#include "TREX.nddl"
#include "rcs/exports.nddl"
#include "rcs/mechanism_control/exports.nddl"
#include "mechanism_control/exports.nddl"

/**
 * @brief Track the state (up or down) of a specific controller in mechanism control
 */
class MechanismController extends AgentTimeline {

  predicate Holds{
    bool is_up;
    defaultOnCommit(is_up, false);
  }

  MechanismController(Mode _mode){
    super(_mode, "Holds");
  }
};

// Same rule expressed for both states
MechanismController::Holds {
  // Values oscillate
  meets(Holds s);
  met_by(Holds p);
  neq(is_up, p.is_up);
  neq(is_up, s.is_up);

  // If and only if required, then link to a command. A better way to handle this?
  bool required;
  testLT(required, end, missionEnd);
  if(required == true){
    ends(SwitchControllers.Active swap_cmd);
    eq(swap_cmd.status, SUCCESS);
  }
}


// Controller State Variables
MechanismController base_controller = new MechanismController(Internal);
MechanismController head_controller = new MechanismController(Internal);
MechanismController laser_tilt_controller = new MechanismController(Internal);
MechanismController r_gripper_effort_controller = new MechanismController(Internal);
MechanismController r_gripper_position_controller = new MechanismController(Internal);
MechanismController r_arm_joint_trajectory_controller = new MechanismController(Internal);
MechanismController r_arm_cartesian_trajectory_controller = new MechanismController(Internal);
MechanismController r_arm_cartesian_twist_controller = new MechanismController(Internal);
MechanismController r_arm_cartesian_wrench_controller = new MechanismController(Internal);
MechanismController r_arm_cartesian_pose_controller = new MechanismController(Internal);
MechanismController r_arm_cartesian_tff_controller = new MechanismController(Internal);

BaseMechanism::use_base_controller{ 
  equals(base_controller.Holds c);
  eq(c.is_up, true);
}

HeadMechanism::use_head_controller{ 
  equals(head_controller.Holds c);
  eq(c.is_up, true);
}

TiltLaserMechanism::use_laser_tilt_controller{ 
  equals(laser_tilt_controller.Holds c);
  eq(c.is_up, true);
}

RightArmMechanism::use_composite_cartesian_controller{
  equals(r_arm_cartesian_wrench_controller.Holds c0);
  eq(c0.is_up, true);
  equals(r_arm_cartesian_twist_controller.Holds c1);
  eq(c1.is_up, true);
  equals(r_arm_cartesian_pose_controller.Holds c2);
  eq(c2.is_up, true);
  equals(r_arm_cartesian_trajectory_controller.Holds c3);
  eq(c3.is_up, true);
}

RightArmMechanism::use_composite_tff_controller{
  equals(r_arm_cartesian_wrench_controller.Holds c0);
  eq(c0.is_up, true);
  equals(r_arm_cartesian_tff_controller.Holds c3);
  eq(c3.is_up, true);
}

RightArmMechanism::use_joint_trajectory_controller{
  equals(r_arm_joint_trajectory_controller.Holds c);
  eq(c.is_up, true);
}

RightArmMechanism::use_cartesian_trajectory_controller{
  equals(r_arm_cartesian_trajectory_controller.Holds c);
  eq(c.is_up, true);
}

RightGripperMechanism::use_effort_controller{
  equals(r_gripper_effort_controller.Holds c);
  eq(c.is_up, true);
}

RightGripperMechanism::use_position_controller{
  equals(r_gripper_position_controller.Holds c);
  eq(c.is_up, true);
}

// Swap Command
SwitchControllers switch_controllers = new SwitchControllers(External);

// Actual mechanisms
BaseMechanism base_mechanism = new BaseMechanism(Internal);
HeadMechanism head_mechanism = new HeadMechanism(Internal);
TiltLaserMechanism laser_tilt_mechanism = new TiltLaserMechanism(Internal);
RightArmMechanism right_arm_mechanism = new RightArmMechanism(Internal);
RightGripperMechanism right_gripper_mechanism = new RightGripperMechanism(Internal);
