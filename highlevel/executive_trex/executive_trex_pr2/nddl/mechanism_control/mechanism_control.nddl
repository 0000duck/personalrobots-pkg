#include "TREX.nddl"
#include "rcs/exports.nddl"
#include "rcs/mechanism_control/exports.nddl"
#include "mechanism_control/exports.nddl"

/**
 * @brief Track the state (up or down) of a specific controller in mechanism control
 */
class MechanismController extends AgentTimeline {

  predicate Holds{
    bool is_up;
    defaultOnCommit(is_up, false);
  }

  MechanismController(Mode _mode){
    super(_mode, "Holds");
  }
};

// Same rule expressed for both states
MechanismController::Holds {
  // Values oscillate
  meets(Holds s);
  met_by(Holds p);
  neq(is_up, p.is_up);
  neq(is_up, s.is_up);

  // If and only if required, then link to a command. A better way to handle this?
  bool required;
  testLT(required, end, missionEnd);
  if(required == true){
    ends(SwitchControllers.Active swap_cmd);
    eq(swap_cmd.status, SUCCESS);
  }
}


// Controller State Variables
MechanismController base_controller_sv = new MechanismController(Internal);
MechanismController head_controller_sv = new MechanismController(Internal);
MechanismController tilt_laser_controller_sv = new MechanismController(Internal);
MechanismController r_gripper_effort_controller_sv = new MechanismController(Internal);
MechanismController r_gripper_position_controller_sv = new MechanismController(Internal);
MechanismController r_arm_joint_trajectory_controller_sv = new MechanismController(Internal);
MechanismController r_arm_cartesian_trajectory_controller_sv = new MechanismController(Internal);
MechanismController r_arm_cartesian_twist_controller_sv = new MechanismController(Internal);
MechanismController r_arm_cartesian_wrench_controller_sv = new MechanismController(Internal);
MechanismController r_arm_cartesian_pose_controller_sv = new MechanismController(Internal);
MechanismController r_arm_cartesian_tff_controller_sv = new MechanismController(Internal);

BaseMechanism::base_controller{ 
  equals(base_controller_sv.Holds c);
  eq(c.is_up, true);
}

HeadMechanism::head_controller{ 
  equals(head_controller_sv.Holds c);
  eq(c.is_up, true);
}

TiltLaserMechanism::tilt_laser_controller{ 
  equals(tilt_laser_controller_sv.Holds c);
  eq(c.is_up, true);
}

RightArmMechanism::composite_cartesian_controller{
  equals(r_arm_cartesian_wrench_controller_sv.Holds c0);
  eq(c0.is_up, true);
  equals(r_arm_cartesian_twist_controller_sv.Holds c1);
  eq(c1.is_up, true);
  equals(r_arm_cartesian_pose_controller_sv.Holds c2);
  eq(c2.is_up, true);
  equals(r_arm_cartesian_trajectory_controller_sv.Holds c3);
  eq(c3.is_up, true);
}

RightArmMechanism::composite_tff_controller{
  equals(r_arm_cartesian_wrench_controller_sv.Holds c0);
  eq(c0.is_up, true);
  equals(r_arm_cartesian_twist_controller_sv.Holds c1);
  eq(c1.is_up, true);
  equals(r_arm_cartesian_pose_controller_sv.Holds c2);
  eq(c2.is_up, true);
  equals(r_arm_cartesian_tff_controller_sv.Holds c3);
  eq(c3.is_up, true);
}

RightArmMechanism::joint_trajectory_controller{
  equals(r_arm_joint_trajectory_controller_sv.Holds c);
  eq(c.is_up, true);
}

RightArmMechanism::cartesian_trajectory_controller{
  equals(r_arm_cartesian_trajectory_controller_sv.Holds c);
  eq(c.is_up, true);
}

RightGripperMechanism::gripper_effort_controller{
  equals(r_gripper_effort_controller_sv.Holds c);
  eq(c.is_up, true);
}

RightGripperMechanism::gripper_position_controller{
  equals(r_gripper_position_controller_sv.Holds c);
  eq(c.is_up, true);
}

// Swap Command
SwitchControllers switch_controllers = new SwitchControllers(External);

// Actual mechanisms
BaseMechanism base_mechanism = new BaseMechanism(Internal);
HeadMechanism head_mechanism = new HeadMechanism(Internal);
TiltLaserMechanism tilt_laser_mechanism = new TiltLaserMechanism(Internal);
RightArmMechanism right_arm_mechanism = new RightArmMechanism(Internal);
RightGripperMechanism right_gripper_mechanism = new RightGripperMechanism(Internal);
