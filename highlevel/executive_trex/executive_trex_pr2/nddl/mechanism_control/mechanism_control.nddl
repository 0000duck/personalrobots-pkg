#include "TREX.nddl"
#include "rcs/exports.nddl"
#include "rcs/mechanism_control/exports.nddl"
#include "mechanism_control/exports.nddl"

AgentActions agent_actions = new AgentActions();

/**
 * @brief Track the state (up or down) of a specific controller in mechanism control
 */
class MechanismController extends AgentTimeline {

  predicate Holds{
    bool is_up;
    defaultOnCommit(is_up, false);
  }

  MechanismController(Mode _mode){
    super(_mode, "Holds");
  }
};

// Same rule expressed for both states
MechanismController::Holds {
  // Values oscillate
  meets(Holds s);
  met_by(Holds p);
  neq(is_up, p.is_up);
  neq(is_up, s.is_up);

  // If and only if required, then link to a command. A better way to handle this?
  bool required;
  testLT(required, end, missionEnd);
  if(required == true){
    ends(SwitchControllers.Active swap_cmd);
    eq(swap_cmd.status, SUCCESS);
  }
}

// Controllers

// Arm controllers that are mutually exclusive
MechanismController r_arm_joint_trajectory_controller = new MechanismController(Internal);
MechanismController r_arm_cartesian_trajectory_controller = new MechanismController(Internal);
MechanismController r_arm_cartesian_tff_controller = new MechanismController(Internal);
MechanismController r_arm_hybrid_controller = new MechanismController(Internal);

// Additional ones
MechanismController r_arm_cartesian_twist_controller = new MechanismController(Internal);
MechanismController r_arm_cartesian_wrench_controller = new MechanismController(Internal);
MechanismController r_arm_cartesian_pose_controller = new MechanismController(Internal);
MechanismController head_controller = new MechanismController(Internal);
MechanismController laser_tilt_controller = new MechanismController(Internal);
MechanismController r_gripper_effort_controller = new MechanismController(Internal);
MechanismController r_gripper_position_controller = new MechanismController(Internal);

// Constraint controllers
MechanismController r_arm_constraint_cartesian_twist_controller = new MechanismController(Internal);
MechanismController r_arm_constraint_cartesian_wrench_controller = new MechanismController(Internal);
MechanismController r_arm_constraint_cartesian_pose_controller = new MechanismController(Internal);
MechanismController r_arm_constraint_cartesian_trajectory_controller = new MechanismController(Internal);

HeadMechanism::use_head_controller{ 
  contains(AgentActions.startEvent);
  contained_by(head_controller.Holds c);
  eq(c.is_up, true);
}

TiltLaserMechanism::use_laser_tilt_controller{ 
  contains(AgentActions.startEvent);
  contained_by(laser_tilt_controller.Holds c);
  eq(c.is_up, true);
}

RightArmMechanism::use_composite_cartesian_trajectory_controller{
  contains(AgentActions.startEvent);
  contained_by(r_arm_cartesian_wrench_controller.Holds c0);
  eq(c0.is_up, true);
  contained_by(r_arm_cartesian_twist_controller.Holds c1);
  eq(c1.is_up, true);
  contained_by(r_arm_cartesian_pose_controller.Holds c2);
  eq(c2.is_up, true);
  contained_by(r_arm_cartesian_trajectory_controller.Holds c3);
  eq(c3.is_up, true);

  // We also require certain other controllers are down
  contained_by(r_arm_cartesian_tff_controller.Holds down_0);
  eq(down_0.is_up, false);
  contained_by(r_arm_joint_trajectory_controller.Holds down_1);
  eq(down_1.is_up, false);
  contained_by(r_arm_hybrid_controller.Holds c5);
  eq(c5.is_up, false);

  // This is ugly. We should not have to explicitly restate the mutex
  contained_by(r_arm_constraint_cartesian_wrench_controller.Holds d0);
  eq(d0.is_up, false);
  contained_by(r_arm_constraint_cartesian_twist_controller.Holds d1);
  eq(d1.is_up, false);
  contained_by(r_arm_constraint_cartesian_pose_controller.Holds d2);
  eq(d2.is_up, false);
  contained_by(r_arm_constraint_cartesian_trajectory_controller.Holds d3);
  eq(d3.is_up, false);
}


RightArmMechanism::use_constraint_composite_cartesian_trajectory_controller{
  contains(AgentActions.startEvent);
  contained_by(r_arm_constraint_cartesian_wrench_controller.Holds c0);
  eq(c0.is_up, true);
  contained_by(r_arm_constraint_cartesian_twist_controller.Holds c1);
  eq(c1.is_up, true);
  contained_by(r_arm_constraint_cartesian_pose_controller.Holds c2);
  eq(c2.is_up, true);
  contained_by(r_arm_constraint_cartesian_trajectory_controller.Holds c3);
  eq(c3.is_up, true);

  // We also require certain other controllers are down
  contained_by(r_arm_cartesian_tff_controller.Holds down_0);
  eq(down_0.is_up, false);
  contained_by(r_arm_joint_trajectory_controller.Holds down_1);
  eq(down_1.is_up, false);
  contained_by(r_arm_hybrid_controller.Holds down_2);
  eq(down_2.is_up, false);

  // This is ugly. We should not have to explicitly restate the mutex
  contained_by(r_arm_cartesian_wrench_controller.Holds d0);
  eq(d0.is_up, false);
  contained_by(r_arm_cartesian_twist_controller.Holds d1);
  eq(d1.is_up, false);
  contained_by(r_arm_cartesian_pose_controller.Holds d2);
  eq(d2.is_up, false);
  contained_by(r_arm_cartesian_trajectory_controller.Holds d3);
  eq(d3.is_up, false);
}

RightArmMechanism::use_constraint_composite_cartesian_pose_controller{
  contains(AgentActions.startEvent);
  contained_by(r_arm_constraint_cartesian_wrench_controller.Holds c0);
  eq(c0.is_up, true);
  contained_by(r_arm_constraint_cartesian_twist_controller.Holds c1);
  eq(c1.is_up, true);
  contained_by(r_arm_constraint_cartesian_pose_controller.Holds c2);
  eq(c2.is_up, true);

  // We also require certain other controllers are down
  contained_by(r_arm_cartesian_tff_controller.Holds down_0);
  eq(down_0.is_up, false);
  contained_by(r_arm_joint_trajectory_controller.Holds down_1);
  eq(down_1.is_up, false);
  contained_by(r_arm_hybrid_controller.Holds c5);
  eq(c5.is_up, false);
  contained_by(r_arm_cartesian_trajectory_controller.Holds c3);
  eq(c3.is_up, false);

  contained_by(r_arm_cartesian_wrench_controller.Holds d0);
  eq(d0.is_up, false);
  contained_by(r_arm_cartesian_twist_controller.Holds d1);
  eq(d1.is_up, false);
  contained_by(r_arm_cartesian_pose_controller.Holds d2);
  eq(d2.is_up, false);
  contained_by(r_arm_constraint_cartesian_trajectory_controller.Holds d3);
  eq(d3.is_up, false);
}


RightArmMechanism::use_composite_tff_controller{
  contains(AgentActions.startEvent);
  contained_by(r_arm_constraint_cartesian_wrench_controller.Holds c0);
  eq(c0.is_up, true);
  contained_by(r_arm_cartesian_tff_controller.Holds c1);
  eq(c1.is_up, true);

  // All others should be down
  contained_by(r_arm_joint_trajectory_controller.Holds c2);
  eq(c2.is_up, false);
  contained_by(r_arm_cartesian_twist_controller.Holds c3);
  eq(c3.is_up, false);
  contained_by(r_arm_cartesian_pose_controller.Holds c4);
  eq(c4.is_up, false);
  contained_by(r_arm_cartesian_trajectory_controller.Holds c5);
  eq(c5.is_up, false);
  contained_by(r_arm_hybrid_controller.Holds c6);
  eq(c6.is_up, false);

  // This is ugly. We should not have to explicitly restate the mutex
  contained_by(r_arm_cartesian_wrench_controller.Holds d0);
  eq(d0.is_up, false);
  contained_by(r_arm_constraint_cartesian_twist_controller.Holds d1);
  eq(d1.is_up, false);
  contained_by(r_arm_constraint_cartesian_pose_controller.Holds d2);
  eq(d2.is_up, false);
  contained_by(r_arm_constraint_cartesian_trajectory_controller.Holds d3);
  eq(d3.is_up, false);
}

RightArmMechanism::use_joint_trajectory_controller{
  contains(AgentActions.startEvent);
  contained_by(r_arm_joint_trajectory_controller.Holds c);
  eq(c.is_up, true);

  // All others should be down
  contained_by(r_arm_cartesian_wrench_controller.Holds c0);
  eq(c0.is_up, false);
  contained_by(r_arm_cartesian_twist_controller.Holds c1);
  eq(c1.is_up, false);
  contained_by(r_arm_cartesian_pose_controller.Holds c2);
  eq(c2.is_up, false);
  contained_by(r_arm_cartesian_trajectory_controller.Holds c3);
  eq(c3.is_up, false);
  contained_by(r_arm_cartesian_tff_controller.Holds c4);
  eq(c4.is_up, false);
  contained_by(r_arm_hybrid_controller.Holds c5);
  eq(c5.is_up, false);

  // This is ugly. We should not have to explicitly restate the mutex
  contained_by(r_arm_constraint_cartesian_wrench_controller.Holds d0);
  eq(d0.is_up, false);
  contained_by(r_arm_constraint_cartesian_twist_controller.Holds d1);
  eq(d1.is_up, false);
  contained_by(r_arm_constraint_cartesian_pose_controller.Holds d2);
  eq(d2.is_up, false);
  contained_by(r_arm_constraint_cartesian_trajectory_controller.Holds d3);
  eq(d3.is_up, false);
}

RightArmMechanism::use_cartesian_trajectory_controller{
  contains(AgentActions.startEvent);
  contained_by(r_arm_cartesian_trajectory_controller.Holds c);
  eq(c.is_up, true);

  // All others should be down
  contained_by(r_arm_cartesian_wrench_controller.Holds c0);
  eq(c0.is_up, false);
  contained_by(r_arm_cartesian_twist_controller.Holds c1);
  eq(c1.is_up, false);
  contained_by(r_arm_cartesian_pose_controller.Holds c2);
  eq(c2.is_up, false);
  contained_by(r_arm_joint_trajectory_controller.Holds c3);
  eq(c3.is_up, false);
  contained_by(r_arm_cartesian_tff_controller.Holds c4);
  eq(c4.is_up, false);

  contained_by(r_arm_hybrid_controller.Holds c5);
  eq(c5.is_up, false);

  // This is ugly. We should not have to explicitly restate the mutex
  contained_by(r_arm_constraint_cartesian_wrench_controller.Holds d0);
  eq(d0.is_up, false);
  contained_by(r_arm_constraint_cartesian_twist_controller.Holds d1);
  eq(d1.is_up, false);
  contained_by(r_arm_constraint_cartesian_pose_controller.Holds d2);
  eq(d2.is_up, false);
  contained_by(r_arm_constraint_cartesian_trajectory_controller.Holds d3);
  eq(d3.is_up, false);
}


RightArmMechanism::use_hybrid_controller{
  contains(AgentActions.startEvent);

  contained_by(r_arm_hybrid_controller.Holds c);
  eq(c.is_up, true);

  contained_by(r_arm_cartesian_wrench_controller.Holds c0);
  eq(c0.is_up, false);
  contained_by(r_arm_cartesian_twist_controller.Holds c1);
  eq(c1.is_up, false);
  contained_by(r_arm_cartesian_pose_controller.Holds c2);
  eq(c2.is_up, false);
  contained_by(r_arm_cartesian_trajectory_controller.Holds c3);
  eq(c3.is_up, false);

  // We also require certain other controllers are down
  contained_by(r_arm_cartesian_tff_controller.Holds down_0);
  eq(down_0.is_up, false);
  contained_by(r_arm_joint_trajectory_controller.Holds down_1);
  eq(down_1.is_up, false);

  // This is ugly. We should not have to explicitly restate the mutex
  contained_by(r_arm_constraint_cartesian_wrench_controller.Holds d0);
  eq(d0.is_up, false);
  contained_by(r_arm_constraint_cartesian_twist_controller.Holds d1);
  eq(d1.is_up, false);
  contained_by(r_arm_constraint_cartesian_pose_controller.Holds d2);
  eq(d2.is_up, false);
  contained_by(r_arm_constraint_cartesian_trajectory_controller.Holds d3);
  eq(d3.is_up, false);
}

RightGripperMechanism::use_effort_controller{
  contains(AgentActions.startEvent);
  contained_by(r_gripper_effort_controller.Holds c);
  eq(c.is_up, true);

  contained_by(r_gripper_position_controller.Holds c1);
  eq(c1.is_up, false);
}

RightGripperMechanism::use_position_controller{
  contains(AgentActions.startEvent);
  contained_by(r_gripper_position_controller.Holds c);
  eq(c.is_up, true);

  contained_by(r_gripper_effort_controller.Holds c1);
  eq(c1.is_up, false);
}

// Swap Command
SwitchControllers switch_controllers = new SwitchControllers(External);

// Actual mechanisms
HeadMechanism head_mechanism = new HeadMechanism(Internal);
TiltLaserMechanism laser_tilt_mechanism = new TiltLaserMechanism(Internal);
RightArmMechanism right_arm_mechanism = new RightArmMechanism(Internal);
RightGripperMechanism right_gripper_mechanism = new RightGripperMechanism(Internal);
