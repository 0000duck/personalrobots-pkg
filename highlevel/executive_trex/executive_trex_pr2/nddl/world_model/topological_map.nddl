/***********************************************************************
 * External functions and relations for working with the topological map
 ***********************************************************************/

// Define a MAP_KEY type to give positive integer id's for keys in the topological mapp
typedef int [0 100000] MAP_KEY;

// A 0 key value indicates no key, and thus no map entity
MAP_KEY NO_KEY = 0;

// A function that will be executed to load the topological map
constraint map_initialize_from_file(fileName) { fileName <: string }

// A relation: given a connector, bind the x, y the values. Given x, and y, bind the connector
constraint map_connector(connection_id, x, y, th) { connection_id <: MAP_KEY && x <: numeric && y <: numeric && th <: numeric }

// A function: given an x,y position, bind a region.
constraint map_get_region_from_position(region_id, x, y){ region_id <: MAP_KEY && x <: numeric && y <: numeric }

// A function: given a pair of 2d points, return the doorway containing their mid-point. If not a doorway, then
// it will return a NO_KEY
constraint map_get_doorway_from_points(region_id, x1, y1, x2, y2){ region_id <: MAP_KEY && x1 <: numeric && y1 <: numeric && x2 <: numeric && y2 <: numeric }

// A function to query if a region is a doorway
constraint map_is_doorway(result, region_id) { result <: bool && region_id <: MAP_KEY }

// A function to get all door state data (a full door message) and fill it into the parameters if a token. If I had structured
// data types I would not have to do it like this!
constraint map_get_door_state(object, door_id) {object <: Object && door_id <: MAP_KEY}

/***********************************************************************
 * Types related to a semantic view of the map
 ***********************************************************************/

/**
 * A predefined location to go to
 */
class Location {
  float x;
  float y;
  float z;
  float qx;
  float qy;
  float qz;
  float qw;

  Location(float x_, float y_, float z_, float qx_, float qy_, float qz_, float qw_){
    x = x_;
    y = y_;
    z = z_;
    qx = qx_;
    qy = qy_;
    qz = qz_;
    qw = qw_;
  }
};

class Waypoint extends Location {
  Waypoint(float x_, float y_, float z_, float qx_, float qy_, float qz_, float qw_){
    super(x_, y_, z_, qx_, qy_, qz_, qw_);
  }
};

/**
 * @brief Charging Stations
 */
class ChargingStation extends Location {
  ChargingStation(float x_, float y_, float z_, float qx_, float qy_, float qz_, float qw_){
    super(x_, y_, z_, qx_, qy_, qz_, qw_);
  }
};
