/**
 * This file defines the door controller behavior as an implementation of the MoveBehavior for
 * traversing a doorway. It lays out the higher level logic that aggregates door domain actions
 */

#include "doors/imports.nddl"


typedef int [-1, 1] TIME_ERROR_BOUND;

// Introduce a constriant to set a time for forcing us to chekc the door based on the door check interval
int FORCE_DOOR_CHECK;
addEq(FORCE_DOOR_CHECK, DOOR_CHECK_INTERVAL, 0);


// Error Bounds
float DETECTION_POSITION_ERROR = 0.1;
float GRASP_POSITION_ERROR = 0.1;

/**
 * This is an internal controller which will monitor state variables and HLC status. It can also generate
 * next steps for this meta level control. This pattern exploits reactive planning based on feedback from the
 * environment.
 */
class DoorController extends AgentTimeline {

  bool integrated; // When true, force interaction wth MoveBehavior

  /**
   * The parameters here 
   */
  predicate Holds{
    bool active;

    bool found_door;
    bool found_handle; // Should Cover this!
    MAYBE_TRUE_OR_FALSE have_handle;
    bool door_latched;
    bool doorway_clear;
    int last_checked_door; // Time for when we last checked the doorway

    // Target base pose for getting to on the other side of the doorway.
    float target_x;
    float target_y;
    float target_th;
  }

  DoorController(Mode _mode){
    super(_mode, "Holds");
    integrated = false;
  }

  DoorController(Mode _mode, bool _integrated){
    super(_mode, "Holds");
    integrated = _integrated;
  }
};


MoveBehavior::Inactive {
  // Only apply this condition when it has started. Do not want to plan it in advance.
  if(start){
    equals(DoorController.Holds dc);
    eq(dc.active, false);
  }

  // If it has been aborted, send an update with current the current current and target positions
  if(status == ABORTED){
    any(BaseState.Holds bs);
    precedes(bs.start, start);
    temporalDistance(start, [1 +inf], bs.end);
    starts_before(NotifyDoorBlocked.Active cmd);
    precedes(cmd.end, end);
  }
}

MoveBehavior::Active {
  starts_before(DoorController.Holds dc);
  precedes(dc.end, end);

  // Initialize controller variables. We begin by assuming the worst. Note that the test for being in detection
  // position is derived from base state data directly and thus not subject to setting as a free control variable
  eq(dc.active, true);
  eq(dc.found_door, false);
  eq(dc.found_handle, false);
  eq(dc.have_handle, MAYBE);
  eq(dc.door_latched, true);
  eq(dc.doorway_clear, false);
  eq(dc.last_checked_door, FORCE_DOOR_CHECK);
}


/** 
 * In full integration we apply additional rules to tie the door controller with a MoveBehavior. This is not the case
 * under certain test conditions where we wish to enter the state machine at any point
 */
DoorController::Holds {

  if(integrated == true){
    // If inactive, the move behavior must also be inactive
    if(active == false){
      contained_by(MoveBehavior.Inactive);
    }
  
    // If active, constrain with respect to a containing move behavior
    if(active == true){
      // MoveBehavior(all) == Active(target_x, target_y, target_th)   
      contained_by(MoveBehavior.Active dm);
      eq(dm.x, target_x);
      eq(dm.y, target_y);
      eq(dm.th, target_th);
    }
  }
}

/**
 * This rule fires essentially a TR-style decision tree to select
 * the next action to take. The action choices are(in reverse order):
 * - ReleaseDoor
 * - OpenDoorWithGrasp
 * - GraspHandle
 * - MoveBase (x 2)
 * - OpenDoorWithoutGrasp
 * - DetectDoor
 * - DetectHandle
 * - CheckDoor
 *
 * Note the pattern that uses a flexible temporal interval for constraining the relationshop between the
 * completion time of the selected action, and the end time of this control step. This flexibility accounts for
 * the fact that an exogenous event can trip the state forcing a planned preemption of the active command, and the
 * completion of the command should also bring about a completion of the given control step
 */
DoorController::Holds {
  // We will assume default values on commitment based on predecessor. We really want these values to be bound. These values carry
  // forward from priors as they are updated by actions and we thus assume inertia
  met_by(Holds p);
  defaultOnCommit(active, p.active);
  defaultOnCommit(found_door, p.found_door);
  defaultOnCommit(found_handle, p.found_handle);
  defaultOnCommit(have_handle, p.have_handle);
  defaultOnCommit(door_latched, p.door_latched);
  defaultOnCommit(doorway_clear, p.doorway_clear);
  defaultOnCommit(last_checked_door, p.last_checked_door);

  // If we are active, then we must evaluate different states based on current base, door , and handle state
  if(active == true){

    // Local variables, derived from sensors and map
    MAP_KEY door_id; // The door id for this doorway
    bool in_detection_position; // True if far enough from the door to scan effectively. Else false
    bool in_grasp_position; // True if far enough from the door to scan effectively, Can only be evaluated

    // The end bound defined here provides a margin of error around the connection between the end time of the
    // command issued here, and the end time of the control step.
    int end_bounds;
    temporalDistance(end, [-1, 1], end_bounds);

    // Is the doorway clear? No special checks are required for this. We can do it any time
    if(doorway_clear == true){

      // If we do not have the handle then we are good to go, so we just terminate with success
      if(have_handle == FALSE){
	meets(MoveBehavior.Inactive mb);
	eq(mb.status, SUCCESS);
	eq(duration, 1);
      }
      else {
	// If true or maybe then we should release the door just to be safe. Could do a sensing action
	// but I am expecting that releasing the door doubles as a sensing action
	// ReleaseDoor([start, +inf], end + [-1, 1]] == Active;
	starts_before(ReleaseDoor.Active cmd);
	concurrent(cmd.end, end_bounds);
      }
    }

    if(doorway_clear == false){

      // We might want to recheck the doorway. Alternately we could include such an observation in the door
      // monitoring code.
      bool recheck_doorway;
      int elapsed_time_since_last_check;
      addEq(last_checked_door, elapsed_time_since_last_check, start);
      testLEQ(recheck_doorway, DOOR_CHECK_INTERVAL, elapsed_time_since_last_check);
      if(recheck_doorway == true){
	starts_before(CheckDoorway.Active cmd);
	concurrent(cmd.end, end_bounds);
	eq(cmd.x, target_x);
	eq(cmd.y, target_y);
	eq(cmd.th, target_th);
      }

      if(recheck_doorway == false){

	if(have_handle == TRUE) {
	  // OpenDoorWithGrasp(any, end_bounds] == Active();
	  starts_before(OpenDoorWithGrasp.Active cmd);
	  concurrent(cmd.end, end_bounds);
	}
	else {
	  // BaseState.Holds bs = base_state(start);
	  any(BaseState.Holds bs);
	  precedes(bs.start, start);
	  temporalDistance(start, [1 +inf], bs.end);

	  // Access the map to get the door given 2 points - where I am and where I am trying to get 2. Both points should be in or very near the
	  // doorway region
	  map_get_door_from_position(door_id, bs.x, bs.y, target_x, target_y);

	  // We need door position information here
	  float x1, y1, x2, y2;
	  map_get_door_data(x1, y1, x2, y2, door_id);

	  if(found_handle == true){
	    // Are we in a grasp position? Now is a good time to find out. We will query the map. This data will have to be laid out
	    // in more detail.
	    float grasp_x, grasp_y, grasp_th;
	    get_door_grasp_base_position(grasp_x, grasp_y, grasp_th, x1, y1, x2, y2);

	    // @todo We should probably treat position and orientation seperately for tolerances
	    float distanceAway;
	    calcDistance(distanceAway, bs.x, bs.y, bs.th, grasp_x, grasp_y, grasp_th);
	    testLEQ(in_grasp_position, distanceAway, GRASP_POSITION_ERROR);

	    if(in_grasp_position == true){
	      // GraspHandle(any, end_bounds] == Active();
	      starts_before(GraspHandle.Active cmd);
	      concurrent(cmd.end, end_bounds);
	    }
	    else {
	      // MoveBase(any, end_bounds] == Active();
	      starts_before(MoveBase.Active cmd);
	      concurrent(cmd.end, end_bounds);
	      eq(cmd.x, grasp_x);
	      eq(cmd.y, grasp_y);
	      eq(cmd.th, grasp_th);
	    }
	  }

	  if(found_handle == false){

	    if(found_door == true){
	      // DetectHandle(any, end_bounds] == Active()
	      starts_before(DetectHandle.Active cmd);
	      concurrent(cmd.end, end_bounds);
	    }
	    else {
	      float detect_x, detect_y, detect_th;
	      get_door_detection_base_position(detect_x, detect_y, detect_th, x1, y1, x2, y2);
	      float distanceAway;
	      calcDistance(distanceAway, bs.x, bs.y, bs.th, detect_x, detect_y, detect_th);
	      testLEQ(in_detection_position, distanceAway, DETECTION_POSITION_ERROR);

	      if(in_detection_position == true){
		// DetectDoor(any, end_bounds] == Active();
		starts_before(DetectDoor.Active cmd);
		concurrent(cmd.end, end_bounds);
	      }
	      else {
		// MoveBase(any, end_bounds] == Active(detect_x, detect_y, detect_th);
		starts_before(MoveBase.Active cmd);
		concurrent(cmd.end, end_bounds);
		eq(cmd.x, detect_x);
		eq(cmd.y, detect_y);
		eq(cmd.th, detect_th);
	      }
	    }
	  }
	}
      }
    }
  }
}


/************************************************************************
 * Now we define how actions update the door controller by setting
 * feedback parameters on success or failure
 ***********************************************************************/

DoorState::Holds{
  met_by(Holds p);

  // Commit to unknown values if nothing set
  defaultOnCommit(hinge, UNKNOWN);
  defaultOnCommit(rot_dir, UNKNOWN);

  // Active status
  defaultOnCommit(active, p.active);

  // Points for the door frame. 
  defaultOnCommit(frame_p1_x, p.frame_p1_x);
  defaultOnCommit(frame_p1_y, p.frame_p1_y);
  defaultOnCommit(frame_p1_z, p.frame_p1_z);
  defaultOnCommit(frame_p2_z, p.frame_p2_x);
  defaultOnCommit(frame_p2_z, p.frame_p2_y);
  defaultOnCommit(frame_p2_z, p.frame_p2_z);

  // Points for th door
  defaultOnCommit(door_p1_x, p.door_p1_x);
  defaultOnCommit(door_p1_y, p.door_p1_y);
  defaultOnCommit(door_p1_z, p.door_p1_z);
  defaultOnCommit(door_p2_z, p.door_p2_x);
  defaultOnCommit(door_p2_z, p.door_p2_y);
  defaultOnCommit(door_p2_z, p.door_p2_z);

  // Handle data
  defaultOnCommit(height, p.height);
  defaultOnCommit(hinge, p.hinge);
  defaultOnCommit(rot_dir, p.rot_dir);
}

// Derive input bounds form the behavior
DoorManipulationBehavior::Active{
  // DoorController(start) == Holds(dc);
  any(DoorController.Holds dc);
  precedes(dc.start, start);
  temporalDistance(start, [1 +inf], dc.end);

  if(dc.active == true){
    // Update the door state with feedback I would really like to be able to say:
    // eq(door_data, ds.door_data)
    // and have that be the same as an iterative eq() over the components of a variable structure.
    // DoorState(all) == Holds(true, door_data);
    contained_by(DoorState.Holds ds);
    eq(ds.active, true);
    get_state(this.state, ds.state);
  }
}

DoorManipulationBehavior::Inactive{

  if(status == SUCCESS){
    // Update the door state with feedback I would really like to be able to say:
    // eq(door_data, ds.door_data)
    // and have that be the same as an iterative eq() over the components of a variable structure.
    // DoorState[start) == Holds(true, door_data);
    starts(DoorState.Holds ds);
    eq(ds.active, true);
    get_state(this.state, ds.state);
  }
}

ReleaseDoor::Inactive{

  // If successful it means we were able to execute the check. The result can still be clear or not
  if(status == SUCCESS){
    // This is a common pattern for all - to bind to the door controller
    // DoorController[start + TIME_ERROR_BOUND) dc == Holds;
    any(DoorController.Holds dc);
    TIME_ERROR_BOUND error;
    temporalDistance(dc.start, error, start);
    eq(dc.have_handle, FALSE);
    eq(dc.last_checked_door, FORCE_DOOR_CHECK);
    concurrent(dc.start, start);
  }
}

OpenDoorWithGrasp::Inactive{

  // If successful, update the state with feedback. Note that at this point we could
  // set values for door and handle state. On the other hand, we could also just
  // start a door detector
  if(status == SUCCESS){
    // Update door controller with feedback
    any(DoorController.Holds dc);
    TIME_ERROR_BOUND error;
    temporalDistance(dc.start, error, start);
    eq(dc.last_checked_door, FORCE_DOOR_CHECK);
    eq(dc.have_handle, TRUE);
    concurrent(dc.start, start);
  }
}

GraspHandle::Inactive{

  // If successful, update the state with feedback. Note that at this point we could
  // set values for door and handle state. On the other hand, we could also just
  // start a door detector
  if(status == SUCCESS){
    // Update door controller with feedback
    any(DoorController.Holds dc);
    TIME_ERROR_BOUND error;
    temporalDistance(dc.start, error, start);
    eq(dc.have_handle, TRUE);
    eq(dc.last_checked_door, start);
    concurrent(dc.start, start);
  }
}

OpenDoorWithoutGrasp::Inactive{

  // If successful, there is nothing really to do, since it will depend on the CheckDoorway
  // behavior finding the clear path. What we can do is reset the last checked time to force an immediate recheck
  if(status == SUCCESS){
    // Update door controller with feedback
    any(DoorController.Holds dc);
    TIME_ERROR_BOUND error;
    temporalDistance(dc.start, error, start);
    eq(dc.last_checked_door, FORCE_DOOR_CHECK);
    concurrent(dc.start, start);
  }
}

DetectDoor::Inactive{

  // If successful, update the state with feedback. Note that at this point we could
  // set values for door and handle state. On the other hand, we could also just
  // start a door detector
  if(status == SUCCESS){
    // Update door controller with feedback
    any(DoorController.Holds dc);
    TIME_ERROR_BOUND error;
    temporalDistance(dc.start, error, start);
    eq(dc.found_door, true);
    eq(dc.found_handle, true);
    concurrent(dc.start, start);
  }
}

CheckDoorway::Inactive{

  // If successful it means we were able to execute the check. The result can still be clear or not
  if(status == SUCCESS){
    // Update door controller with feedback
    any(DoorController.Holds dc);
    TIME_ERROR_BOUND error;
    temporalDistance(dc.start, error, start);
    eq(dc.doorway_clear, doorway_clear);
    eq(dc.door_latched, door_latched);
    eq(dc.last_checked_door, start);
    concurrent(dc.start, start);
  }
}

// Internal - controller must be allocated separately
MoveBehavior doorman = new MoveBehavior(Internal, true);
DoorState door_state = new DoorState(Internal);
