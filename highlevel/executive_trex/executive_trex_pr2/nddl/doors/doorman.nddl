/**
 * Provides full functionality of the doorman. Here we integrate with the topological map.
 */
#include "doors/door_controller.nddl"
#include "world_model/topological_map.nddl"

MoveBehavior::Inactive {
  // If it has been aborted, send an update with current the current current and target positions
  if(status == ABORTED){
    met_by(Active p);
    MAP_KEY doorway_id;
    neq(doorway_id, NO_KEY);
    float current_x, current_y, current_z, current_qx, current_qy, current_qz, current_qw;
    tf_get_robot_pose(current_x, current_y, current_z, current_qx, current_qy, current_qz, current_qw, "map");
    map_get_doorway_from_points(doorway_id, current_x, current_y, p.x, p.y);
    map_notify_door_blocked(doorway_id);
  }
}

MoveBehavior::Active {
  starts(DoorController.Holds dc);

  // Initialize controller variables. We begin by assuming the worst.
  eq(dc.active, true);	 
  eq(dc.in_position, false);
  eq(dc.found_door, false);
  eq(dc.must_find_handle, true);
  eq(dc.have_handle, false);
  eq(dc.latch_state, UNKNOWN);
  eq(dc.doorway_clear, false);
  eq(dc.check_doorway, true);
  eq(dc.finishing, false);

  // Initialize door message from the topological map
  MAP_KEY doorway_id;
  neq(doorway_id, NO_KEY);
  float current_x, current_y, current_z, current_qx, current_qy, current_qz, current_qw;
  tf_get_robot_pose(current_x, current_y, current_z, current_qx, current_qy, current_qz, current_qw, "map");
  map_get_doorway_from_points(doorway_id, current_x, current_y, x, y);
  starts(door_state.Holds ds);
  map_get_door_state(ds.object, doorway_id);
  eq(ds.frame_id, frame_id);
}
