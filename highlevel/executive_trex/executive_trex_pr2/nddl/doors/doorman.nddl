/**
 * This file defines the door controller behavior as an implementation of the MoveBehavior for
 * traversing a doorway. It lays out the higher level logic that aggregates door domain actions
 */




MoveBehavior::Inactive {
  // Only apply this condition when it has started. Do not want to plan it in advance.
  if(start){
    equals(DoorController.Holds dc);
    eq(dc.active, false);
  }

  // If it has been aborted, send an update with current the current current and target positions
  if(status == ABORTED){
    any(BaseState.Holds bs);
    precedes(bs.start, start);
    temporalDistance(start, [1 +inf], bs.end);
    starts_before(NotifyDoorBlocked.Active cmd);
    precedes(cmd.end, end);
  }
}

MoveBehavior::Active {
  starts_before(DoorController.Holds dc);
  precedes(dc.end, end);

  // Initialize controller variables. We begin by assuming the worst. Note that the test for being in detection
  // position is derived from base state data directly and thus not subject to setting as a free control variable
  eq(dc.active, true);
  eq(dc.found_door, false);
  eq(dc.found_handle, false);
  eq(dc.have_handle, MAYBE);
  eq(dc.door_latched, true);
  eq(dc.doorway_clear, false);
  eq(dc.last_checked_door, FORCE_DOOR_CHECK);
}


/** 
 * In full integration we apply additional rules to tie the door controller with a MoveBehavior. This is not the case
 * under certain test conditions where we wish to enter the state machine at any point
 */
DoorController::Holds {

  if(object.integrated == true){
    // If inactive, the move behavior must also be inactive
    if(active == false){
      contained_by(MoveBehavior.Inactive);

    }
  
    // If active, constrain with respect to a containing move behavior
    if(active == true){
      // MoveBehavior(all) == Active(target_x, target_y, target_th)   
      contained_by(MoveBehavior.Active dm);
      eq(dm.x, target_x);
      eq(dm.y, target_y);
      eq(dm.th, target_th);
    }
  }
}
