/**
 * @author Conor McGann
 * @brief Declares and Defines actions for testing the door domain at a pretty low level
 * @requires world_model
 */
class DoorActions extends AgentActions{

  /**
   * @brief An action to open the door, with no branching
   * @param The doorway region id in the topological map
   * @see OpenDoorByDoorState
   */
  predicate OpenDoorById{
    MAP_KEY doorway_id;
  }

  /**
   * @brief An action to open a door given by a frame. Does not use the topological map
   */
  predicate OpenDoorByDoorState{
    // Points for the door frame
    float frame_p1_x;
    float frame_p1_y;
    float frame_p1_z;
    float frame_p2_x;
    float frame_p2_y;
    float frame_p2_z;

    // Points for the door
    float door_p1_x;
    float door_p1_y;
    float door_p1_z;
    float door_p2_x;
    float door_p2_y;
    float door_p2_z;

    // Handle data
    float height;
    HINGE_FRAME hinge;
    ROTATION_DIRECTION rot_dir;
  }
};


/**
 * This one uses the topological map throughout
 */
DoorActions::OpenDoorById{
  // Verify it is a valid id
  neq(doorway_id, NO_KEY);

  // Here is the basic sequence. First introduce the components
  contains(MoveBase.Active cmd_move_to_detect);
  contains(DetectDoor.Active cmd_detect_door);
  contains(MoveBase.Active cmd_go_to_grasp_position);
  contains(GraspHandle.Active cmd_grasp_handle);
  contains(OpenDoorWithGrasp.Active cmd_open_door);

  // Impose ordering constraints
  cmd_move_to_detect before cmd_detect_door;
  cmd_detect_door before cmd_go_to_grasp_position;
  cmd_go_to_grasp_position before cmd_grasp_handle;
  cmd_grasp_handle before cmd_open_door;

  // Require that all actions are successul. If one fails, they all fail.
  eq(SUCCESS, 
     cmd_move_to_detect.status,
     cmd_detect_door.status, 
     cmd_go_to_grasp_position.status, 
     cmd_grasp_handle.status, 
     cmd_open_door.status);

  // Get door data from the world model. This initial data is used to guide the door detector
  map_get_door_state(cmd_detect_door.state, doorway_id);

  // Obtain the detection base location based on the door data from this initial state value
  door_get_robot_pose_for_door(cmd_move_to_detect.x, cmd_move_to_detect.y, cmd_move_to_detect.th,
			       cmd_detect_door.door_p1_x, cmd_detect_door.door_p1_y, cmd_detect_door.door_p2_x, cmd_detect_door.door_p2_y,
			       DETECTION_RANGE);

  // Bindings below are conditional because the world model will be evolving as underlying actions execute. The guard will not evaluate
  // until they have ended. Door State updates will flow from one action to another
  if(cmd_detect_door.end){ map_get_door_state(cmd_grasp_handle.state, doorway_id); }
  if(cmd_grasp_handle.end){ map_get_door_state(cmd_open_door.state, doorway_id); }
 
  // The base position for grasping is a function of the door state after we have detected the door, and thus the bound value in the door detection action
  door_get_robot_pose_for_door(cmd_go_to_grasp_position.x, cmd_go_to_grasp_position.y, cmd_go_to_grasp_position.th,
			       cmd_grasp_handle.door_p1_x, cmd_grasp_handle.door_p1_y, cmd_grasp_handle.door_p2_x, cmd_grasp_handle.door_p2_y,
			       GRASP_RANGE);
}

DoorActions::OpenDoorByDoorState{
  // Here is the basic sequence. First introduce the components
  any(MoveBase.Inactive cmd_move_to_detect);
  any(DetectDoor.Inactive cmd_detect_door);
  any(MoveBase.Inactive cmd_go_to_grasp_position);
  any(GraspHandle.Inactive cmd_grasp_handle);
  any(OpenDoorWithGrasp.Inactive cmd_open_door);

  // Impose ordering constraints
  precedes(start, cmd_move_to_detect.start);
  precedes(cmd_move_to_detect.start, cmd_detect_door.start);
  precedes(cmd_detect_door.start, cmd_go_to_grasp_position.start);
  precedes(cmd_go_to_grasp_position.start, cmd_grasp_handle.start);
  precedes(cmd_grasp_handle.start, cmd_open_door.start);
  precedes(cmd_open_door.start, end);

  // Require that all actions are successul. If one fails, they all fail.
  eq(SUCCESS, 
     cmd_move_to_detect.status,
     cmd_detect_door.status, 
     cmd_go_to_grasp_position.status, 
     cmd_grasp_handle.status, 
     cmd_open_door.status);

  // Flow feedback from one to another. Seeded by input parameters
  get_state(cmd_detect_door.state, this.state);
  get_state(cmd_grasp_handle.state, cmd_detect_door.state);
  get_state(cmd_open_door.state, cmd_grasp_handle.state);


  // Obtain the detection base location based on the door data from this initial state value
  door_get_robot_pose_for_door(cmd_move_to_detect.x, cmd_move_to_detect.y, cmd_move_to_detect.th,
			       cmd_detect_door.door_p1_x, cmd_detect_door.door_p1_y, cmd_detect_door.door_p2_x, cmd_detect_door.door_p2_y,
			       DETECTION_RANGE);

  // The base position for grasping is a function of the door state after we have detected the door, and thus the bound value in the door detection action
  door_get_robot_pose_for_door(cmd_go_to_grasp_position.x, cmd_go_to_grasp_position.y, cmd_go_to_grasp_position.th,
			       cmd_grasp_handle.door_p1_x, cmd_grasp_handle.door_p1_y, cmd_grasp_handle.door_p2_x, cmd_grasp_handle.door_p2_y,
			       GRASP_RANGE);

}
