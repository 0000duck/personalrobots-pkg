#include "doors/imports.nddl"

/**
 * These constants are the set of all individual action timeout limits for actions
 * used in the door domain. All values are in seconds
 */
float CHECK_PATH_DURATION_BOUND = 30.0;
float DETECT_DOOR_DURATION_BOUND = 30.0;
float DETECT_HANDLE_DURATION_BOUND = 60.0;
float GRASP_HANDLE_DURATION_BOUND = 30.0;
float UNLATCH_HANDLE_DURATION_BOUND = 30.0;
float RELEASE_HANDLE_DURATION_BOUND = 30.0;
float MOVE_BASE_LOCAL_APPROACH_DURATION_BOUND = 60.0;
float MOVE_BASE_LOCAL_THROUGH_DOOR_DURATION_BOUND = 120.0;
float MOVE_BASE_DOOR_DURATION_BOUND = 120.0;
float SAFETY_TUCK_ARMS_DURATION_BOUND = 60.0;

class DoorState extends AgentTimeline {

  predicate Holds{
    // Door state
    string frame_id;
    float time_stamp;

    /**
     * The following is essentially a Door message data structure. If we add support for 'struct'
     * in NDDL then we can declare structured data types that directly map to the relevant ROS message types.
     * This will be a generally useful feature of the language and will also make auto-generated NDDL/ROS
     * bindings straightforward. Absent that structure, we would have to capture structure through nomenclature.
     */

    // Overall latched state
    LatchState latch_state;

    // Points for the door frame
    float frame_p1_x;
    float frame_p1_y;
    float frame_p1_z;
    float frame_p2_x;
    float frame_p2_y;
    float frame_p2_z;

    // Additional Frame information
    float height;
    HINGE_FRAME hinge;
    ROTATION_DIRECTION rot_dir;

    // Points for the door
    float door_p1_x;
    float door_p1_y;
    float door_p1_z;
    float door_p2_x;
    float door_p2_y;
    float door_p2_z;

    // Handle data
    float handle_x;
    float handle_y;
    float handle_z;

    // Travel direction data
    float travel_dir_x;
    float travel_dir_y;
    float travel_dir_z;

    // Default Values
    defaultOnCommit(frame_id, "map");
    defaultOnCommit(latch_state, UNKNOWN);
    defaultOnCommit(frame_p1_x, 0.0);
    defaultOnCommit(frame_p1_y, 0.0);
    defaultOnCommit(frame_p1_z, 0.0);
    defaultOnCommit(frame_p2_x, 0.0);
    defaultOnCommit(frame_p2_y, 0.0);
    defaultOnCommit(frame_p2_z, 0.0);
    defaultOnCommit(door_p1_x, 0.0);
    defaultOnCommit(door_p1_y, 0.0);
    defaultOnCommit(door_p1_z, 0.0);
    defaultOnCommit(door_p2_x, 0.0);
    defaultOnCommit(door_p2_y, 0.0);
    defaultOnCommit(door_p2_z, 0.0);
    defaultOnCommit(height, 0.0);
    defaultOnCommit(hinge, UNKNOWN);
    defaultOnCommit(rot_dir, UNKNOWN);
    defaultOnCommit(handle_x, 0.0);
    defaultOnCommit(handle_y, 0.0);
    defaultOnCommit(handle_z, 0.0);
    defaultOnCommit(travel_dir_x, 0.0);
    defaultOnCommit(travel_dir_y, 0.0);
    defaultOnCommit(travel_dir_z, 0.0);
  }

  DoorState(){
    super(Internal, "Holds");
  }
};

/**
 * This is an internal controller which will select actions for execution based on control state variables using a
 * Teleo-reactive tree structure.
 */
class DoorController extends AgentTimeline {

  /**
   * The parameters here 
   */
  predicate Holds{
    bool active;

    // Control variables
    bool in_position;
    bool found_door;
    bool must_find_handle;
    bool have_handle;
    bool doorway_clear;
    bool check_doorway;
    bool finishing;
    bool timed_out;
    LatchState latch_state;
  }

  DoorController(){
    super(Internal, "Holds");
  }
};


MoveBehavior doorman = new MoveBehavior(Internal, true);
DoorController door_controller = new DoorController();
DoorState door_state = new DoorState();

fact(door_controller.Holds dc_initial_state);
dc_initial_state.active = false;

DoorController::Holds{
  // We will assume default values on commitment based on predecessor. We really want these values to be bound. These values carry
  // forward from priors as they are updated by actions and we thus assume inertia (if we had the handle before and have no information
  // to the contrary, then we still have the handle).
  met_by(Holds p);
  defaultOnCommit(active, p.active);
  defaultOnCommit(found_door, p.found_door);
  defaultOnCommit(in_position, p.in_position);
  defaultOnCommit(must_find_handle, p.must_find_handle);
  defaultOnCommit(have_handle, p.have_handle);
  defaultOnCommit(latch_state, p.latch_state);
  defaultOnCommit(doorway_clear, p.doorway_clear);
  defaultOnCommit(check_doorway, p.check_doorway);
  defaultOnCommit(finishing, p.finishing);
  defaultOnCommit(timed_out, false);
}

/**
 * This rule fires essentially a TR-style decision tree to select
 * the next action to take.
 *
 */
DoorController::Holds {

  if(active == true){
    contained_by(door_state.Holds ds);
    meets(Holds s);
    contained_by(doorman.Active dm_active);

    // Derive arms_tucked from external safety monitor.
    // TODO: Analyze bug that arises when I include guards directly on mb.arms_tucked. The local variable
    // below is just a workaround
    starts_during(mobility_status.Holds ms);
    bool arms_tucked;
    eq(arms_tucked, ms.arms_tucked);

    // Compute a bound on the duration of any action we launch from here based on the global time limit
    int elapsed_ticks;
    float elapsed_time, remaining_time;
    addEq(dm_active.start, elapsed_ticks, start);
    mulEq(elapsed_ticks, TICK_DURATION, elapsed_time);
    addEq(elapsed_time, remaining_time, dm_active.max_duration);

    testLEQ(timed_out, remaining_time, 0.0);
    if(timed_out == true){
      eq(s.finishing, true);
    }

    if(finishing == true){
      if(have_handle == false){
	if(arms_tucked == true){
	  eq(s.active, false);
	  meets(doorman.Inactive dm_inactive);
	  eq(duration, 1);	 
	  if(timed_out == true){
	    eq(dm_inactive.status, ABORTED);
	  }
	  else {
	    if(doorway_clear == true){
	      eq(dm_inactive.status, SUCCESS);
	    }
	    else {
	      eq(dm_inactive.status, ABORTED);
	    }
	  }
	}
	else {
	  contains_start(safety_tuck_arms.Active cmd);
	  leq(cmd.max_duration, SAFETY_TUCK_ARMS_DURATION_BOUND);
	  concurrent(cmd.end, end);
	}
      }
      else{
	contains_start(release_handle.Active cmd);
	concurrent(cmd.end, end);
      }
    }
    else{
      if(doorway_clear == true){
	contains_start(move_base_local.Active cmd);
	concurrent(cmd.end, end);
	leq(cmd.max_duration, remaining_time);
	leq(cmd.max_duration, MOVE_BASE_LOCAL_THROUGH_DOOR_DURATION_BOUND);
	eq_pose_msg(cmd.object, dm_active.object);

	contains_start(set_laser_tilt.Active cmd_set_laser_tilt);
	eq(cmd_set_laser_tilt.status, SUCCESS);
	cmd_set_laser_tilt before cmd;
      }
      else {
	if(check_doorway == true){
	  if(arms_tucked == true){
	    // Now the goal will be the target across the doorway. This is the goal pose for the containing behavior
	    contains_start(check_path.Active cmd);
	    concurrent(cmd.end, end);
	    leq(cmd.max_duration, remaining_time);
	    leq(cmd.max_duration, CHECK_PATH_DURATION_BOUND);
	    eq_pose_msg(cmd.object, dm_active.object);

	    contains_start(set_laser_tilt.Active cmd_set_laser_tilt);
	    eq(cmd_set_laser_tilt.status, SUCCESS);
	    cmd_set_laser_tilt before cmd;
	  }
	  else {
	    contains_start(safety_tuck_arms.Active cmd);
	    concurrent(cmd.end, end);
	  }
	}
	else {
	  if(must_find_handle == false){
	    if(in_position == true){
	      if(latch_state == LATCH_STATE_UNLATCHED) {	
		// Moving the base set up here. Used in either case
		contains_start(move_base_door.Active cmd_move_base_door);
		concurrent(cmd_move_base_door.end, end);
		leq(cmd_move_base_door.max_duration, remaining_time);
		leq(cmd_move_base_door.max_duration, MOVE_BASE_DOOR_DURATION_BOUND);

		// Set up a preemption as needed. Will make this conditional shortly
		any(stop_action.Active cmd_stop_action);
		cmd_move_base_door before cmd_stop_action;

		if(have_handle == true){
		  contains_start(open_door.Active cmd_open_door);
		  cmd_open_door starts_before cmd_move_base_door;
		  eq(cmd_stop_action.action_name,"open_door");
		}
		else {
		  contains_start(touch_door.Active cmd_touch_door);
		  contains_start(push_door.Active cmd_push_door);
		  eq(cmd_touch_door.status, SUCCESS);

		  cmd_touch_door before cmd_push_door;
		  cmd_push_door starts_before cmd_move_base_door;
		  eq(cmd_stop_action.action_name,"push_door");
		}
	      }
	      else{
		if(have_handle == true){
		  contains_start(unlatch_handle.Active cmd);
		  concurrent(cmd.end, end);
		  leq(cmd.max_duration, remaining_time);
		  leq(cmd.max_duration, UNLATCH_HANDLE_DURATION_BOUND);
		}
		else {
		  // Don't have the handle, but could grasp it!
		  contains_start(grasp_handle.Active cmd);
		  concurrent(cmd.end, end);
		  leq(cmd.max_duration, remaining_time);
		  leq(cmd.max_duration, GRASP_HANDLE_DURATION_BOUND);
		}
	      }
	    }
	    else { // Not in position
	      // Move to the grasp position. Checking to tuck arms may be unnecessary
	      if(arms_tucked == true){
		contains_start(move_base_local.Active cmd);
		concurrent(cmd.end, end);
		leq(cmd.max_duration, remaining_time);
		leq(cmd.max_duration, MOVE_BASE_LOCAL_APPROACH_DURATION_BOUND);
		eq(cmd.frame_id, ds.frame_id);
		door_get_robot_pose_for_door(cmd.x, cmd.y, cmd.z, cmd.qx, cmd.qy, cmd.qz, cmd.qw, ds.object, GRASP_RANGE);

		contains_start(set_laser_tilt.Active cmd_set_laser_tilt);
		eq(cmd_set_laser_tilt.status, SUCCESS);
		cmd_set_laser_tilt before cmd;
	      }
	      else {
		contains_start(safety_tuck_arms.Active cmd);
		concurrent(cmd.end, end);
	      }
	    }
	  }
	  else { // Found handle == false
	    if(found_door == true){
	      contains_start(detect_handle.Active cmd);
	      leq(cmd.max_duration, remaining_time);
	      leq(cmd.max_duration, DETECT_HANDLE_DURATION_BOUND);
	      concurrent(cmd.end, end);
	    }
	    else {
	      // If in detection position, we can detect the door
	      if(in_position == true){
		contains_start(detect_door.Active cmd);
		leq(cmd.max_duration, remaining_time);
		concurrent(cmd.end, end);
	      }
	      else {
		// Should move to detection position using standard navigation
		if(arms_tucked == true){
		  contains_start(move_base.Active cmd);
		  concurrent(cmd.end, end);
		  leq(cmd.max_duration, remaining_time);
		  eq(cmd.frame_id, "map");
		  map_get_door_approach_pose(cmd.x, cmd.y, cmd.z, cmd.qx, cmd.qy, cmd.qz, cmd.qw, dm_active.start_connector);

		  contains_start(set_laser_tilt.Active cmd_set_laser_tilt);
		  eq(cmd_set_laser_tilt.status, SUCCESS);
		  cmd_set_laser_tilt before cmd;
		}
		else {
		  if(have_handle == true){
		    contains_start(release_handle.Active cmd);
		    concurrent(cmd.end, end);
		    leq(cmd.max_duration, RELEASE_HANDLE_DURATION_BOUND);
		  }
		  else {
		    contains_start(safety_tuck_arms.Active cmd);
		    concurrent(cmd.end, end);
		    leq(cmd.max_duration, SAFETY_TUCK_ARMS_DURATION_BOUND);
		  }
		}
	      }
	    }
	  }
	}
      }
    }
  }
}

/************************************************************************
 * Now we define how actions update the door controller by setting
 * feedback parameters on success or failure
 ***********************************************************************/

// Derive input bounds from the behavior
DoorManipulationBehavior::Active{
  starts_during(DoorState.Holds ds);
  eq_door_msg(this.object, ds.object);
}

ReleaseHandle::Inactive{
  if(status == SUCCESS){
    starts(door_controller.Holds dc);
    eq(dc.have_handle, false);
  }
}

MoveBaseDoor::Inactive{
  if(status == SUCCESS){
    starts(door_controller.Holds dc);
    eq(dc.finishing, true);
    eq(dc.doorway_clear, true);
  }
}

UnlatchHandle::Inactive{
  if(status == SUCCESS){
    starts(DoorState.Holds ds);
    eq_door_msg(ds.object, this.object);
    starts(door_controller.Holds dc);
    eq(dc.latch_state, latch_state);
    if(latch_state == LATCH_STATE_LOCKED){
      eq(dc.finishing, true);
    }
  }
  else{
    if(status == UNDEFINED){}
    else{
      starts(door_controller.Holds dc);
      eq(dc.must_find_handle, true);
      eq(dc.found_door, false);
      eq(dc.in_position, false);
    }
  }
}

GraspHandle::Inactive{
  if(status == SUCCESS){
    starts(door_controller.Holds dc);
    eq(dc.have_handle, true);
  }
}

DetectHandle::Inactive{
  if(status == SUCCESS){
    starts(door_controller.Holds dc);
    eq(dc.must_find_handle, false);
    starts(DoorState.Holds ds);
    eq_door_msg(ds.object, this.object);
    eq(dc.latch_state, ds.latch_state);
  }
  else {
    if(status == UNDEFINED){}
    else {
      starts(door_controller.Holds dc);
      eq(dc.in_position, false);
      eq(dc.found_door, false);
    }
  }
}

DetectDoor::Inactive{
  if(status == SUCCESS){
    starts(door_controller.Holds dc);
    eq(dc.found_door, true);
    eq(dc.in_position, false);
    starts(DoorState.Holds ds);
    eq_door_msg(ds.object, this.object);
    eq(dc.latch_state, ds.latch_state);

    if(latch_state == LATCH_STATE_UNLATCHED){
      eq(dc.must_find_handle, false);
    }

    if(latch_state == LATCH_STATE_LOCKED){
      eq(dc.finishing, true);
    }
  }
  if(status == ABORTED){
    starts(door_controller.Holds dc);
    eq(dc.check_doorway, true);
  }
}

CheckPath::Inactive{
  if(status == SUCCESS){
    starts(door_controller.Holds dc);
    eq(dc.doorway_clear, is_clear);
    eq(dc.check_doorway, false);
  }
}

/**
 * Move base can be called as part of a recovery to retry from an approach pose, or it can be
 * called because we think the doorway is clear and traversable. If it fails for any reason, we should
 * finish. This could be quite frustrating to watch. For example, it could be right in the doorway
 * and only a small push would be required to get thru. In that case, it will in fact give up and be going to the next goal. Note that
 * it will try again later! The problem is, it is hard to bound the behavior of move_base reasonably and thus our ability
 * to reliably attempt better local recoveries is questionable. Moreover, we typically assume we do not have the door data
 */
MoveBase::Inactive {
  if(status == SUCCESS){
    starts(door_controller.Holds dc);
    eq(dc.in_position, true);

    // There are 2 conditions at play here. If the doorway is clear, and move base succeded, then we have to set
    // finishing to true
    met_by(door_controller.Holds p);
    if(p.doorway_clear == true){
      eq(dc.finishing, true);
    }
  }
  else{
    if(status == UNDEFINED){}
    else {
      // Rest control flags to go back to the beginning but preclude checking the doorway
      starts(door_controller.Holds dc);
      eq(dc.doorway_clear, false);
      eq(dc.in_position, false);
      eq(dc.found_door, false);
      eq(dc.must_find_handle, true);
      eq(dc.have_handle, false);
      eq(dc.latch_state, UNKNOWN);
      eq(dc.doorway_clear, false);
    }
  }
}
