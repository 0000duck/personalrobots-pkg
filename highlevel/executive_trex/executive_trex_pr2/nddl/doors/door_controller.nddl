#include "doors/imports.nddl"

/**
 * These constants are the set of all individual action timeout limits for actions
 * used in the door domain. All values are in seconds
 */
float CHECK_PATH_DURATION_BOUND = 30.0;
float DETECT_DOOR_DURATION_BOUND = 30.0;
float DETECT_HANDLE_DURATION_BOUND = 60.0;
float GRASP_HANDLE_DURATION_BOUND = 30.0;
float UNLATCH_HANDLE_DURATION_BOUND = 30.0;
float RELEASE_HANDLE_DURATION_BOUND = 30.0;
float MOVE_BASE_LOCAL_APPROACH_DURATION_BOUND = 60.0;
float MOVE_BASE_THROUGH_DOOR_DURATION_BOUND = 600.0;
float MOVE_BASE_DOOR_DURATION_BOUND = 120.0;

class DoorState extends AgentTimeline {

  predicate Holds{
    // Door state
    string frame_id;
    float time_stamp;

    /**
     * The following is essentially a Door message data structure. If we add support for 'struct'
     * in NDDL then we can declare structured data types that directly map to the relevant ROS message types.
     * This will be a generally useful feature of the language and will also make auto-generated NDDL/ROS
     * bindings straightforward. Absent that structure, we would have to capture structure through nomenclature.
     */

    // Overall latched state
    LatchState latch_state;

    // Points for the door frame
    float frame_p1_x;
    float frame_p1_y;
    float frame_p1_z;
    float frame_p2_x;
    float frame_p2_y;
    float frame_p2_z;

    // Additional Frame information
    float height;
    HINGE_FRAME hinge;
    ROTATION_DIRECTION rot_dir;

    // Points for the door
    float door_p1_x;
    float door_p1_y;
    float door_p1_z;
    float door_p2_x;
    float door_p2_y;
    float door_p2_z;

    // Handle data
    float handle_x;
    float handle_y;
    float handle_z;

    // Travel direction data
    float travel_dir_x;
    float travel_dir_y;
    float travel_dir_z;

    // Default Values
    defaultOnCommit(frame_id, "map");
    defaultOnCommit(latch_state, UNKNOWN);
    defaultOnCommit(frame_p1_x, 0.0);
    defaultOnCommit(frame_p1_y, 0.0);
    defaultOnCommit(frame_p1_z, 0.0);
    defaultOnCommit(frame_p2_x, 0.0);
    defaultOnCommit(frame_p2_y, 0.0);
    defaultOnCommit(frame_p2_z, 0.0);
    defaultOnCommit(door_p1_x, 0.0);
    defaultOnCommit(door_p1_y, 0.0);
    defaultOnCommit(door_p1_z, 0.0);
    defaultOnCommit(door_p2_x, 0.0);
    defaultOnCommit(door_p2_y, 0.0);
    defaultOnCommit(door_p2_z, 0.0);
    defaultOnCommit(height, 0.0);
    defaultOnCommit(hinge, UNKNOWN);
    defaultOnCommit(rot_dir, UNKNOWN);
    defaultOnCommit(handle_x, 0.0);
    defaultOnCommit(handle_y, 0.0);
    defaultOnCommit(handle_z, 0.0);
    defaultOnCommit(travel_dir_x, 0.0);
    defaultOnCommit(travel_dir_y, 0.0);
    defaultOnCommit(travel_dir_z, 0.0);
  }

  DoorState(){
    super(Internal, "Holds");
  }
};

/**
 * This is an internal controller which will select actions for execution based on control state variables using a
 * Teleo-reactive tree structure.
 */
class DoorController extends AgentTimeline {

  predicate Inactive{
    ResultStatus status;
    defaultOnCommit(status, UNDEFINED);
  }

  predicate CheckingDoorway{}
  predicate Positioning{}
  predicate DetectingDoor{}
  predicate DetectingHandle{}
  predicate ReleasingHandle{}
  predicate ApproachingDoor{}
  predicate GraspingHandle{}
  predicate UnlatchingHandle{}
  predicate DriveThruDoorway{}
  predicate OpenDoor{
    bool use_handle;
  }

  DoorController(){ super(Internal, "Inactive"); }
};


MoveBehavior doorman = new MoveBehavior(Internal, true);
DoorController door_controller = new DoorController();
DoorState door_state = new DoorState();

fact(door_controller.Inactive dc_initial_state);
dc_initial_state.status = UNDEFINED;

DoorController::Inactive{
  starts(doorman.Inactive dm);
  eq(dm.status, status);
}

DoorController::CheckingDoorway{
  // Now the goal will be the target across the doorway. This is the goal pose for the containing behavior
  contains_start(check_path.Active cmd);
  concurrent(cmd.end, end);
  leq(cmd.max_duration, CHECK_PATH_DURATION_BOUND);
  contained_by(doorman.Active dm);
  eq_pose_msg(cmd.object, dm.object);
  eq(cmd.status, SUCCESS);

  cmd meets (check_path.Inactive cmd_feedback);
  if(cmd_feedback.is_clear == true){
    meets(door_controller.DriveThruDoorway);
  }
  else {
    meets(door_controller.Positioning);
  }
}

// We must move the base to the approach point
DoorController::DriveThruDoorway{
  contains_start(move_base.Active cmd);
  concurrent(cmd.end, end);
  contained_by(doorman.Active dm);
  leq(cmd.max_duration, MOVE_BASE_THROUGH_DOOR_DURATION_BOUND);
  eq_pose_msg(cmd.object, dm.object);
  
  if(cmd.status == SUCCESS){
    meets(Inactive s);
    eq(s.status, SUCCESS);
  }
  else{
    meets(Positioning);
  }
}

// We must move the base to the approach point
DoorController::Positioning{
  contains_start(move_base.Active cmd);
  concurrent(cmd.end, end);
  eq(cmd.frame_id, "map");
  eq(cmd.status, SUCCESS);
  contained_by(doorman.Active dm);
  map_get_door_approach_pose(cmd.x, cmd.y, cmd.z, cmd.qx, cmd.qy, cmd.qz, cmd.qw, dm.start_connector);
  meets(DetectingDoor);
}

DoorController::DetectingDoor{
  contains_start(detect_door.Active cmd);
  concurrent(cmd.end, end);

  if(cmd.status == SUCCESS){
    cmd meets(detect_door.Inactive cmd_feedback);
    if(cmd_feedback.latch_state == LATCH_STATE_UNLATCHED){
      meets(ApproachingDoor);
    }
    else{
      meets(DetectingHandle);
    }
  }
  else {
    meets(CheckingDoorway);
  }
}

DoorController::DetectingHandle{
  contains_start(detect_handle.Active cmd);
  leq(cmd.max_duration, DETECT_HANDLE_DURATION_BOUND);
  concurrent(cmd.end, end);

  if(cmd.status == SUCCESS){
    meets(ApproachingDoor);
  }
  else {
    meets(DetectingDoor);
  }
}

DoorController::ApproachingDoor{
  contains_start(move_base_local.Active cmd);
  concurrent(cmd.end, end);
  leq(cmd.max_duration, MOVE_BASE_LOCAL_APPROACH_DURATION_BOUND);
  contained_by(door_state.Holds ds);
  eq(cmd.frame_id, ds.frame_id);
  door_get_robot_pose_for_door(cmd.x, cmd.y, cmd.z, cmd.qx, cmd.qy, cmd.qz, cmd.qw, ds.object, GRASP_RANGE);

  // FOXME: The introduction of a new variable here is a work around to a EUROPA bug on constraint migration. Remove when fixed.
  bool use_handle;
  testEQ(use_handle, ds.latch_state, LATCH_STATE_LATCHED);

  if(cmd.status == SUCCESS){
    if(use_handle == true){
      meets(GraspingHandle);
    }
    else{
      meets(OpenDoor s);
      eq(s.use_handle, false);
    }
  }
  else {
    meets(Positioning);
  }
}

DoorController::GraspingHandle{
  contains_start(grasp_handle.Active cmd);
  concurrent(cmd.end, end);
  leq(cmd.max_duration, GRASP_HANDLE_DURATION_BOUND);

  if(cmd.status == SUCCESS){
    meets(UnlatchingHandle);
  }
  else {
    meets(ReleasingHandle rh);
    rh meets(Positioning);
  }
}

DoorController::UnlatchingHandle{
  contains_start(unlatch_handle.Active cmd);
  concurrent(cmd.end, end);
  leq(cmd.max_duration, UNLATCH_HANDLE_DURATION_BOUND);

  if(cmd.status == SUCCESS){
    cmd meets(unlatch_handle.Inactive cmd_feedback);

    // If locked, try again later
    if(cmd_feedback.latch_state == LATCH_STATE_LOCKED){
      meets(ReleasingHandle rh);
      rh meets(Inactive s);
      eq(s.status, ABORTED);
    }
    else {
      meets(OpenDoor s);
      eq(s.use_handle, true);
    }
  }
  else {
    meets(ReleasingHandle rh);
    rh meets(Positioning);
  }
}

DoorController::ReleasingHandle{
  contains_start(release_handle.Active cmd);
  concurrent(cmd.end, end);
  leq(cmd.max_duration, RELEASE_HANDLE_DURATION_BOUND);
  eq(cmd.status, SUCCESS);
}

DoorController::OpenDoor{
  // Moving the base set up here. Used in either case
  contains_start(move_base_door.Active cmd_move_base_door);
  concurrent(cmd_move_base_door.end, end);
  leq(cmd_move_base_door.max_duration, MOVE_BASE_DOOR_DURATION_BOUND);
  eq(cmd_move_base_door.status, SUCCESS);

  cmd_move_base_door before(stop_action.Active cmd_stop_action);

  if(use_handle == true){
    contains_start(open_door.Active cmd_open_door);
    eq(cmd_open_door.status, SUCCESS);
    cmd_open_door starts_before cmd_move_base_door;
    // Must stop the open door action explicitly
    eq(cmd_stop_action.action_name,"open_door");
    meets(ReleasingHandle rh);
    rh meets(Inactive s);
    eq(s.status, SUCCESS);
  }
  else {
    contains_start(touch_door.Active cmd_touch_door);
    contains_start(push_door.Active cmd_push_door);
    eq(cmd_touch_door.status, SUCCESS);
    eq(cmd_push_door.status, SUCCESS);

    cmd_touch_door before cmd_push_door;
    cmd_push_door starts_before cmd_move_base_door;
    eq(cmd_stop_action.action_name,"push_door");

    meets(Inactive s);
    eq(s.status, SUCCESS);
  }
}

/************************************************************************
 * Now we define how actions update the door controller by setting
 * feedback parameters on success or failure
 ***********************************************************************/

/**
 * All door domain actions have the current door state as input.
 */
DoorManipulationBehavior::Active{
  starts_during(DoorState.Holds ds);
  eq_door_msg(this.object, ds.object);
}

/**
 * @brief This commands update the door state if successful. Note that it is probable safe to assume this for all door actions
 * but they might screw up the feedback values! We could subclass the ones that do this to avoid redundancy.
 */
UnlatchHandle::Inactive{
  if(status == SUCCESS){
    starts(DoorState.Holds ds);
    eq_door_msg(ds.object, this.object);
  }
}
DetectHandle::Inactive{
  if(status == SUCCESS){
    starts(DoorState.Holds ds);
    eq_door_msg(ds.object, this.object);
  }
}
DetectDoor::Inactive{
  if(status == SUCCESS){
    starts(DoorState.Holds ds);
    eq_door_msg(ds.object, this.object);
  }
}
