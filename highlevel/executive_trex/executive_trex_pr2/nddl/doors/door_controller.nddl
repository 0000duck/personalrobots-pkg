#include "doors/imports.nddl"

typedef int [-1, 1] TIME_ERROR_BOUND;

/**
 * This is an internal controller which will monitor state variables and HLC status. It can also generate
 * next steps for this meta level control. This pattern exploits reactive planning based on feedback from the
 * environment.
 */
class DoorController extends AgentTimeline {

  /**
   * The parameters here 
   */
  predicate Holds{
    bool active;

    // Control variables
    bool in_detection_position;
    bool found_door;
    bool found_handle; // Should Cover this!
    bool have_handle;
    bool door_latched;
    bool doorway_clear;
    bool check_doorway;

    // Door state
    string frame_id;

    /**
     * The following is essentially a Door message data structure. If we add support for 'struct'
     * in NDDL then we can declare structured data types that directly map to the relevant ROS message types.
     * This will be a generally useful feature of the language and will also make auto-generated NDDL/ROS
     * bindings straightforward. Absent that structure, we would have to capture structure through nomenclature.
     */

    // Points for the door frame
    float frame_p1_x;
    float frame_p1_y;
    float frame_p1_z;
    float frame_p2_x;
    float frame_p2_y;
    float frame_p2_z;

    // Additional Frame information
    float height;
    HINGE_FRAME hinge;
    ROTATION_DIRECTION rot_dir;

    // Points for the door
    float door_p1_x;
    float door_p1_y;
    float door_p1_z;
    float door_p2_x;
    float door_p2_y;
    float door_p2_z;

    // Handle data
    float handle_x;
    float handle_y;
    float handle_z;

    // Normal data
    float normal_x;
    float normal_y;
    float normal_z;
  }

  DoorController(){
    super(Internal, "Holds");
  }
};

MoveBehavior doorman = new MoveBehavior(Internal, true);
DoorController door_controller = new DoorController();

/**
 * This rule fires essentially a TR-style decision tree to select
 * the next action to take. The action choices are(in reverse order):
 * - release_handle
 * - check_path
 * - open_door
 * - move_base_door
 * - unlatch_handle
 * - grasp_handle
 * - detect_handle
 * - move_base_local
 * - detect_door
 * - move_base_local
 *
 * Note the pattern that uses a flexible temporal interval (end_bounds varaible) for constraining the relationshop between the
 * completion time of the selected action, and the end time of this control step. This flexibility accounts for
 * the fact that an exogenous event can trip the state forcing a planned preemption of the active command, and the
 * completion of the command should also bring about a completion of the given control step
 */
DoorController::Holds {

  // Bind values for inactive case
  if(active == false){
    // Reset control flags
    eq(in_detection_position, false);
    eq(found_door, false);
    eq(found_handle, false);
    eq(have_handle, false);
    eq(door_latched, true);
    eq(doorway_clear, false);
    eq(check_doorway, true);
    contained_by(doorman.Inactive);
  }
  else {
    // The end bound defined here provides a margin of error around the connection between the end time of the
    // command issued here, and the end time of the control step.
    int end_bounds;
    temporalDistance(end, [-1, 1], end_bounds);

    // Is the doorway clear? No special checks are required for this. We can do it any time
    if(doorway_clear == true){

      // If we do not have the handle then we are good to go, so we just terminate with success
      if(have_handle == false){
	meets(doorman.Inactive mb_inactive);
	eq(mb_inactive.status, SUCCESS);
	eq(duration, 1);
      }
      else {
	// If we have the handle, we have to release it. We should not have to tuck arms here
	// but we might have to.
	starts_before(release_handle.Active cmd);
	concurrent(cmd.end, end_bounds);
      }
    }

    if(doorway_clear == false){

      if(check_doorway == true){
	starts_before(check_path.Active cmd);
	concurrent(cmd.end, end_bounds);
	door_get_robot_pose_for_door(cmd.x, cmd.y, cmd.z, cmd.qx, cmd.qy, cmd.qz, cmd.qw, object, DOORWAY_CLEARANCE_RANGE);
      }
      else {
	// If latched then open it - with 2 actions together
	if(door_latched == true) {
	  starts_before(open_door.Active cmd_open_door);
	  starts_before(move_base_door.Active cmd_move_base_door);
	  cmd_open_door starts_before cmd_move_base_door;
	  temporalDistance(cmd_move_base_door.end, [0, 1], cmd_open_door.end);
	  concurrent(cmd_open_door.end, end_bounds);
	}
	else {
	  // Door is not latched. If we have the handle then we need to unlatch it
	  if(have_handle == true){
	    starts_before(unlatch_handle.Active cmd);
	    concurrent(cmd.end, end_bounds);
	  }
	  else {
	    // Don't have the handle, but could grasp it!
	    if(in_detection_position == true){
	      starts_before(grasp_handle.Active cmd);
	      concurrent(cmd.end, end_bounds);
	    }
	    else {
	      // Not in grasp position. If we found the handle, go to grasp position
	      if(found_handle == true){
		// Move to the grasp position
		starts_before(move_base_local.Active cmd);
		concurrent(cmd.end, end_bounds);
		door_get_robot_pose_for_door(cmd.x, cmd.y, cmd.z, cmd.qx, cmd.qy, cmd.qz, cmd.qw, object, GRASP_RANGE);
	      }
	      else {

		// If we found the door we can detect the handle
		if(found_door == true){
		  starts_before(detect_handle.Active cmd);
		  concurrent(cmd.end, end_bounds);
		}
		else {
		  // If in detection position, we can detect the door
		  if(in_detection_position == true){
		    starts_before(detect_door.Active cmd);
		    concurrent(cmd.end, end_bounds);
		  }
		  else{
		    // Should move to detection position
		    starts_before(move_base_local.Active cmd);
		    concurrent(cmd.end, end_bounds);
		    door_get_robot_pose_for_door(cmd.x, cmd.y, cmd.z, cmd.qx, cmd.qy, cmd.qz, cmd.qw, object, DETECTION_RANGE);
		  }
		}
	      }
	    }
	  }
	}
      }
    }
  }
}

/**
 * Defines update rule for default values
 */
DoorController::Holds{
  // We will assume default values on commitment based on predecessor. We really want these values to be bound. These values carry
  // forward from priors as they are updated by actions and we thus assume inertia (if we had the handle before and have no information
  // to the contrary, then we still have the handle).
  met_by(Holds p);
  defaultOnCommit(active, p.active);
  defaultOnCommit(found_door, p.found_door);
  defaultOnCommit(in_detection_position, p.in_detection_position);
  defaultOnCommit(found_handle, p.found_handle);
  defaultOnCommit(have_handle, p.have_handle);
  defaultOnCommit(door_latched, p.door_latched);
  defaultOnCommit(doorway_clear, p.doorway_clear);
  defaultOnCommit(check_doorway, p.check_doorway);

  // Door State Data
  defaultOnCommit(hinge, p.hinge);
  defaultOnCommit(rot_dir, p.rot_dir);
  defaultOnCommit(frame_p1_x, p.frame_p1_x);
  defaultOnCommit(frame_p1_y, p.frame_p1_y);
  defaultOnCommit(frame_p1_z, p.frame_p1_z);
  defaultOnCommit(frame_p2_x, p.frame_p2_x);
  defaultOnCommit(frame_p2_y, p.frame_p2_y);
  defaultOnCommit(frame_p2_z, p.frame_p2_z);
  defaultOnCommit(door_p1_x, p.door_p1_x);
  defaultOnCommit(door_p1_y, p.door_p1_y);
  defaultOnCommit(door_p1_z, p.door_p1_z);
  defaultOnCommit(door_p2_x, p.door_p2_x);
  defaultOnCommit(door_p2_y, p.door_p2_y);
  defaultOnCommit(door_p2_z, p.door_p2_z);
  defaultOnCommit(height, p.height);
  defaultOnCommit(hinge, p.hinge);
  defaultOnCommit(rot_dir, p.rot_dir);
  defaultOnCommit(handle_x, p.handle_x);
  defaultOnCommit(handle_y, p.handle_y);
  defaultOnCommit(handle_z, p.handle_z);
  defaultOnCommit(normal_x, p.normal_x);
  defaultOnCommit(normal_y, p.normal_y);
  defaultOnCommit(normal_z, p.normal_z);
}

/************************************************************************
 * Now we define how actions update the door controller by setting
 * feedback parameters on success or failure
 ***********************************************************************/

// Derive input bounds from the behavior
DoorManipulationBehavior::Active{
  // DoorController(start) == Holds(door_state);
  any(DoorController.Holds dc);
  precedes(dc.start, start);
  temporalDistance(start, [1 +inf], dc.end);
  eq_door_msg(this.object, dc.object);
}

DoorManipulationBehavior::Inactive{
  // If successful, then the completion of the action starts a new step in the controller
  if(status == SUCCESS){
    starts(DoorController.Holds dc);
    eq(dc.active, true);
    eq_door_msg(dc.object, this.object);
  }
}

/**
 * On success, have_handle = false && check_doorway == true
 */
ReleaseHandle::Inactive{
  if(status == SUCCESS){
    starts(DoorController.Holds dc);
    eq(dc.have_handle, false);
    eq(dc.check_doorway, true);
  }
}

/**
 * On comlpetion, if success or preempted, then check the doorway.
 */
OpenDoor::Inactive{
  starts(DoorController.Holds dc);

  if(status == ABORTED){
  }
  else {
    eq(dc.check_doorway, true);
  }
}

GraspHandle::Inactive{
  if(status == SUCCESS){
    starts(DoorController.Holds dc);
    eq(dc.have_handle, true);
  }
}

OpenDoorWithoutGrasp::Inactive{
  if(status == SUCCESS){
    starts(DoorController.Holds dc);
    eq(dc.check_doorway, true);
  }
}

DetectDoor::Inactive{
  if(status == SUCCESS){
    starts(DoorController.Holds dc);
    eq(dc.found_door, true);
    eq(dc.found_handle, true);
    eq(dc.in_detection_position, false);
  }
}

CheckPath::Inactive{
  if(status == SUCCESS){
    starts(DoorController.Holds dc);
    eq(dc.doorway_clear, is_clear);
  }
}

MoveBase::Inactive {
  if(object == move_base_local){
    if(status == SUCCESS){
      starts(DoorController.Holds dc);
      eq(dc.in_detection_position, true);
    }
  }
}
