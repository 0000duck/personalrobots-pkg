/**
 * A simulation control variable governing when the doorway will be clear.
 */
class DoorwayClearSV extends AgentTimeline {

  predicate Holds{ 
    bool value;
  }

  DoorwayClearSV(){ super(Internal, "Holds");}
};

DoorwayClearSV::Holds{  default(value, true); }

/**
 * A simulation control variable governing when the doorway will be unlocked
 */
class DoorwayLockedSV extends AgentTimeline {

  predicate Holds{ 
    bool value;
  }

  DoorwayLockedSV(){ super(Internal, "Holds");}
};


DoorwayLockedSV::Holds{  default(value, false); }

/**
 * For now, assume a fixed duration, and always return success. Later, can model
 * a selection that stochastically selects if the doorway is clear
 */

ReleaseDoor::Active{
  eq(duration, 1);

  // Handle always free at the end
  meets(Inactive s);
  eq(s.status, SUCCESS);
}

/**
 * Could lose the handle here
 */
OpenDoorWithGrasp::Active{
  eq(duration, 1);
  meets(Inactive s);
  eq(s.status, SUCCESS);
}

/**
 * Grasping the handle will indicate at t he end that it has the handle - for now.
 */
GraspHandle::Active{
  eq(duration, 1);
  meets(Inactive s);
  eq(s.status, SUCCESS);
}

/**
 * Should probably include change in base position, and allow for stochastic selection of whether or not we have
 * the handle anymore
 */
OpenDoorWithoutGrasp::Active{
  eq(duration, 1);
  meets(Inactive s);
  eq(s.status, SUCCESS);
}

DetectDoor::Active {
  eq(duration, 1);
  // this[end) == Inactive(SUCCESS, true, true);
  meets(Inactive s);
  eq(s.status, SUCCESS);
}

/**
 * Assume it executes successfully. Leav result status unbound - depends on simulation control variables
 */
CheckDoorway::Active{
  eq(duration, 1);

  // this[end) = Inactive(SUCCESS, dc.value, dl.value);
  meets(Inactive s);
  eq(s.status, SUCCESS);
}

/**
 * Update result parameters accoring to simulation control variables.
 */
CheckDoorway::Inactive{
  // DoorwayClearSV.Holds dc = doorway_cleared_sv(start);
  any(DoorwayClearSV.Holds dc);
  precedes(dc.start, start);
  temporalDistance(start, [1 +inf], dc.end);
  eq(doorway_clear, dc.value);

  // DoorwayLockedSV.Holds dl = doorway_locked_sv(start);
  any(DoorwayLockedSV.Holds dl);
  precedes(dl.start, start);
  temporalDistance(start, [1 +inf], dl.end);
  eq(door_latched, dl.value);
}

NotifyDoorBlocked::Active{
  eq(duration, 1);
  meets(Inactive s);
  eq(s.status, SUCCESS);
}

// External controllers specific to the door domain
ReleaseDoor release_door = new ReleaseDoor(Internal);
OpenDoorWithGrasp open_door_with_grasp = new OpenDoorWithGrasp(Internal);
GraspHandle grasp_handle = new GraspHandle(Internal);
OpenDoorWithoutGrasp open_door_without_grasp = new OpenDoorWithoutGrasp(Internal);
DetectDoor detect_door = new DetectDoor(Internal);
CheckDoorway check_doorway = new CheckDoorway(Internal);
NotifyDoorBlocked notify_door_blocked = new NotifyDoorBlocked(Internal);


// Simulation Control Variables
DoorwayClearSV doorway_clear_sv = new DoorwayClearSV();
DoorwayLockedSV doorway_locked_sv = new DoorwayLockedSV();
