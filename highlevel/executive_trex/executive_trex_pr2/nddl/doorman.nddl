/*
 * Copyright (c) 2008, Willow Garage, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <ORGANIZATION> nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

// TREX base class declaration and definitions
#include "TREX.nddl"

// Exports from sub-systems
#include "rcs.exports.nddl"
#include "rcs.exports.doorman.nddl"
#include "doorman.exports.nddl"
#include "safety.exports.nddl"
#include "nav.exports.nddl"

typedef int [-1, 1] TIME_ERROR_BOUND;

// Introduce a constriant to set a time for forcing us to chekc the door based on the door check interval
int FORCE_DOOR_CHECK;
addEq(FORCE_DOOR_CHECK, DOOR_CHECK_INTERVAL, 0);


/**
 * This is an internal controller which will monitor state variables and HLC status. It can also generate
 * next steps for this meta level control. This pattern exploits reactive planning based on feedback from the
 * environment.
 */
class DoorController extends AgentTimeline {

  /**
   * The parameters here 
   */
  predicate Holds{
    bool active;

    bool in_detection_position; // True if far enough from the door to scan effectively. Else false
    bool in_grasp_position; // True if far enough from the door to scan effectively, Can only be evaluated
    bool found_door;
    bool found_handle; // Should Cover this!
    MAYBE_TRUE_OR_FALSE have_handle;
    bool door_locked;
    bool doorway_clear;
    int last_checked_door; // Time for when we last checked the doorway
  }

  DoorController(Mode _mode){
    super(_mode);
  }
};


MoveBehavior::Inactive {
  // Only apply this condition when it has started. Do not want to plan it in advance.
  if(start){
    equals(DoorController.Holds dc);
    eq(dc.active, false);
  }
}

MoveBehavior::Active {
  starts(DoorController.Holds dc);

  // Initialize controller variables. We begin by assuming the worst. Note that the test for being in detection
  // position is derived from base state data directly and thus not subject to setting as a free control variable
  eq(dc.active, true);
  eq(dc.in_grasp_position, false);
  eq(dc.found_door, false);
  eq(dc.found_handle, false);
  eq(dc.have_handle, MAYBE);
  eq(dc.door_locked, false);
  eq(dc.doorway_clear, false);
  eq(dc.last_checked_door, FORCE_DOOR_CHECK);
}

/**
 * This rule fires essentially a TR-style decision tree to select
 * the next action to take. The action choices are(in reverse order):
 * - ReleaseDoor
 * - OpenDoorWithGrasp
 * - TwistHandle
 * - GraspHandle
 * - MoveBase (x 2)
 * - OpenDoorWithoutGrasp
 * - DetectDoor
 * - CheckDoor
 *
 * Note the pattern that uses a flexible temporal interval for constraining the relationshop between the
 * completion time of the selected action, and the end time of this control step. This flexibility accounts for
 * the fact that an exogenous event can trip the state forcing a planned preemption of the active command, and the
 * completion of the command should also bring about a completion of the given control step
 */
DoorController::Holds {
  met_by(Holds p);

  // We will assume default values on commitment based on predecessor. We really want these values to be bound.
  // It is also pretty clear that we would like an unknown value for these things since we do not want to assume we have the handle.
  // Of course that suggests that we would explode the state machine, or at least require a representation that would admit a 
  // disjunction. Maybe we only care to have such a state for have_handle since we want to have the handle to do work but want to
  // clear it to 
  defaultOnCommit(active, p.active);
  defaultOnCommit(in_detection_position, p.in_detection_position);
  defaultOnCommit(in_grasp_position, p.in_grasp_position);
  defaultOnCommit(found_door, p.found_door);
  defaultOnCommit(found_handle, p.found_handle);
  defaultOnCommit(have_handle, p.have_handle);
  defaultOnCommit(door_locked, p.door_locked);
  defaultOnCommit(doorway_clear, p.doorway_clear);
  defaultOnCommit(last_checked_door, p.last_checked_door);

  // While this controller is inactive, then the doorman is also inactive
  if(active == false){
    contained_by(MoveBehavior.Inactive);
  }

  // If we are active, then we must evaluate different states based on current base, door , and handle state
  if(active == true){
    // MoveBehavior(all) == active   
    contained_by(MoveBehavior.Active dm);

    // Evaluate condition variables based on input states.
    // BaseState.Holds(start) bs;
    // DoorState.Holds(start) ds;
    // HandleState.Holds(start) hs;
    if(start){
      any(BaseState.Holds bs);
      precedes(bs.start, start);
      temporalDistance(start, [1 +inf], bs.end);
      any(DoorState.Holds ds);
      precedes(ds.start, start);
      temporalDistance(start, [1 +inf], ds.end);
      any(HandleState.Holds hs);
      precedes(hs.start, start);
      temporalDistance(start, [1 +inf], hs.end);
    }

    // @todo Compute if within detection position

    // The end bound defined here provides a margin of error around the connection between the end time of the
    // command issued here, and the end time of the control step.
    int end_bounds;
    temporalDistance(end, [-1, 1], end_bounds);

    // Is the doorway clear? No special checks are required for this. We can do it any time
    if(doorway_clear == true){

      // If we do not have the handle then we are good to go, so we just terminate with success
      if(have_handle == FALSE){
	meets(MoveBehavior.Inactive mb);
	eq(mb.status, SUCCESS);
	eq(duration, 1);
      }
      else {
	// If true or maybe then we should release the door just to be safe. Could do a sensing action
	// but I am expecting that releasing the door doubles as a sensing action
	// ReleaseDoor([start, +inf], end + [-1, 1]] == Active;
	starts_before(ReleaseDoor.Active cmd);
	concurrent(cmd.end, end_bounds);
      }
    }

    if(doorway_clear == false){

      // We might want to recheck the doorway. Alternately we could include such an observation in the door
      // monitoring code.
      bool recheck_doorway;
      int elapsed_time_since_last_check;
      addEq(last_checked_door, elapsed_time_since_last_check, start);
      testLEQ(recheck_doorway, DOOR_CHECK_INTERVAL, elapsed_time_since_last_check);
      if(recheck_doorway == true){
	starts_before(CheckDoorway.Active cmd);
	concurrent(cmd.end, end_bounds);
      }

      if(recheck_doorway == false){

	if(have_handle == TRUE) {

	  if(door_locked == false){
	    // OpenDoorWithGrasp([start, +inf], end_bounds] == Active();
	    starts_before(OpenDoorWithGrasp.Active cmd);
	    concurrent(cmd.end, end_bounds);
	  }

	  if(door_locked == true){
	    // TwistHandle([start, +inf], end_bounds] == Active();
	    starts_before(TwistHandle.Active cmd);
	    concurrent(cmd.end, end_bounds);
	  }

	}
	else {

	  if(found_handle == true){	  

	    if(in_grasp_position == true){
	      // GraspHandle([start, +inf], end_bounds] == Active();
	      starts_before(GraspHandle.Active cmd);
	      concurrent(cmd.end, end_bounds);
	    }

	    if(in_grasp_position == false){
	      // MoveBase([start, +inf], end_bounds] == Active();
	      starts_before(MoveBase.Active cmd);
	      concurrent(cmd.end, end_bounds);
	    }

	  }

	  if(found_handle == false){

	    if(found_door == true){

	      // If the door is locked and we cannot find the handle we will abort immediately
	      if(door_locked == true){
		meets(MoveBehavior.Inactive mb);
		eq(mb.status, ABORTED);
		eq(duration, 1);
	      }

	      if(door_locked == false){
		// OpenDoorWithoutGrasp([start, +inf], end_bounds] == Active();
		starts_before(OpenDoorWithoutGrasp.Active cmd);
		concurrent(cmd.end, end_bounds);
	      }

	    }

	    if(found_door == false){
	    
	      if(in_detection_position == true){
		// DetectDoor([start, +inf], end_bounds] == Active();
		starts_before(DetectDoor.Active cmd);
		concurrent(cmd.end, end_bounds);

	      }

	      if(in_detection_position == false){
		// MoveBase([start, +inf], end_bounds] == Active( ...);
		starts_before(MoveBase.Active cmd);
		concurrent(cmd.end, end_bounds);
	      }
	    }
	  }
	}
      }
    }
  }
}

CheckDoorway::Inactive{

  // Update door controller with feedback
  any(DoorController.Holds dc);
  TIME_ERROR_BOUND error;
  temporalDistance(dc.start, error, start);

  // If successful it means we were able to execute the check. The result can still be clear or not
  if(status == SUCCESS){
    eq(dc.doorway_clear, doorway_clear);
  }
  else {
    eq(dc.doorway_clear, false);
  }
}

ReleaseDoor::Inactive{

  // Update door controller with feedback
  any(DoorController.Holds dc);
  TIME_ERROR_BOUND error;
  temporalDistance(dc.start, error, start);

  // If successful it means we were able to execute the check. The result can still be clear or not
  if(status == SUCCESS){
    eq(dc.have_handle, have_handle);
  }
  else {
    eq(dc.have_handle, MAYBE);
  }
}

DetectDoor::Inactive{

  // Update door controller with feedback
  any(DoorController.Holds dc);
  TIME_ERROR_BOUND error;
  temporalDistance(dc.start, error, start);

  // If successful, update the state with feedback. Note that at this point we could
  // set values for door and handle state. On the other hand, we could also just
  // start a door detector
  if(status == SUCCESS){
    eq(dc.found_door, found_door);
    eq(dc.found_handle, found_handle);

    if(found_door == true){
      eq(dc.in_detection_position, true);
    }
  }
  else {
    eq(dc.found_door, false);
    eq(dc.found_handle, false);
    eq(dc.in_detection_position, false);
  }
}


OpenDoorWithoutGrasp::Inactive{
  // Update door controller with feedback
  any(DoorController.Holds dc);
  TIME_ERROR_BOUND error;
  temporalDistance(dc.start, error, start);
  
  // If successful, there is nothing really to do, since it will depend on the CheckDoorway
  // behavior finding the clear path. What we can do is reset the last checked time to 0
  if(status == SUCCESS){
    eq(dc.last_checked_door, 0);
  }
  else { // Trigger a reset?
    eq(dc.found_door, false);
    eq(dc.found_handle, false);
    eq(dc.in_detection_position, false);

  }
}

// Internal
MoveBehavior doorman = new MoveBehavior(Internal, true);
DoorController door_controller = new DoorController(Internal);

// Safety
MobilityStatus mobility_status = new MobilityStatus(External);

// External RCS state variables
BaseState base_state = new BaseState(External);
HandleState handle_state = new HandleState(External);
DoorState door_state = new DoorState(External);

// External RCS Highlevel controllers
MoveBase move_base = new MoveBase(External);
ReleaseDoor release_door = new ReleaseDoor(External);
OpenDoorWithGrasp open_door_with_grasp = new OpenDoorWithGrasp(External);
TwistHandle twist_handle = new TwistHandle(External);
GraspHandle grasp_handle = new GraspHandle(External);
OpenDoorWithoutGrasp open_door_without_grasp = new OpenDoorWithoutGrasp(External);
DetectDoor detect_door = new DetectDoor(External);
CheckDoorway check_door = new CheckDoorway(External);
