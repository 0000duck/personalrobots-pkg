#include "plugs/imports.nddl"

enum BOOL {yes, no, maybe};

/**
 * @todo Get better default values
 */
class PlugState extends AgentTimeline {
  predicate Holds{
    string frame_id;
    float time_stamp;
    bool stowed;
    float x;
    float y;
    float z;
    defaultOnCommit(stowed, true);
  }

  PlugState(){super(Internal, "Holds");}
};

class OutletState extends AgentTimeline {
  predicate Holds{
    string frame_id;
    float time_stamp;
    float x;
    float y;
    float z;
    float qx;
    float qy;
    float qz;
    float qw;

  }

  OutletState(){super(Internal, "Holds");}
};

class RechargeController extends AgentTimeline {

  predicate Holds {
    bool active;
    bool in_position;
    bool outlet_detected_coarse;
    bool outlet_detected_fine;
    bool recharged;
    BOOL plug_is_stowed;
    bool ready_to_plug_in;
    bool plug_in_hand;
    bool plugged_in;
    bool ready_to_grasp;
    bool arms_clear;
    bool finishing;
    bool restowing_plug;
  }
  
  RechargeController(){ super(Internal, "Holds"); }
};

// Internal Timelines
OutletState outlet_state = new OutletState();
PlugState plug_state = new PlugState();
Recharger recharger = new Recharger(Internal);
RechargeController recharge_controller = new RechargeController();

// Initialize controller to inactive
fact(recharge_controller.Holds rc_initial_state);
rc_initial_state.active = false;

RechargeController::Holds{
/*
  if(active == false){
    contained_by(recharger.Inactive);
    // These could be contained_by relations but then we would need a heuristic in the solver to order
    // open conditions between states and recharge controller slaves.
    equals(outlet_state.Holds);
    equals(plug_state.Holds);
  }
*/
  met_by(Holds p);
  defaultOnCommit(active, p.active);
  defaultOnCommit(in_position, p.in_position);
  defaultOnCommit(outlet_detected_coarse, p.outlet_detected_coarse);
  defaultOnCommit(outlet_detected_fine, p.outlet_detected_fine);
  defaultOnCommit(recharged, p.recharged);
  defaultOnCommit(plug_is_stowed, p.plug_is_stowed);
  defaultOnCommit(ready_to_plug_in, p.ready_to_plug_in);
  defaultOnCommit(plug_in_hand, p.plug_in_hand);
  defaultOnCommit(plugged_in, p.plugged_in);
  defaultOnCommit(ready_to_grasp, p.ready_to_grasp);
  defaultOnCommit(arms_clear, p.arms_clear);
  defaultOnCommit(finishing, p.finishing);
  defaultOnCommit(restowing_plug, p.restowing_plug);
}

/**
 * Main control loop. Note that exi
 */
RechargeController::Holds {
  if(active == true){
    // Derive arms_tucked from external safety monotor
    bool arms_tucked;
    starts_during(mobility_status.Holds mb);
    eq(arms_tucked, mb.arms_tucked);
    meets(Holds s); // Successor

    // Should be active. Get outlet param from it. Only require that for local navigation
    contained_by(recharger.Active rc_active);

    // Link to plug and outlet state
    contained_by(outlet_state.Holds os);
    contained_by(plug_state.Holds ps);

    if (finishing == true) {
      if (arms_tucked == true){
        meets(recharger.Inactive rc_inactive);
        eq(duration, 1);
        eq(s.active, false);
	eq(rc_inactive.status, ABORTED);
      }
      if (arms_tucked == false) {
        if (plug_is_stowed == yes) {
          contains_start(safety_tuck_arms.Active cmd);
          concurrent(cmd.end, end);
          eq(s.arms_clear, false);
        }
        else {
          if (plug_is_stowed == maybe) {
            if (arms_clear == true) {
              contains_start(detect_plug_on_base.Active cmd);
              concurrent(cmd.end, end);
            }
            else {
              contains_start(plugs_untuck_arms.Active cmd);
              concurrent(cmd.end, end);
            }
          }
          else {
            
            if (plugged_in == true) {
              contains_start(unplug.Active cmd);
              concurrent(cmd.end, end);
              eq(s.arms_clear, false);
            }
            else {
              contains_start(stow_plug.Active cmd);
              concurrent(cmd.end, end);
              eq(s.arms_clear, false);
            }
          }
        }
      }
    }

    // not finishing
    else {
    
      if(recharged == true){

        if(plug_is_stowed == yes){
          if (arms_tucked == true) {
            meets(recharger.Inactive rc_inactive);
            eq(rc_inactive.status, SUCCESS);
            eq(duration, 1);
            eq(s.active, false);
          }
          else {
            contains_start(safety_tuck_arms.Active cmd);
          }
        }

        // plug not stowed
        else{
          if(plug_is_stowed == maybe){
            if (arms_clear == true) {
              contains_start(detect_plug_on_base.Active cmd);
              concurrent(cmd.end, end);
            }
            else {
              contains_start(plugs_untuck_arms.Active cmd);
              concurrent(cmd.end, end);
            }
          }
          else {
            if(plugged_in == false){
              contains_start(stow_plug.Active cmd);
              concurrent(cmd.end, end);
              eq(s.arms_clear, false);
            }
            else {
              contains_start(unplug.Active cmd);
              concurrent(cmd.end, end);
              eq(s.arms_clear, false);
            }
          }
        }
      }


      // recharged == false
      else {
          
        if (ready_to_plug_in == true){
          contains_start(plug_in.Active cmd);
          concurrent(cmd.end, end);
          eq(s.arms_clear, false);
        }

        // not ready to plug in
        else {

          if (plug_in_hand == true) {
            // Nominal case: localize plug once it's in hand
            if (restowing_plug == false) {
              contains_start(localize_plug_in_gripper.Active cmd);
              concurrent(cmd.end, end);
            }

            // If localizaion fails, restow and go back
            else {
              contains_start(stow_plug.Active cmd);
              concurrent(cmd.end, end);
              eq(s.arms_clear, false);
            }
          }
            
          // plug not in hand
          else {

            if(ready_to_grasp == true){
              contains_start(move_and_grasp_plug.Active cmd);
              eq(cmd.x, ps.x);
              eq(cmd.y, ps.y);
              eq(cmd.z, ps.z);
              eq(cmd.frame_id, ps.frame_id);
              concurrent(cmd.end, end);
              eq(s.arms_clear, false);
            }

            // not ready to grasp plug (not detected)
            else {
              
              if (outlet_detected_fine == true) {

                if(arms_clear == true){
                  contains_start(detect_plug_on_base.Active cmd);
                  concurrent(cmd.end, end);
                }

                // arms not clear: untuck
                else {
                  contains_start(plugs_untuck_arms.Active cmd);
                  concurrent(cmd.end, end);
                }
              }

              // outlet fine detection hasn't happened
              else {
                
                // coarse has happened
                if (outlet_detected_coarse == true) {

                  // we're in position: detect it
                  if (in_position == true) {
                    contains_start(detect_outlet_fine.Active cmd);
                    eq(cmd.x, os.x);
                    eq(cmd.y, os.y);
                    eq(cmd.z, os.z);
                    eq(cmd.frame_id, os.frame_id);
                    concurrent(cmd.end, end);
                  }

                  // not in position: move
                  else {
		    // Use indirection so we can route to a stub for the purposes of testing without actual plug actions
                    contains_start(move_base_local.Active cmd);

                    // TODO ; Constraint should have inputs after outputs
                    plugs_get_offset_pose(os.x, os.y, os.z, os.qx, os.qy, os.qz, os.qw, 0.6, 
                                          cmd.x, cmd.y, cmd.z, cmd.qx, cmd.qy,cmd.qz, cmd.qw);
                    
                    eq(cmd.frame_id, os.frame_id);
                    concurrent(cmd.end, end);

		    // Laser tilt action must run first.
		    contains_start(set_laser_tilt.Active cmd_set_laser_tilt);
		    cmd_set_laser_tilt before cmd;
		    eq(cmd_set_laser_tilt.status, SUCCESS);
                  }
                }

                // coarse hasn't happened
                else {
                  
                    if (arms_tucked == true) {
                      contains_start(detect_outlet_coarse.Active cmd);
                      concurrent(cmd.end, end);
                    }
                    else {
                      contains_start(safety_tuck_arms.Active cmd);
                      concurrent(cmd.end, end);
                    }
                }
              }
            }
          }
        }
      }
    }
  }
}



/**************************************************
 * Update Rules
 *************************************************/

MoveBase::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.in_position, true);
  }
  else {
    //eq(rc.finishing, true);
  }
}

// This is a little tricky. This only alters the arms clear parameter
// which may me mergeable with the prior state. If we are active, we actually need to impose a
// re-evaluation. A simpler solution might simply be to impose a starts constraint after all!
SafetyTuckArms::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.arms_clear, false);
  }
}

DetectPlugOnBase::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.plug_is_stowed, yes);
    eq(rc.ready_to_grasp, true);

    // Update PlugState
    starts(plug_state.Holds ps);
    eq_plug_stow_msg(ps.object, object);
  }
  else {
    eq(rc.finishing, true);
  }
}

PlugsUntuckArms::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.arms_clear, true);
  }
  else {
    eq(rc.finishing, true);
  }
}

StowPlug::Active{
  starts_during(plug_state.Holds ps);
  eq_plug_stow_msg(object, ps.object);
}

// If we stow successfully, declare maybe. Requires confirmation!
// Changing this to yes for now - BMM
StowPlug::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.plug_is_stowed, maybe);
    eq(rc.plug_in_hand, false);
    eq(rc.restowing_plug, false);
  }
  else {
    eq(rc.finishing, true);
  }
}

Unplug::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.plugged_in, false);
  }
  else {
    eq(rc.finishing, true);
  }
}

PlugIn::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.plugged_in, true);
    eq(rc.recharged, true);
  }
  else {
    eq(rc.finishing, true);
  }
}

DetectOutletFine::Active{
  starts_during(outlet_state.Holds os);
  eq_point_msg(object, os.object);
}

DetectOutletFine::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.outlet_detected_fine, true);

    // Update outlet state with feedback
    starts(outlet_state.Holds os);
    eq_pose_msg(os.object, object);
  }
  else {
    eq(rc.finishing, true);
  }
}

DetectOutletCoarse::Active{
  starts_during(outlet_state.Holds os);
  eq_point_msg(object, os.object);
}

DetectOutletCoarse::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.outlet_detected_coarse, true);
    eq(rc.in_position, false);

    // Update outlet state with feedback
    starts(outlet_state.Holds os);
    eq_pose_msg(os.object, object);
  }
  else {
    eq(rc.finishing, true);
  }
}

LocalizePlugInGripper::Active{
  starts_during(outlet_state.Holds os);
  eq_pose_msg(object, os.object);
}

LocalizePlugInGripper::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.ready_to_plug_in, true);
  }
  else {
    eq(rc.restowing_plug, true);
  }
}

MoveAndGraspPlug::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.plug_in_hand, true);
    eq(rc.ready_to_grasp, false);
    eq(rc.plug_is_stowed, no);
  }
  if (status == ABORTED) {
    eq(rc.ready_to_grasp, false);
  }
}
