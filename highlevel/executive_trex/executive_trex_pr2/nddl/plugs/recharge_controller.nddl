#include "plugs/imports.nddl"

enum BOOL {yes, no, maybe};

/**
 * ALL TIME BOUNDS FOR INTERNAL ACTIONS
 */
float DETECT_OUTLET_COARSE_DURATION_BOUND = 60.0;
float DETECT_OUTLET_FINE_DURATION_BOUND = 60.0;
float PLUGS_UNTUCK_ARMS_DURATION_BOUND = 60.0;
float DETECT_PLUG_ON_BASE_DURATION_BOUND = 60.0;
float MOVE_BASE_LOCAL_DURATION_BOUND = 60.0;
float MOVE_BASE_DURATION_BOUND = 60.0;
float MOVE_AND_GRASP_PLUG_DURATION_BOUND = 60.0;
float LOCALIZE_PLUG_IN_GRIPPER_DURATION_BOUND = 60.0;
float PLUG_IN_DURATION_BOUND = 180.0;
float UNPLUG_DURATION_BOUND = 60.0;
float STOW_PLUG_DURATION_BOUND = 60.0;
float SAFETY_TUCK_ARMS_DURATION_BOUND = 60.0;

/**
 * @todo Get better default values
 */
class PlugState extends AgentTimeline {
  predicate Holds{
    string frame_id;
    float time_stamp;
    bool stowed;
    float x;
    float y;
    float z;
    defaultOnCommit(stowed, true);
  }

  PlugState(){super(Internal, "Holds");}
};

class OutletState extends AgentTimeline {
  predicate Holds{
    string frame_id;
    float time_stamp;
    float x;
    float y;
    float z;
    float qx;
    float qy;
    float qz;
    float qw;

  }

  OutletState(){super(Internal, "Holds");}
};

class RechargeController extends AgentTimeline {

  predicate Holds {
    bool active;
    bool in_position;
    bool outlet_detected_coarse;
    bool outlet_detected_fine;
    bool recharged;
    BOOL plug_is_stowed;
    bool ready_to_plug_in;
    bool plug_in_hand;
    bool plugged_in;
    bool ready_to_grasp;
    bool arms_clear; // Need this because the arm could be anywhere in principle!
    bool resetting;
    bool timed_out;
  }
  
  RechargeController(){ super(Internal, "Holds"); }
};

// Internal Timelines
OutletState outlet_state = new OutletState();
PlugState plug_state = new PlugState();
Recharger recharger = new Recharger(Internal);
RechargeController recharge_controller = new RechargeController();

// Initialize controller to inactive
fact(recharge_controller.Holds rc_initial_state);
rc_initial_state.active = false;

RechargeController::Holds{
  met_by(Holds p);
  defaultOnCommit(active, p.active);
  defaultOnCommit(in_position, p.in_position);
  defaultOnCommit(outlet_detected_coarse, p.outlet_detected_coarse);
  defaultOnCommit(outlet_detected_fine, p.outlet_detected_fine);
  defaultOnCommit(recharged, p.recharged);
  defaultOnCommit(plug_is_stowed, p.plug_is_stowed);
  defaultOnCommit(ready_to_plug_in, p.ready_to_plug_in);
  defaultOnCommit(plug_in_hand, p.plug_in_hand);
  defaultOnCommit(plugged_in, p.plugged_in);
  defaultOnCommit(ready_to_grasp, p.ready_to_grasp);
  defaultOnCommit(arms_clear, p.arms_clear);
  defaultOnCommit(resetting, p.resetting);
}

/**
 * Main control loop step.
 */
RechargeController::Holds {
  if(active == true){
    // Derive arms_tucked from external safety monotor
    bool arms_tucked;
    starts_during(mobility_status.Holds mb);
    eq(arms_tucked, mb.arms_tucked);
    meets(Holds s); // Successor

    // Should be active. Get outlet param from it. Only require that for local navigation
    contained_by(recharger.Active rc_active);

    // Compute a bound on the duration of any action we launch from here based on the global time limit
    int elapsed_ticks;
    float elapsed_time, remaining_time;
    addEq(rc_active.start, elapsed_ticks, start);
    mulEq(elapsed_ticks, TICK_DURATION, elapsed_time);
    addEq(elapsed_time, remaining_time, rc_active.max_duration);

    testLEQ(timed_out, remaining_time, 0.0);
    if(timed_out == true){
      eq(s.resetting, true);
    }

    // Here we are resetting - either to rety or to finish up
    if (resetting == true){
      if (plug_is_stowed == yes){
	if (arms_tucked == true){
	  if(timed_out == true){
	    meets(recharger.Inactive rc_inactive);
	    eq(duration, 1);
	    eq(s.active, false);
	    eq(rc_inactive.status, ABORTED);
	  }
	  else {
	    if(in_position == true){
	      meets(recharger.Inactive rc_inactive);
	      eq(duration, 1);
	      eq(s.active, false);

	      if(recharged == true){
		eq(rc_inactive.status, SUCCESS);
	      }
	      else {
		eq(rc_inactive.status, ABORTED);
	      }
	    }
	    else{
	      contains_start(move_base.Active cmd);
	      concurrent(cmd.end, end);
	      leq(cmd.max_duration, MOVE_BASE_DURATION_BOUND);
	      leq(cmd.max_duration, remaining_time);

	      // Bind pose based on approach pose for the outlet
	      map_get_outlet_approach_pose(cmd.x, cmd.y, cmd.z, cmd.qx, cmd.qy, cmd.qz, cmd.qw, rc_active.outlet_id);
	      defaultOnCommit(cmd.frame_id, "map");

	      // PRE-REQ
	      contains_start(set_laser_tilt.Active cmd_set_laser_tilt);
	      eq(cmd_set_laser_tilt.status, SUCCESS);
	      cmd_set_laser_tilt before cmd;
	    }
	  }
	}

	if(arms_tucked == false){
          contains_start(safety_tuck_arms.Active cmd);
          concurrent(cmd.end, end);
	  leq(cmd.max_duration, SAFETY_TUCK_ARMS_DURATION_BOUND);
          eq(s.arms_clear, false);
	}
      }
      /*
	if (plug_is_stowed == maybe){
	// Can this step be ommitted?
	// Need to confirm
	if (arms_clear == true) {
	contains_start(detect_plug_on_base.Active cmd);
	concurrent(cmd.end, end);
	leq(cmd.max_duration, DETECT_PLUG_ON_BASE_DURATION_BOUND);
	leq(cmd.max_duration, remaining_time);
	}
	else {
	contains_start(plugs_untuck_arms.Active cmd);
	concurrent(cmd.end, end);
	leq(cmd.max_duration, PLUGS_UNTUCK_ARMS_DURATION_BOUND);
	leq(cmd.max_duration, remaining_time);
	}
	}
      */
      if (plug_is_stowed == no){
	if (plugged_in == false){
	  contains_start(stow_plug.Active cmd);
	  concurrent(cmd.end, end);
	  leq(cmd.max_duration, STOW_PLUG_DURATION_BOUND);
	  eq(s.arms_clear, false);
	}
	else {
	  contains_start(unplug.Active cmd);
	  concurrent(cmd.end, end);
	  leq(cmd.max_duration, UNPLUG_DURATION_BOUND);
	  eq(s.arms_clear, false);
	}
      }
    }
    
    // Thus begins the process of plugging in
    if (resetting == false){
      if (ready_to_plug_in == true){
	contains_start(plug_in.Active cmd);
	concurrent(cmd.end, end);
	leq(cmd.max_duration, PLUG_IN_DURATION_BOUND);
	leq(cmd.max_duration, remaining_time);
	eq(s.arms_clear, false);
	eq(cmd.outlet_id, rc_active.outlet_id);
      }
      else {
	if (plug_in_hand == true) {
	  contains_start(localize_plug_in_gripper.Active cmd);
	  concurrent(cmd.end, end);
	  leq(cmd.max_duration, LOCALIZE_PLUG_IN_GRIPPER_DURATION_BOUND);
	  leq(cmd.max_duration, remaining_time);
	}
	else {
	  if(ready_to_grasp == true){
	    contains_start(move_and_grasp_plug.Active cmd);
	    concurrent(cmd.end, end);
	    leq(cmd.max_duration, remaining_time);
	    leq(cmd.max_duration, MOVE_AND_GRASP_PLUG_DURATION_BOUND);
	    eq(s.arms_clear, false);
	  }
	  else {   
	    if (outlet_detected_fine == true) {
	      if(arms_clear == true){
		contains_start(detect_plug_on_base.Active cmd);
		concurrent(cmd.end, end);
		leq(cmd.max_duration, DETECT_PLUG_ON_BASE_DURATION_BOUND);
		leq(cmd.max_duration, remaining_time);
	      }
	      else {
		contains_start(plugs_untuck_arms.Active cmd);
		concurrent(cmd.end, end);
		leq(cmd.max_duration, PLUGS_UNTUCK_ARMS_DURATION_BOUND);
		leq(cmd.max_duration, remaining_time);
	      }
	    }
	    else {
	      if (outlet_detected_coarse == true) {
		if (in_position == true) {
		  contains_start(detect_outlet_fine.Active cmd);
		  concurrent(cmd.end, end);
		  leq(cmd.max_duration, DETECT_OUTLET_FINE_DURATION_BOUND);
		  leq(cmd.max_duration, remaining_time);
		}
		else {
		  contains_start(move_base_local.Active cmd);
		  concurrent(cmd.end, end);
		  leq(cmd.max_duration, MOVE_BASE_LOCAL_DURATION_BOUND);
		  leq(cmd.max_duration, remaining_time);

		  // Here we can obtain the outlet state to get parameters from move_base local since
		  // it should not be done generically at the action level as this is a shared action
		  starts_during(outlet_state.Holds os);
		  eq(cmd.frame_id, os.frame_id);
		  plugs_get_offset_pose(os.x, os.y, os.z, os.qx, os.qy, os.qz, os.qw, 0.6, 
					cmd.x, cmd.y, cmd.z, cmd.qx, cmd.qy,cmd.qz, cmd.qw);

		  contains_start(set_laser_tilt.Active cmd_set_laser_tilt);
		  eq(cmd_set_laser_tilt.status, SUCCESS);
		  cmd_set_laser_tilt before cmd;
		}
	      }

	      if (outlet_detected_coarse == false) {
		if (arms_tucked == true) {
		  contains_start(detect_outlet_coarse.Active cmd);
		  concurrent(cmd.end, end);
		  leq(cmd.max_duration, DETECT_OUTLET_COARSE_DURATION_BOUND);
		  leq(cmd.max_duration, remaining_time);
		}
		else {
		  contains_start(safety_tuck_arms.Active cmd);
		  concurrent(cmd.end, end);
		  leq(cmd.max_duration, SAFETY_TUCK_ARMS_DURATION_BOUND);
		}
	      }
	    }
	  }
	}
      }
    }
  }
}



/**************************************************
 * Update Rules
 *************************************************/

/**
 * We use move_base_local to approach the wall and move_base to reposition.
 */
MoveBase::Inactive{
  starts(RechargeController.Holds rc);
  
  if(object == move_base_local){
    if(status == SUCCESS){
      eq(rc.in_position, true);
    }
    else{
      eq(rc.resetting, true);
      eq(rc.in_position, false);
    }
  }
  
  if(object == move_base){
    if(status == SUCCESS){
      // Pretty much a full reset
      eq(rc.in_position, true);
      eq(rc.resetting, false);	
      eq(rc.outlet_detected_coarse, false);
      eq(rc.outlet_detected_fine, false);
      eq(rc.recharged, false);
      eq(rc.plug_is_stowed, yes);
      eq(rc.ready_to_plug_in, false);
      eq(rc.plug_in_hand, false);
      eq(rc.plugged_in, false);
      eq(rc.ready_to_grasp, false);
    }
  }
}

DetectPlugOnBase::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.plug_is_stowed, yes);
    eq(rc.ready_to_grasp, true);

    // Update PlugState
    starts(plug_state.Holds ps);
    eq_plug_stow_msg(ps.object, object);
  }
}

PlugsUntuckArms::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.arms_clear, true);
  }
  else {
    eq(rc.resetting, true);
    eq(rc.in_position, false);
  }
}

StowPlug::Active{
  starts_during(plug_state.Holds ps);
  eq_plug_stow_msg(object, ps.object);
}

// If we stow successfully, declare maybe. Requires confirmation!
StowPlug::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.plug_is_stowed, yes);
    eq(rc.plug_in_hand, false);
  }
}

Unplug::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.plugged_in, false);
  }
}

PlugIn::Inactive{
  starts(RechargeController.Holds rc);
  eq(rc.resetting, true);
  if(status == SUCCESS){
    eq(rc.plugged_in, true);
    eq(rc.recharged, true);
  }
  else {
    eq(rc.in_position, false);
  }
}

DetectOutletFine::Active{
  starts_during(outlet_state.Holds os);
  eq_point_msg(object, os.object);
}

DetectOutletFine::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.outlet_detected_fine, true);

    // Update outlet state with feedback
    starts(outlet_state.Holds os);
    eq_pose_msg(os.object, object);
  }
  else {
    eq(rc.resetting, true);
    eq(rc.in_position, false);
  }
}

DetectOutletCoarse::Active{
  starts_during(outlet_state.Holds os);
  eq_point_msg(object, os.object);
}

DetectOutletCoarse::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.outlet_detected_coarse, true);
    eq(rc.in_position, false);

    // Update outlet state with feedback
    starts(outlet_state.Holds os);
    eq_pose_msg(os.object, object);
  }
  else {
    eq(rc.resetting, true);
    eq(rc.in_position, false);
  }
}

LocalizePlugInGripper::Active{
  starts_during(outlet_state.Holds os);
  eq_pose_msg(object, os.object);
}

LocalizePlugInGripper::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.ready_to_plug_in, true);
  }
  else {
    eq(rc.resetting, true);
    eq(rc.in_position, false);
  }
}

MoveAndGraspPlug::Active{
  starts_during(plug_state.Holds ps);
  eq_point_msg(object, ps.object);
}

MoveAndGraspPlug::Inactive{
  starts(RechargeController.Holds rc);
  if(status == SUCCESS){
    eq(rc.plug_in_hand, true);
    eq(rc.ready_to_grasp, false);
    eq(rc.plug_is_stowed, no);
  }
  else{
    eq(rc.resetting, true);
    eq(rc.in_position, false);
  }
}
