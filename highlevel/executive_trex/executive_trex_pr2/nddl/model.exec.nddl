/*
 * model.exec.nddl
 * Copyright (c) 2009, Willow Garage, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <ORGANIZATION> nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "model.core.nddl"

float XY_ERROR = 0.5;
float THETA_ERROR = 0.1;
float MIN_RECHARGE = 500.0;
int WAIT_TIME_AFTER_UNPLUGGING = 5;



/**
 * This is an abstract state variable which reflects if we are 
 * able to do useful work or if we should focus on recharging. Tripping this state variable
 * into a recharging state will lock out other activities from execution until we are able to
 * finish recharging.
 */
class WorkingStatus extends AgentTimeline {

  predicate Holds{bool recharging;}

  WorkingStatus(){
    super(Internal, "Holds");
  }
};

/**
 * A waypoint to go to
 */
class Location {
  float x;
  float y;
  float th;

  Location(float x_, float y_, float th_){
    x = x_;
    y = y_;
    th = th_;
  }
};

/**
 * The x, y, and theta values for a charging station. These describe the
 * target base pose for the robot when recharging.
 */
class ChargingStation extends Location {
  ChargingStation(float x, float y, float th){
    super(x, y, th);
  }
};

class Waypoint extends Location {
  Waypoint(float x, float y, float th){
    super(x, y, th);
  }
};

/**
 * A Navigator can navigate towards the given waypoint by repeatedly calling a lower level base controller (MoveBase). This pattern will allow
 * suspension and resumption of progress towards a goal if pre-empted by the need to recharge.
 */
class Navigator extends Behavior {

  /**
   * When active, we are pursuing a waypoint, although we may be pre-empted
   */
  predicate Active{
    Waypoint w;
  }

  Navigator(){
    super(Internal, "Inactive");
  }
};

/**
 * A top level timeline that will drive navigation goals until a target iteration count is reached.
 */
class VenusDeMiles extends AgentTimeline {

  predicate Holds{
    int iterationCount; // Current iteration count
    int iterationLimit; // Iteration Limit (when done)
    bool alwaysBusy; // When true, keep going
    Waypoint w; // Way point to achieve
  }

  VenusDeMiles(){
    super(Internal, "Holds");
  }
};

BaseState::Holds{
  defaultOnCommit(accumulatedDistance, 0.0);
  if(end){
    meets(Holds s);
    float distance;
    calcDistance(distance, x, y, s.x, s.y);
    addEq(accumulatedDistance, distance, s.accumulatedDistance);
  }
}

/**
 * All behaviors will oscillate between active and inactive
 */
Behavior::Inactive{
  precedes(start, missionEnd);
  // These semantics are that we want to check a constraint, but not drive planning. It would be much better
  // to have these more explicitly listed as constraints, that get applied accordingly. For example, as transition
  // constraints. This guard structure is a hack.
  if(end){
    meets(Active);
  }
}

Behavior::Active{
  // Parameter Constraints
  leq(duration, max_duration);

  // Constraint on successor state
  meets(Inactive);

  // All behaviors must deactivate before the end of the agent time window
  precedes(end, missionEnd);
}

MoveBase::Inactive {
  default(recharging, false);

  // If desired values are set, then they are used to bind parameters of the
  // predecessor to accomplish the desired position.
  if(desX){
    if(desY) {
      if(desTh) {
	met_by(Active p);
	eq(p.x, desX);
	eq(p.y, desY);
	eq(p.th, desTh);
	eq(p.recharging, recharging);
      }
    }
  }

  // Require actual and desired values to be within some tolerance
  addEq(x, [-1.5, 1.5], desX);
  addEq(y, [-1.5, 1.5], desY);
  addEq(th, [-.25, .25], desTh);
}

MoveBase::Active{
 default(th, 0.0);

 // This part is particular to the MoveBase node. It is probably fair that it would apply to all behaviors
 // in the ROS set up, but not all behaviors more generally. This pattern allows us to impose a bounded
 // synchronization model
 temporalDistance(dispatch_time, [0, 2], start);

 // If at the end, apply a default to the timeout flag so that it is not zero.
 // This ensures the flag is set even if a max duration bound is not imposed
 if(end){
   defaultOnCommit(timed_out, false);
 }

 // If the working status indicates that we are recharging, then we better be heading for a charging station
 contained_by(WorkingStatus.Holds ws);
 eq(ws.recharging, recharging);

 if(recharging == true){
   ChargingStation cs;
   eq(cs.x, x);
   eq(cs.y, y);
   eq(cs.th, th);
 }

}

MoveArm::Inactive{
  if(des_shoulder_pan){
    if(des_shoulder_pitch){
      if(des_upperarm_roll){
	if(des_elbow_flex){
	  if(des_forearm_roll){
	    if(des_wrist_flex){
	      if(des_gripper_roll){
		met_by(Active p);
		eq(p.shoulder_pan, des_shoulder_pan);
		eq(p.shoulder_pitch, des_shoulder_pitch);
		eq(p.upperarm_roll, des_upperarm_roll);
		eq(p.elbow_flex, des_elbow_flex);
		eq(p.forearm_roll, des_forearm_roll);
		eq(p.wrist_flex, des_wrist_flex);
		eq(p.gripper_roll, des_gripper_roll);

		//checking desired values
		addEq(shoulder_pan, [-.15, .15], des_shoulder_pan);
		addEq(shoulder_pitch, [-.15, .15], des_shoulder_pitch);
		addEq(upperarm_roll, [-.15, .15], des_upperarm_roll);
		addEq(elbow_flex, [-.15, .15], des_elbow_flex);
		addEq(forearm_roll, [-.15, .15], des_forearm_roll);
		addEq(wrist_flex, [-.15, .15], des_wrist_flex);
		addEq(gripper_roll, [-.15, .15], des_gripper_roll);
	      }
	    }
	  }
	}
      }
    }
  }
}


MoveEndEffector::Inactive{
  if(des_shoulder_pan){
    if(des_shoulder_pitch){
      if(des_upperarm_roll){
	if(des_elbow_flex){
	  if(des_forearm_roll){
	    if(des_wrist_flex){
	      if(des_gripper_roll){
		met_by(Active p);
		eq(p.shoulder_pan, des_shoulder_pan);
		eq(p.shoulder_pitch, des_shoulder_pitch);
		eq(p.upperarm_roll, des_upperarm_roll);
		eq(p.elbow_flex, des_elbow_flex);
		eq(p.forearm_roll, des_forearm_roll);
		eq(p.wrist_flex, des_wrist_flex);
		eq(p.gripper_roll, des_gripper_roll);

		//checking desired values
		addEq(shoulder_pan, [-.15, .15], des_shoulder_pan);
		addEq(shoulder_pitch, [-.15, .15], des_shoulder_pitch);
		addEq(upperarm_roll, [-.15, .15], des_upperarm_roll);
		addEq(elbow_flex, [-.15, .15], des_elbow_flex);
		addEq(forearm_roll, [-.15, .15], des_forearm_roll);
		addEq(wrist_flex, [-.15, .15], des_wrist_flex);
		addEq(gripper_roll, [-.15, .15], des_gripper_roll);
	      }
	    }
	  }
	}
      }
    }
  }
}

/**
 * A simple iterator pattern - drives subgoaling on the Navigator Timeline
 */
VenusDeMiles::Holds{
  defaultOnCommit(iterationCount, 0);
  defaultOnCommit(iterationLimit, 0);
  defaultOnCommit(alwaysBusy, false);

  if(alwaysBusy == true){
    eq(iterationLimit, 1);
  }

  bool busy;
  testLT(busy, 0, iterationLimit);
  if(busy == true){
    // Alternatives:
    // navigator[start + [0, inf], end] = Active(randomSelect(w))
    randomSelect(w);
    ends(Navigator.Active n);
    eq(n.w, w);
    precedes(start, n.start);

    // Carry forward parameters
    if(end){
      meets(Holds s);
      addEq(iterationCount, 1, s.iterationCount);
      eq(iterationLimit, s.iterationLimit);
      eq(alwaysBusy, s.alwaysBusy);
    }
  }
}

WorkingStatus::Holds{
  // We should toggle between recharging and not recharging
  // this[end] == Holds(!recharging); 
  if(end){
    meets(Holds s);
    neq(s.recharging, recharging);
  }

  // By default we are not recharging
  defaultOnCommit(recharging, false);

  // Do the recharging if appropriate
  if(recharging == true){
    // Selection of a charging station can happen in principle in a number of ways. The ideal scenario is that actual obstacle data
    // is used as a constraint on the available charging station. This could occur where we would say something like:
    //   collissionFree(cs);
    // However, no such integration is available and it is an open question how to interpret that constraint given a temporal
    // context.
    //
    // We can select from the available set via the planner. This would allow branching over the decision. This could yield a very
    // high branching factor.
    // We can pick the nearest available - which is simple and efficient. However, it may force a situation where we  re-commit to an
    // unreachable location. This would look like what we had implemented before:
    //   met_by(BaseState.Holds bs);
    //   nearestReachableLocation(bs.x, bs.y, cs);
    //
    // Instead we will use the randomSelect again, and revisit this later
    ChargingStation cs;
    randomSelect(cs);

    // allow a delay after recharging before releasing the robot. Also require that we remain 
    // with the recharger inactive when we get back to work
    any(RechargeController.Inactive rc);
    eq(rc.x, cs.x);
    eq(rc.y, cs.y);
    eq(rc.th, cs.th);
    temporalDistance(rc.start, WAIT_TIME_AFTER_UNPLUGGING, end);
    precedes(end, rc.end);

    // check expected end conditions. Notation assumes a single predicate, otherwise it would be
    // ambiguous. Actually, it assumes that there is exactly one predicate with that parameter. At run
    // time this can resolve to a token that cannot be inserted. At compile time, it must resolve unabiguously
    // to a token
    // where w = batteryState[level] : (w.energy_remaining/w.energy_capacity) >= recharge_level;
    if(rc.end){
      any(BatteryState.Holds bs_e);
      eq(bs_e.object.actual_value, true);
      concurrent(rc.end, bs_e.start);
      leq(rc.recharge_level, bs_e.percentage_remaining);
    }
  }
}


/**
 * Constrain so that the recharge controller switches between plugging on and unplugging
 */
RechargeController::Inactive{
  // Preceded by an effort to get to a desired pose. This drives regression from the goal for planning
  // previous() == Active(x, y, th, recharge_level)
  if(x){
    if(y){
      if(th){
	met_by(Active p);
	eq(p.x, x);
	eq(p.y, y);
	eq(p.th, th);
	eq(p.recharge_level, recharge_level);


	// Derive the recharge level from battery state configuration
	BatteryState bs;
	eq(bs.actual_value, true);
	eq(recharge_level, bs.recharge_level);
      }
    }
  }

  // Compare values based on base state. We are only reading these values. This is an important idiom
  // to distinguish inputs evaluated from execution rather than planned for. This could be captured with suitable
  // syntax in the language to make it more explicit what is going on. All we are really doing here
  // is binding default values from execution
  // baseState[start] == Holds( desX + [-0.5, 0.5], desY + [-0.5, 0.5], desTh + [-0.5, 0.5])
  if(start){
    starts(BaseState.Holds bs);
    addEq(bs.x, [-0.5, 0.5], x);
    addEq(bs.y, [-0.5, 0.5], y);
    addEq(bs.th, [-0.5, 0.5], th);
  }
}

RechargeController::Active{
  contained_by(WorkingStatus.Holds ws);
  eq(ws.recharging, true);

  // When busy pluging in or unplugging, we require that we are located, and stationary, at the
  // correct charging station. This is derived by the given parameters
  // Alternatives:
  // moveBase[start, end] == Inactive(*, *, *, x, y, th);
  // contained_by(moveBase.Inactive(*, *, *, x, y, th):
  any(MoveBase.Inactive mb);
  eq(mb.desX, x);
  eq(mb.desY, y);
  eq(mb.desTh, th);
  eq(mb.recharging, true);
  leq(duration, mb.duration);
  precedes(mb.start, start);
  precedes(end, mb.end);
}

Navigator::Active{
  // An assignment statement? We mean to transition the state
  // label mb: moveBase[*, end] = Active(w.x, w.y, w.th);
  any(MoveBase.Active mb);
  eq(mb.x, w.x);
  eq(mb.y, w.y);
  eq(mb.th, w.th);
  concurrent(mb.end, end);

  // We further constrain mb so that it begins within this interval
  // start <= mb.start
  precedes(start, mb.start);

  // ws[mb.start, mb.end] == Holds(false);
  any(WorkingStatus.Holds ws);
  eq(ws.recharging, false);
  precedes(ws.start, mb.start);
  precedes(mb.end, ws.end);
  leq(mb.duration, ws.duration);

  // Check end conditions. Note that this formulation should always be resolved in implementation
  // by binding to an existing token. We allow for the fact that an effort to achieve the goal may have timed out,
  // in which case we will not check the end condition (which would force a replan). Instead we will simply let it go.
  // s = baseState[end];
  // distance(s.x, s.y, w.x, w.y) <= XY_ERROR
  bool temp_t;
  eq(mb.timed_out, temp_t);
  if(end){
    if(temp_t == false){
      ends(BaseState.Holds s);
      float distance;
      calcDistance(distance, s.x, s.y, w.x, w.y);
      leq(distance, XY_ERROR);
    }
  }
}

/**
 * Each update is monitored and can trigger a transition to recharging
 */
BatteryState::Holds {
  // If below the threshold, transition working status to recharge
  // if(discharge_limit > (energy_remaining / energy_capacity))
  //  workingStatus(start+1) == Holds(true);
  bool mustRecharge;
  testLEQ(mustRecharge, percentage_remaining, object.discharge_limit);
  if(mustRecharge == true){
    any(WorkingStatus.Holds ws);
    temporalDistance(start, [-inf, 1], ws.start); 
    precedes(end, ws.end);
    eq(ws.recharging, true);
  }
}

/* Internal Timelines */
VenusDeMiles venusDeMiles = new VenusDeMiles();
WorkingStatus workingStatus = new WorkingStatus();
Navigator navigator = new Navigator();

// Base. An upper bound of 10 minutes before timing out the
// effort to move the base to a target location
BaseState baseState = new BaseState(External);
MoveBase moveBase = new MoveBase(External, 300);

// Battery and Plug In Control
RechargeController rechargeController = new RechargeController(External);
BatteryState batteryState = new BatteryState(External, .7, .8);
