/**
 * This file specifies the interface for actions in the plugs domain
 * @note Detection of the plug on the base is specified in the safety area.
 */

/**
 * @brief 
 */
class PlugsUntuckArms extends ROSAction {
  predicate Active{}
  predicate Inactive{}
  PlugsUntuckArms(Mode _mode){super(_mode);}
};

/**
 * @brief For placing the plug back on the base.
 * Leaves the arm in a free position out of the way so that we can confirm that the plug is stowed
 */
class StowPlug extends ROSAction {
  predicate Active{
    float time_stamp;
    string frame_id;
    bool stowed;
    float x;
    float y;
    float z;
  }

  // No feedback. Just succeeds or not
  predicate Inactive{}

  StowPlug(Mode _mode){super(_mode);}
};

/**
 * @brief For unplugging from the socket. Just using a force controller so no args required.
 */
class Unplug extends ROSAction {

  predicate Active{}
  predicate Inactive{}

  Unplug(Mode _mode){super(_mode);}
};

/**
 * @brief Plug in, assuming we have the plug staged etc
 * @todo Might be a pose message
 */
class PlugIn extends ROSAction {

  predicate Active{}

  predicate Inactive{}

  PlugIn(Mode _mode){super(_mode);}
};

/**
 * @brief Detect the outlet with fine resolution
 */
class DetectOutletFine extends ROSAction {
  // Input takes a point
  predicate Active{
    float time_stamp; // A double encoding is reliable
    string frame_id;
    float x;
    float y;
    float z;
  }

  // Output produces a point and the normal
  predicate Inactive{
    float time_stamp; // A double encoding is reliable
    string frame_id;
    float x;
    float y;
    float z;
    float qx;
    float qy;
    float qz;
    float qw;
  }

  DetectOutletFine(Mode _mode){super(_mode);}
};

/**
 * @brief Detect the outlet with coarse resolution
 */
class DetectOutletCoarse extends ROSAction {
  // Input takes a point
  predicate Active{
    float time_stamp; // A double encoding is reliable
    string frame_id;
    float x;
    float y;
    float z;
  }

  // Output produces a point and the normal
  predicate Inactive{
    float time_stamp; // A double encoding is reliable
    string frame_id;
    float x;
    float y;
    float z;
    float qx;
    float qy;
    float qz;
    float qw;
  }

  DetectOutletCoarse(Mode _mode){super(_mode);}
};

/**
 * @brief Localize the plug in the gripper
 * @note No args - looking at it.
 */
class LocalizePlugInGripper extends ROSAction {

  // Goal takes the ouput of outlet detection
  predicate Active{
    float time_stamp; // A double encoding is reliable
    string frame_id;
    float x;
    float y;
    float z;
    float qx;
    float qy;
    float qz;
    float qw;
  }

  predicate Inactive{}

  LocalizePlugInGripper(Mode _mode){super(_mode);}
};

/**
 * @brief Move to a grasp point and grasp.
 */
class MoveAndGraspPlug extends ROSAction {
  predicate Active{
    float time_stamp; // A double encoding is reliable
    string frame_id;
    bool stowed;
    float x;
    float y;
    float z;
  }

  predicate Inactive{}

  MoveAndGraspPlug(Mode _mode){super(_mode);}
};

/**
 * Monitors battery state information
 * @see BatteryState.msg
 */
class BatteryState extends ROSStateVariable {
  float discharge_limit; // Percentage of total capacity we are allowed to draw down before recharging
  float recharge_level; // Percentage of total capacity we expect to be at or better than after recharging

  predicate Holds {
    float energy_remaining; // Remaining energy in Joules
    float energy_capacity; // Total energy capacity
    float power_consumption; // Power load in Watts
    UNIT_FLOAT percentage_remaining; // Derived value - energy_remaining/ energy_capacity
    mulEq(energy_capacity, percentage_remaining, energy_remaining);
  }

  BatteryState(Mode _mode, float ds, float rc){
    super(_mode, "Holds", true);
    discharge_limit = ds;
    recharge_level = rc;
  }

  BatteryState(Mode _mode){
    super(_mode, "Holds", true);
    discharge_limit = 0.1;
    recharge_level = 0.9;
  }
};
