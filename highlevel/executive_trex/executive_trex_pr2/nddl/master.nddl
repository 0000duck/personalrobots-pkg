/*
 * Copyright (c) 2008, Willow Garage, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <ORGANIZATION> nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

// TREX base class declaration and definitions
#include "TREX.nddl"

// Exports from sub-systems
#include "rcs.exports.nddl"
#include "driver.exports.nddl"
#include "recharger.exports.nddl"
#include "doorman.exports.nddl"
#include "safety.exports.nddl"
#include "topological_map.exports.nddl"

// Priority for goals
typedef int [0 5] PRIORITY;

// Constaint for time delay before resuming work after unplugging
int WAIT_TIME_AFTER_UNPLUGGING = 5; 

/**
 * A predefined location to go to
 */
class Location {
  float x;
  float y;
  float th;

  Location(float x_, float y_, float th_){
    x = x_;
    y = y_;
    th = th_;
  }
};

/**
 * The x, y, and theta values for a charging station. These describe the
 * target base pose for the robot when recharging.
 */
class ChargingStation extends Location {
  ChargingStation(float x, float y, float th){
    super(x, y, th);
  }
};

class Waypoint extends Location {
  Waypoint(float x, float y, float th){
    super(x, y, th);
  }
};


/**
 * This is an abstract state variable which reflects if we are 
 * able to do useful work or if we should focus on recharging. Tripping this state variable
 * into a recharging state will lock out other activities from execution until we are able to
 * finish recharging.
 */
class WorkingStatus extends AgentTimeline {

  predicate Holds{bool recharging;}

  WorkingStatus(){
    super(Internal, "Holds");
  }
};

/**
 * The Navigator turns a single navigation goal into a path over a topological map
 */
class Navigator extends Behavior {

  /**
   * When active, we are pursuing a waypoint, although we may be pre-empted
   */
  predicate Active{
    Waypoint w;
  }

  Navigator(){
    super(Internal, "Inactive");
  }
};

class Path extends AgentTimeline {

  /**
   * Extends over a traverse that is contained across a single region of the topological map.
   * This traverse is en-route to some final destination.
   */
  predicate Holds{
    // Activation status
    bool active;

    // Source pose
    float x;
    float y;

    // The region we are traversing
    MAP_KEY region;
    bool is_doorway;

    // Target pose
    float target_x;
    float target_y;
    float target_th;
    MAP_KEY target_connector;

    // Final pose
    float final_x;
    float final_y;
    float final_th;
    MAP_KEY final_region;

    // Parameter Constraints based on the topological map
    map_is_doorway(is_doorway, region);
    map_get_region_from_position(region, x, y);
    map_connector(target_connector, target_x, target_y);
    map_get_region_from_position(final_region, final_x, final_y);
  }

  Path(){
    super(Internal, "Holds");
  }
};

/**
 * Rules for Path Handling
 */
Path::Holds{
  // By default, we should be inactive
  default(active, false);

  // The predecessor
  met_by(Holds p);
  eq(p.target_x, x);
  eq(p.target_y, y);

  // Control Variable: captures if this is a thru-way (can continue under same navigation mode)
  bool thru_way;

  // If we are inactive, this is not a thru way. Moreover, we can set all target variables
  // to be the same as the start
  // BaseState(start) == Holds(x, y)
  if(active == false){
    any(BaseState.Holds bs);
    precedes(bs.start, start);
    temporalDistance(start, [1 +inf], bs.end);
    eq(bs.x, x);
    eq(bs.y, y);

    eq(thru_way, false);
    eq(x, target_x);
    eq(y, target_y);
    eq(x, final_x);
    eq(y, final_y);

    // We should also be sure that all MoveBehaviors are inactive
    MoveBehavior behaviors;
    foreach(b in behaviors){
      contained_by(b.Inactive);
    }
  }

  if(active == true){

    // Successor will be active if the error exceeds our error limit
    float error;
    bool done;
    calcDistance(error, final_x, final_y, target_x, target_y);
    testLT(done, error, POSE_ERROR);

    // Topological map functions and relations

    // If the target connector is a NO_KEY, then we are making the last leg. This is basically navigating
    // off the topological map.
    if(target_connector == NO_KEY){
      eq(target_x, final_x);
      eq(target_y, final_y);
    }

    // When we know the target_connector, we can extend the path. Note that this is really a form of search control knowlegde.
    // What we really want to to is define an ordering for resolving the decomposition so we do not generate extra work
    // until we need. This makes any planner less complicated because it will not spawn spurios successor tokens that
    // can be mingled with the search
    if(target_connector){

      // Carry forward parameters to the successor
      meets(Holds s);
      eq(s.x, target_x);
      eq(s.y, target_y);
      eq(s.final_x, final_x);
      eq(s.final_y, final_y);
      eq(s.final_th, final_th);

      // Once we know the kind of region to traverse, we should further decompose to handle the appropriate MoveBehavior
      if(is_doorway){

	// If we are not done then the successor should be active and must end before the end of the mission
	if(done == false){
	  eq(s.active, true);
	  precedes(s.end, missionEnd);
	  testEQ(thru_way, is_doorway, s.is_doorway);
	}

	// If we are done, then:
	// 1. The target connector id is always 0, indicating it is not a connector.
	// 2. The region id is the same as the final region id
	if(done == true){
	  eq(target_connector, NO_KEY);
	  eq(region, final_region);
	  eq(s.active, false);
	  eq(thru_way, false);
	}
      }
    }

    // If this is not a thru way, then we can subgoal moving to this end point.
    if(thru_way == false){
      MoveBehavior move_behavior;
      eq(move_behavior.for_doorways, is_doorway);
      ends(move_behavior.Active mb);
      eq(mb.x, target_x);
      eq(mb.y, target_y);
      eq(mb.th, 0.0);
      // BUG IN NDDL INTERPRETER FOR THIS PATTERN:
      //eq(mb.object.for_doorways, is_doorway);
      // TO DO - calculate a th that is meaningful for finding a door. We should probably
      // allow that the move base node can be commanded without a theta. We could then begin
      // by rotating to face the door as we reset the position. For this theta calculation we
      // need to compute the normal to the door. Thus we need the door! That is data that
      // shoudl be available in the topological map.
    } 
  }
}

/**
 * A top level timeline that will drive navigation goals until a target iteration count is reached. It can
 * also be used where it is always busy, in which case it just runs forever.
 */
class VenusDeMiles extends AgentTimeline {

  predicate Holds{
    int iterationCount; // Current iteration count
    int iterationLimit; // Iteration Limit (when done)
    bool alwaysBusy; // When true, keep going
    Waypoint w; // Way point to achieve
  }

  VenusDeMiles(){
    super(Internal, "Holds");
  }
};

WorkingStatus::Holds{

  // Do the recharging if appropriate
  if(recharging == true){
    // Selection of a charging station can happen in principle in a number of ways. The ideal scenario is that actual obstacle data
    // is used as a constraint on the available charging station. This could occur where we would say something like:
    //   collissionFree(cs);
    // However, no such integration is available and it is an open question how to interpret that constraint given a temporal
    // context.
    //
    // We can select from the available set via the planner. This would allow branching over the decision. This could yield a very
    // high branching factor.
    // We can pick the nearest available - which is simple and efficient. However, it may force a situation where we  re-commit to an
    // unreachable location. This would look like what we had implemented before:
    //   met_by(BaseState.Holds bs);
    //   nearestReachableLocation(bs.x, bs.y, cs);
    //
    // Instead we will use the randomSelect again, and revisit this later
    ChargingStation cs;
    randomSelect(cs);

    // allow a delay after recharging before releasing the robot. Also require that we remain 
    // with the recharger inactive when we get back to work
    any(Recharger.Inactive rc);
    eq(rc.x, cs.x);
    eq(rc.y, cs.y);
    eq(rc.th, cs.th);
    temporalDistance(rc.start, WAIT_TIME_AFTER_UNPLUGGING, end);
    precedes(end, rc.end);
  }
}

class MotionMutex extends AgentTimeline {
  predicate Using{
    MoveBehavior user;
  }

  predicate Free{}

  MotionMutex(){
    super(Internal, "Free");
  }
}

/**
 * If the working status indicates that we are recharging, then we better be heading for a charging station
 */
MoveBehavior::Active{
  contained_by(WorkingStatus.Holds ws);
  eq(ws.recharging, recharging);

  if(recharging == true){
    ChargingStation cs;
    eq(cs.x, x);
    eq(cs.y, y);
    eq(cs.th, th);
  }

  contained_by(MotionMutex.Using mutex);
  eq(mutex.user, this.object);
}


/**
 * The base state should contain a link to the path to indicate region changes.
 */
BaseState::Holds{
  contained_by(Path.Holds p);
  map_get_region_from_position(p.region, x, y);
}

WorkingStatus::Holds{
  // We should toggle between recharging and not recharging
  // this[end] == Holds(!recharging); 
  if(end){
    meets(Holds s);
    neq(s.recharging, recharging);
  }

  // By default we are not recharging
  defaultOnCommit(recharging, false);
}


Recharger::Active{
  contained_by(WorkingStatus.Holds ws);
  eq(ws.recharging, true);

  // When busy pluging in or unplugging, we require that we are located, and stationary, at the
  // correct charging station. This is derived by the given parameters
  // Alternatives:
  // moveBase[start, end] == Inactive(*, *, *, x, y, th);
  // contained_by(moveBase.Inactive(*, *, *, x, y, th):
  any(MoveBase.Inactive mb);
  eq(mb.desX, x);
  eq(mb.desY, y);
  eq(mb.desTh, th);
  eq(mb.recharging, true);
  leq(duration, mb.duration);
  precedes(mb.start, start);
  precedes(end, mb.end);
}

/**
 * Each update is monitored and can trigger a transition to recharging
 */
BatteryState::Holds {
  // If below the threshold, transition working status to recharge
  // if(discharge_limit > (energy_remaining / energy_capacity))
  //  workingStatus(start+1) == Holds(true);
  bool mustRecharge;
  testLEQ(mustRecharge, percentage_remaining, object.discharge_limit);
  if(mustRecharge == true){
    any(WorkingStatus.Holds ws);
    temporalDistance(start, [-inf, 1], ws.start); 
    precedes(end, ws.end);
    eq(ws.recharging, true);
  }
}

/** Allocate common objects **/

// Internal timelines
MotionMutex motion_mutex = new MotionMutex();
VenusDeMiles venus_de_miles = new VenusDeMiles();
Navigator navigator = new Navigator();
Path path = new Path();
WorkingStatus working_status = new WorkingStatus();

// External timelines
MoveBehavior driver = new MoveBehavior(External, false);
MoveBehavior doorman = new MoveBehavior(External, true);
Recharger recharger = new Recharger(External);
BaseState base_state = new BaseState(External);
BatteryState battery_state = new BatteryState(External);
