#include "model.core.nddl"


/**
 * NOTES:
 * 1. Could bind start times of active tokens on behaviors using a sim solver. 
 * Then the model here would dispense with the actions.
 */

class Actions extends AgentActions {
  predicate startEvent{eq(duration, 1);}
};

float XY_ERROR = 0.1;
float THETA_ERROR = 0.1;
typedef float [-1.0 1.0] LINEAR_VELOCITY;
typedef float [-3.0 3.0] ANGULAR_VELOCITY;


/**
 * A Base Controller.
 * MoveBase should impose a goal for x, y and theta.
 * A controller should be activated to pursue these values. It can have a velocity and acceleration model. Should be able to select a velocity value within bounds.
 * If we are stuck, the velocity is constrained to 0.
 * Should be able to select the abort value.
 * Should be able to set the preempted value.
 * Cases where we want to force it to transition all the time are when we have a variable to crash.
 * Stochastically select aborted and preempted flags for the deactivation state.
 */
class BaseController extends AgentTimeline {

  // Single predicate structure for all values.
  predicate Holds{

    // Target values when active
    float x;
    float y;
    float th;

    // Deltas to be used to update successor state, if not already set
    float dx;
    float dy;
    float dth;

    // Control flags
    bool active;
    bool abort;
    bool preempt;
  }

  BaseController(){super(Internal, "Holds");}
};

/**
 * This is the core implementation for a base controller. It is a stub for moving the base. Desirable short hand shown below.
 *
 * default active = false;
 * default abort = false;
 * default preempt = false;
 *
 * if(active && !abort && !preempt){
 *   met_by(Holds p);
 *   meets(Holds s);
 *   duration = 1;
 *
 *   // Apply updates to generate new base state
 *   met_by(BaseState.Holds prior);
 *   equals(BaseState.Holds current);
 *   current.x = prior.x  + p.dx;
 *   current.y = prior.y  + p.dy;
 *   current.th= prior.th + p.dth;
 *   
 *   on commit {
 *      dx = absMax(intersection(x - current.x, [-1.0, 1.0]);
 *      dy = absMax(intersection(y - current.y, [-1.0, 1.0]);
 *      dth= absMax(intersection(th- current.th,[-3.0, 3.0]);
 *
 *      if (abs(dx) >= XY_ERROR || abs(dy) >= XY_ERROR || abs(dth) > THETA_ERROR)
 *        s.active = true;
 *   }
 *
 * }
 * else {
 *   dx = 0;
 *   dy = 0;
 *   dth= 0;
 *   contained_by(MoveBase.Inactive);
 * }
 */
BaseController::Holds{
  // These control variables can be defaulted based on a random selection if we wish to create spurios behaviors.
  default(active, false);
  default(abort, false);
  default(preempt, false);

  // If it is active, compute control parameters
  if(active == true){
    if(abort == false){
      if(preempt == false){
	met_by(Holds p);
	meets(Holds s);
	eq(duration, 1);

	// Bind to prior x, y and th values for base state
	met_by(BaseState.Holds prior);
	equals(BaseState.Holds current);

	// Bind to predecessor to obtain prefered deltas
	addEq(prior.x, p.dx, current.x);
	addEq(prior.y, p.dy, current.y);
	addEq(prior.th, p.dth, current.th);

	// Bind successor x, y, th values
	eq(s.x, x);
	eq(s.y, y);
	eq(s.th, th);

	// Compute estimated values for dx, dy, and dth. These will be applied if not over-ridden by some other event.
	LINEAR_VELOCITY estDX;
	LINEAR_VELOCITY estDY;
	LINEAR_VELOCITY estDTH;

	// Bounds on dx, dy, and dth are derived by analyzing the gap
	float ub_dx, ub_dy, ub_dth;
	addEq(current.x, ub_dx, x);
	addEq(current.y, ub_dy, y);
	addEq(current.th, ub_dth, th);

	// Update estDX
	bool x_positive;
	testLEQ(x_positive, 0, ub_dx);

	if(x_positive == true){
	  leq(estDX, ub_dx);
	}

	if(x_positive == false){
	  leq(ub_dx, estDX);
	}

	// Update estDY
	bool y_positive;
	testLEQ(y_positive, 0, ub_dy);

	if(y_positive == true){
	  leq(estDY, ub_dy);
	}

	if(y_positive == false){
	  leq(ub_dy, estDY);
	}

	// Update estDTH
	bool th_positive;
	testLEQ(th_positive, 0, ub_dth);

	if(th_positive == true){
	  leq(estDTH, ub_dth);
	}

	if(th_positive == false){
	  leq(ub_dth, estDTH);
	}

	// These will not bind until second argument is a singleton
	// on commit {
	//            dx = absMax(estDX);
	//            dy = absMax(estDY);
	//            dth= absMax(estDTH);
	// }
	absMaxOnCommit(estDX);
	absMaxOnCommit(estDY);
	absMaxOnCommit(estDTH);
	defaultOnCommit(dx, estDX);
	defaultOnCommit(dy, estDY);
	defaultOnCommit(dth, estDTH);

	// if (abs(dx) >= XY_ERROR || abs(dy) >= XY_ERROR || abs(dth) > THETA_ERROR) then successor is active.
	// Otherwise, terminate the parent.
	// Implement an OR using an leq constraint. Yuck
	float abs_dx, abs_dy, abs_dth;
	bool test_dx, test_dy, test_dth;
	absVal(abs_dx, dx);
	testLEQ(test_dx, XY_ERROR, abs_dx);
	leq(test_dx, s.active);
	absVal(abs_dy, dy);
	testLEQ(test_dy, XY_ERROR, abs_dy);
	leq(test_dy, s.active);
	absVal(abs_dth, dth);
	testLEQ(test_dth, THETA_ERROR, abs_dth);
	leq(test_dth, s.active);
      }
    }
  }

  // When it has transitioned to inactive, transition the parent
  if(active == false){
    eq(dx, 0.0);
    eq(dy, 0.0);
    eq(dth, 0.0);

    contained_by(MoveBase.Inactive);
  }
}


/**
 * By default it will retain prior values
 */
BaseState::Holds{
  met_by(Holds p);
  defaultOnCommit(x, p.x);
  defaultOnCommit(y, p.y);
  defaultOnCommit(th,p.th);
  eq(duration, 1);
}

/**
 * Behavior will be started and execute perfectly.
 */
MoveBase::Active{
  starts(Actions.startEvent);

  // Activate base controller with goals
  starts(BaseController.Holds bc);
  eq(bc.active, true);
  eq(bc.x, x);
  eq(bc.y, y);
  eq(bc.th, th);
}

/**
 *
 */
MoveBase::Inactive{
  starts(BaseState.Holds bs);
  eq(bs.x, x);
  eq(bs.y, y);
  eq(bs.th, th);
}

/**
 * Behavior will be started and executed perfectly
 */
RechargeController::Active{
  starts(Actions.startEvent);
  eq(duration, 5);
  meets(Inactive s);
  eq(s.x, x);
  eq(s.y, y);
  eq(s.th, th);
  eq(s.recharge_level, recharge_level);
}

/**
 * By default it will retain prior values
 */
BatteryState::Holds{
  met_by(Holds p);
  defaultOnCommit(energy_remaining, p.energy_remaining);
  defaultOnCommit(energy_capacity, p.energy_capacity);
  defaultOnCommit(power_consumption, p.power_consumption);
  eq(duration, 1);
}

// Base
BaseState baseState = new BaseState(Internal);
MoveBase moveBase = new MoveBase(Internal);

// Battery and Plug In Control
RechargeController rechargeController = new RechargeController(Internal);
BatteryState batteryState = new BatteryState(Internal, .7, .8);

// Actions
Actions actions = new Actions();

// Internal Controllers
BaseController baseController = new BaseController();

close();


