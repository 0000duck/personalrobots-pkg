/**
 * @brief Track the state (up or down) of a specific controller in mechanism control
 */
class MechanismController extends AgentTimeline {
  predicate Holds{
    bool is_up;

    defaultOnCommit(is_up, false);
  }

  MechanismController(Mode _mode){
    super(_mode, "Holds");
  }
};

/**
 * @brief A mechanism can be controlled by at most one controller at a time. Some mechanisms
 * may require exactly one controller at all times. Others may do without control. We may also want
 * to express a specific subset of controllers that are applicable for a gievn mechanism.
 */
class Mechanism extends AgentTimeline {

  // Define a default controller, which is provided on input
  MechanismController default_controller;

  predicate Uncontrolled {}

  predicate ControlledBy{
    MechanismController controller;
  }

  Mechanism(Mode _mode, MechanismController dc){
    super(_mode, "Uncontrolled");
    default_controller = dc;
  }
};

/**
 * A controller will oscillate between being up and being down. The transition of
 * state is concurrent with (achieved by) a call to SwitchControllers
 */
MechanismController::Holds {
  // State must oscillate between being up and down
  met_by(Holds p);
  neq(p.is_up, is_up);
  meets(Holds s);
  neq(s.is_up, is_up);

  // Transition event is the reconfiguration action
  bool required;
  testLEQ(required, end, missionEnd);
  if(required == true){
    ends(SwitchControllers.Active swap_cmd);
    eq(swap_cmd.status, SUCCESS);
  }
}

Mechanism::Uncontrolled {
  meets(ControlledBy);
}

/**
 * Once we are in control, we stay in control.
 */
Mechanism::ControlledBy {
  meets(ControlledBy);
  default(controller, object.default_controller);

  // Co-temporal with the controller being up
  equals(controller.Holds mc);
  eq(mc.is_up, true);
}
