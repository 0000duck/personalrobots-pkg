/*
 * Copyright (c) 2008, Willow Garage, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <ORGANIZATION> nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

// TREX base class declaration and definitions
#include "TREX.nddl"

// Exports from sub-systems
#include "rcs.exports.nddl"
#include "rcs.exports.doorman.nddl"

// Include simulation subsystems
#include "rcs.sim.doorman.nddl"



/**
 * If an active token is dispatched, we start it immediately.
 */
Behavior::Active{
  addEq(dispatch_time, 1, start);
}

float XY_ERROR = 0.1;
float THETA_ERROR = 0.1;
typedef float [-1.0 1.0] LINEAR_VELOCITY;
typedef float [-3.0 3.0] ANGULAR_VELOCITY;


/**
 * A Base Controller.
 * MoveBase should impose a goal for x, y and theta.
 * A controller should be activated to pursue these values. It can have a velocity and acceleration model. 
 * Should be able to select a velocity value within bounds.
 * If we are stuck, the velocity is constrained to 0.
 * Should be able to select the abort value.
 * Should be able to set the preempted value.
 * Cases where we want to force it to transition all the time are when we have a variable to crash.
 * Stochastically select aborted and preempted flags for the deactivation state.
 */
class BaseController extends AgentTimeline {

  // Single predicate structure for all values.
  predicate Holds{

    // Target values when active
    float x;
    float y;
    float th;

    // Deltas to be used to update successor state, if not already set
    float dx;
    float dy;
    float dth;

    // Control flags
    bool active;
    bool abort;
    bool preempt;
  }

  BaseController(){super(Internal, "Holds", false);}
};

/**
 * This is the core implementation for a base controller. It is a stub for moving the base. Desirable short hand shown below.
 *
 * default active = false;
 * default abort = false;
 * default preempt = false;
 *
 * if(active && !abort && !preempt){
 *   duration = 1;
 *
 *   // Apply updates to generate new base state
 *   met_by(BaseState.Holds prior);
 *   equals(BaseState.Holds current);
 *   current.x = prior.x  + p.dx;
 *   current.y = prior.y  + p.dy;
 *   current.th= prior.th + p.dth;
 *   
 *   on commit {
 *      dx = absMax(intersection(x - current.x, [-1.0, 1.0]);
 *      dy = absMax(intersection(y - current.y, [-1.0, 1.0]);
 *      dth= absMax(intersection(th- current.th,[-3.0, 3.0]);
 *
 *      if (abs(dx) >= XY_ERROR || abs(dy) >= XY_ERROR || abs(dth) > THETA_ERROR)
 *        s.active = true;
 *   }
 *
 * }
 * else {
 *   dx = 0;
 *   dy = 0;
 *   dth= 0;
 *   contained_by(MoveBase.Inactive);
 * }
 */
BaseController::Holds{
  // These control variables can be defaulted based on a random selection if we wish to create spurios behaviors.
  default(active, false);
  default(abort, false);
  default(preempt, false);

  // If it is active, compute control parameters
  if(active == true){
    if(abort == false){
      if(preempt == false){
	met_by(Holds p);
	meets(Holds s);
	eq(duration, 1);

	// Bind to prior x, y and th values for base state
	met_by(BaseState.Holds prior);
	equals(BaseState.Holds current);

	// Bind to predecessor to obtain prefered deltas
	addEq(prior.x, p.dx, current.x);
	addEq(prior.y, p.dy, current.y);
	addEq(prior.th, p.dth, current.th);

	// Bind successor x, y, th values
	eq(s.x, x);
	eq(s.y, y);
	eq(s.th, th);

	// Bounds on dx, dy, and dth are derived by analyzing the gap
	float ub_dx, ub_dy, ub_dth;
	addEq(current.x, ub_dx, x);
	addEq(current.y, ub_dy, y);
	addEq(current.th, ub_dth, th);

	// Bind defaults based on linear velocity constraints. These kick in on commit. This pattern allows us to later
	// apply other methods for binding values that supersede the estimate computed by physics model
	LINEAR_VELOCITY estDX;
	LINEAR_VELOCITY estDY;
	LINEAR_VELOCITY estDTH;
	defaultOnCommit(estDX, ub_dx);
	defaultOnCommit(estDY, ub_dy);
	defaultOnCommit(estDTH, ub_dth);

	if(estDX){
	  defaultOnCommit(dx, estDX);
	}

	if(estDY){
	  defaultOnCommit(dy, estDY);
	}

	if(estDTH){
	  defaultOnCommit(dth, estDTH);
	}

	// if (abs(dx) >= XY_ERROR || abs(dy) >= XY_ERROR || abs(dth) > THETA_ERROR) then successor is active.
	// Otherwise, terminate the parent.
	// Implement an OR using an leq constraint. Yuck
	float abs_dx, abs_dy, abs_dth;
	bool test_dx, test_dy, test_dth;
	absVal(abs_dx, dx);
	testLEQ(test_dx, XY_ERROR, abs_dx);
	leq(test_dx, s.active);
	absVal(abs_dy, dy);
	testLEQ(test_dy, XY_ERROR, abs_dy);
	leq(test_dy, s.active);
	absVal(abs_dth, dth);
	testLEQ(test_dth, THETA_ERROR, abs_dth);
	leq(test_dth, s.active);
      }
    }
  }

  // When it has transitioned to inactive, transition the parent
  if(active == false){
    eq(dx, 0.0);
    eq(dy, 0.0);
    eq(dth, 0.0);

    contained_by(MoveBase.Inactive);
  }
}


/**
 * By default it will retain prior values. We will constrain its duration to 1.
 *
 * duration = 1;
 *
 * on commit {
 *  default x = previous.x;
 *  default y = previous.y;
 *  default th= previous.th;
 * }
 */
BaseState::Holds{
  met_by(Holds p);
  defaultOnCommit(x, p.x);
  defaultOnCommit(y, p.y);
  defaultOnCommit(th,p.th);
  //eq(duration, 1);
}

/**
 * Behavior will be started and execute perfectly.
 */
MoveBase::Active{
  // Activate base controller with goals
  /*
  starts(BaseController.Holds bc);
  eq(bc.active, true);
  eq(bc.x, x);
  eq(bc.y, y);
  eq(bc.th, th);
  */

  // For now, assume a constant duration, and write the end bounds thru magic so we are transported
  // to the target position instantaneouosly
  eq(duration, 3);
  meets(BaseState.Holds bs);
  eq(bs.x, x);
  eq(bs.y, y);
  eq(bs.th, th);
}

MoveBase::Inactive{
  // BaseState(start) == Holds(x, y, th);
  any(BaseState.Holds bs);
  precedes(bs.start, start);
  temporalDistance(start, [1 +inf], bs.end);
  eq(bs.x, x);
  eq(bs.y, y);
  eq(bs.th, th);
}

float MAX_CAPACITY; // Maximum energy capacity of all batteries
float NOMINAL_POWER_CONSUMPTION; // When not plugged in.
float PLUGGED_IN_POWER_CONSUMPTION; // When plugged in, it should draw this amount

/**
 * Behavior will be started and executed perfectly
 */
RechargeController::Active{
  // Forces a fixed duration.
  eq(duration, 1);

  // Batteries are magically charged at the end
  meets(Inactive s);
  eq(s.x, x);
  eq(s.y, y);
  eq(s.th, th);
  eq(s.recharge_level, recharge_level);

  // Fix the battery state at the end
  ends(BatteryState.Holds bs);
  float estEnergy, estCapacity, estConsumption;
  mulEq(recharge_level, MAX_CAPACITY, estEnergy);
  eq(estCapacity, MAX_CAPACITY);
  eq(estConsumption, NOMINAL_POWER_CONSUMPTION);

  defaultOnCommit(bs.energy_remaining, estEnergy);
  defaultOnCommit(bs.energy_capacity, estCapacity);
  defaultOnCommit(bs.power_consumption, estConsumption);
}

/**
 * By default it will retain prior values
 */
BatteryState::Holds{
  met_by(Holds p);
  defaultOnCommit(energy_remaining, p.energy_remaining);
  defaultOnCommit(energy_capacity, p.energy_capacity);
  defaultOnCommit(power_consumption, p.power_consumption);
  //eq(duration, 1);
}

ShellCommand::Active{
  eq(duration, 1);
}

// Internal Controllers
//BaseController base_controller = new BaseController();

// State Variables
BaseState base_state = new BaseState(Internal);
BatteryState battery_state = new BatteryState(Internal);

// Behaviors
MoveBase move_base = new MoveBase(Internal);
RechargeController recharge_controller = new RechargeController(Internal);
ShellCommand shell_command = new ShellCommand(Internal);
