#include "rcs/safety/exports.nddl"
#include "rcs/doors/exports.nddl"
#include "rcs/plugs/exports.nddl"

/**
 * A simulation control variable governing when the doorway will be clear.
 */
class DoorwayClearSV extends AgentTimeline {

  predicate Holds{ 
    bool value;
  }

  DoorwayClearSV(){ super(Internal, "Holds");}
};

ReleaseHandle release_handle = new ReleaseHandle(Internal);
OpenDoor open_door = new OpenDoor(Internal);
TouchDoor touch_door = new TouchDoor(Internal);
PushDoor push_door = new PushDoor(Internal);
GraspHandle grasp_handle = new GraspHandle(Internal);
UnlatchHandle unlatch_handle = new UnlatchHandle(Internal);
DetectDoor detect_door = new DetectDoor(Internal);
DetectHandle detect_handle = new DetectHandle(Internal);
CheckPath check_path = new CheckPath(Internal);
NotifyDoorBlocked notify_door_blocked = new NotifyDoorBlocked(Internal);
MoveBase move_base_local = new MoveBase(Internal);
MoveBaseDoor move_base_door = new MoveBaseDoor(Internal);
StopAction stop_action = new StopAction(Internal);

// Simulation Control Variables
DoorwayClearSV doorway_clear_sv = new DoorwayClearSV();

DoorwayClearSV::Holds{  default(value, true); }

/**
 * A simulation control variable governing when the doorway will be unlocked
 */
class DoorwayLockedSV extends AgentTimeline {

  predicate Holds{ 
    bool value;
  }

  DoorwayLockedSV(){ super(Internal, "Holds");}
};


DoorwayLockedSV::Holds{  default(value, false); }

/**
 * For now, assume a fixed duration, and always return success.
 */

DoorManipulationBehavior::Active{
  eq(duration, 1);

  // Handle always free at the end
  meets(Inactive s);
  eq(s.status, SUCCESS);
}

MoveBase::Active{
  eq(duration, 1);
  meets(Inactive s);
  eq(s.status, SUCCESS);
}

CheckPath::Active {
  eq(duration, 1);
  meets(Inactive s);
  eq(s.status, SUCCESS);
}

UnlatchHandle::Inactive{
  if(status == SUCCESS){
    eq(latch_state, LATCH_STATE_UNLATCHED);
  }
}
/**
 * Update result parameters according to simulation control variables.
 */
CheckPath::Inactive{
  starts_during(DoorwayClearSV.Holds dc);
  eq(is_clear, dc.value);
}

StopAction::Active{
  eq(duration, 5);
  meets(Inactive s);
  eq(s.status, SUCCESS);
}


