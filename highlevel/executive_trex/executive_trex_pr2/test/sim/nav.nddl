float XY_ERROR = 0.1;
float THETA_ERROR = 0.1;
typedef float [-1.0 1.0] LINEAR_VELOCITY;
typedef float [-3.0 3.0] ANGULAR_VELOCITY;

/**
 * A Base Controller.
 * MoveBase should impose a goal for x, y and theta.
 * A controller should be activated to pursue these values. It can have a velocity and acceleration model. 
 * Should be able to select a velocity value within bounds.
 * If we are stuck, the velocity is constrained to 0.
 * Should be able to select the abort value.
 * Should be able to set the preempted value.
 * Cases where we want to force it to transition all the time are when we have a variable to crash.
 * Stochastically select aborted and preempted flags for the deactivation state.
 */
class BaseController extends AgentTimeline {

  // Single predicate structure for all values.
  predicate Holds{

    // Target values when active
    float x;
    float y;
    float th;

    // Deltas to be used to update successor state, if not already set
    float dx;
    float dy;
    float dth;

    // Control flags
    bool active;
    bool abort;
    bool preempt;
  }

  BaseController(){super(Internal, "Holds", false);}
};

/**
 * This is the core implementation for a base controller. It is a stub for moving the base. Desirable short hand shown below.
 *
 * default active = false;
 * default abort = false;
 * default preempt = false;
 *
 * if(active && !abort && !preempt){
 *   duration = 1;
 *
 *   // Apply updates to generate new base state
 *   met_by(BaseState.Holds prior);
 *   equals(BaseState.Holds current);
 *   current.x = prior.x  + p.dx;
 *   current.y = prior.y  + p.dy;
 *   current.th= prior.th + p.dth;
 *   
 *   on commit {
 *      dx = absMax(intersection(x - current.x, [-1.0, 1.0]);
 *      dy = absMax(intersection(y - current.y, [-1.0, 1.0]);
 *      dth= absMax(intersection(th- current.th,[-3.0, 3.0]);
 *
 *      if (abs(dx) >= XY_ERROR || abs(dy) >= XY_ERROR || abs(dth) > THETA_ERROR)
 *        s.active = true;
 *   }
 *
 * }
 * else {
 *   dx = 0;
 *   dy = 0;
 *   dth= 0;
 *   contained_by(MoveBase.Inactive);
 * }
 */
BaseController::Holds{
  // These control variables can be defaulted based on a random selection if we wish to create spurios behaviors.
  default(active, false);
  default(abort, false);
  default(preempt, false);

  // If it is active, compute control parameters
  if(active == true){
    if(abort == false){
      if(preempt == false){
	met_by(Holds p);
	meets(Holds s);
	eq(duration, 1);

	// Bind to prior x, y and th values for base state
	met_by(BaseState.Holds prior);
	equals(BaseState.Holds current);

	// Bind to predecessor to obtain prefered deltas
	addEq(prior.x, p.dx, current.x);
	addEq(prior.y, p.dy, current.y);
	addEq(prior.th, p.dth, current.th);

	// Bind successor x, y, th values
	eq(s.x, x);
	eq(s.y, y);
	eq(s.th, th);

	// Bounds on dx, dy, and dth are derived by analyzing the gap
	float ub_dx, ub_dy, ub_dth;
	addEq(current.x, ub_dx, x);
	addEq(current.y, ub_dy, y);
	addEq(current.th, ub_dth, th);

	// Bind defaults based on linear velocity constraints. These kick in on commit. This pattern allows us to later
	// apply other methods for binding values that supersede the estimate computed by physics model
	LINEAR_VELOCITY estDX;
	LINEAR_VELOCITY estDY;
	LINEAR_VELOCITY estDTH;
	defaultOnCommit(estDX, ub_dx);
	defaultOnCommit(estDY, ub_dy);
	defaultOnCommit(estDTH, ub_dth);

	if(estDX){
	  defaultOnCommit(dx, estDX);
	}

	if(estDY){
	  defaultOnCommit(dy, estDY);
	}

	if(estDTH){
	  defaultOnCommit(dth, estDTH);
	}

	// if (abs(dx) >= XY_ERROR || abs(dy) >= XY_ERROR || abs(dth) > THETA_ERROR) then successor is active.
	// Otherwise, terminate the parent.
	// Implement an OR using an leq constraint. Yuck
	float abs_dx, abs_dy, abs_dth;
	bool test_dx, test_dy, test_dth;
	absVal(abs_dx, dx);
	testLEQ(test_dx, XY_ERROR, abs_dx);
	leq(test_dx, s.active);
	absVal(abs_dy, dy);
	testLEQ(test_dy, XY_ERROR, abs_dy);
	leq(test_dy, s.active);
	absVal(abs_dth, dth);
	testLEQ(test_dth, THETA_ERROR, abs_dth);
	leq(test_dth, s.active);
      }
    }
  }

  // When it has transitioned to inactive, transition the parent
  if(active == false){
    eq(dx, 0.0);
    eq(dy, 0.0);
    eq(dth, 0.0);

    contained_by(MoveBase.Inactive);
  }
}


/**
 * By default it will retain prior values. We will constrain its duration to 1.
 *
 * duration = 1;
 *
 * on commit {
 *  default x = previous.x;
 *  default y = previous.y;
 *  default th= previous.th;
 * }
 */
BaseState::Holds{
  met_by(Holds p);
  defaultOnCommit(x, p.x);
  defaultOnCommit(y, p.y);
  defaultOnCommit(th,p.th);
  //eq(duration, 1);
}

/**
 * Behavior will be started and execute perfectly.
 */
MoveBase::Active{
  // Activate base controller with goals
  starts(BaseController.Holds bc);
  eq(bc.active, true);
  eq(bc.x, x);
  eq(bc.y, y);
  eq(bc.th, th);

  // For now, assume a constant duration, and write the end bounds thru magic so we are transported
  // to the target position instantaneouosly
  eq(duration, 3);
  meets(BaseState.Holds bs);
  eq(bs.x, x);
  eq(bs.y, y);
  eq(bs.th, th);
}

MoveBase::Inactive{
  // BaseState(start) == Holds(x, y, th);
  any(BaseState.Holds bs);
  precedes(bs.start, start);
  temporalDistance(start, [1 +inf], bs.end);
  eq(bs.x, x);
  eq(bs.y, y);
  eq(bs.th, th);
}

BaseController base_controller = new BaseController();
BaseState base_state = new BaseState(Internal);
MoveBase move_base = new MoveBase(Internal);