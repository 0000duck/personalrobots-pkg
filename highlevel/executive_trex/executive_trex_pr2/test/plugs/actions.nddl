/**
 * Actions used to support testing. These actions utilize an explict specification of
 * a plan to decompose an action into its parts. This is mainly used for testing the indivudual
 * actions as directly as possible.
 */
class PlugActions extends AgentActions {

  /**
   * Super simple - tuck, untuck, detect, tuck
   */
  predicate DetectPlug{}

  /**
   * Will execute actions as far as grapping the plug, and staging it, and then putting it back
   */
  predicate PickupAndRelease{}
};

PlugActions::DetectPlug {
  contains(safety_tuck_arms.Active cmd_tuck_arms);
  contains(plugs_untuck_arms.Active cmd_untuck_arms);
  contains(detect_plug_on_base.Active cmd_detect_plug_on_base);
  contains(detect_outlet_coarse.Active cmd_detect_outlet_coarse);
  contains(detect_outlet_fine.Active cmd_detect_outlet_fine);
  contains(safety_tuck_arms.Active cmd_tuck_arms_again);

  cmd_tuck_arms before cmd_untuck_arms;
  cmd_untuck_arms before cmd_detect_plug_on_base;
  cmd_detect_plug_on_base before cmd_detect_outlet_coarse;
  cmd_detect_outlet_coarse before cmd_detect_outlet_fine;
  cmd_detect_outlet_fine before cmd_tuck_arms_again;

  concurrent(end, cmd_tuck_arms_again.end);
}

PlugActions::PickupAndRelease {
  // Subgoal all the actions. It would be nice if they were sequenced in declaration
  // These are variable declarations, in the form of contains(${X}.active cmd_${X})
  // where X is a variable declared in plugs/imports.nddl.
  contains(safety_tuck_arms.Active cmd_tuck_arms);
  contains(plugs_untuck_arms.Active cmd_untuck_arms);
  contains(detect_plug_on_base.Active cmd_detect_plug_on_base);
  contains(move_and_grasp_plug.Active cmd_move_and_grasp_plug);
  contains(detect_outlet_fine.Active cmd_detect_outlet_fine);
  contains(stow_plug.Active cmd_stow_plug);

  // Sequence them
  cmd_tuck_arms before cmd_untuck_arms;
  cmd_untuck_arms before cmd_detect_plug_on_base;
  cmd_detect_plug_on_base before cmd_move_and_grasp_plug;
  cmd_move_and_grasp_plug before cmd_detect_outlet_fine;
  cmd_detect_outlet_fine before cmd_stow_plug;

  // Constrain all to be successful
  eq(SUCCESS,
     cmd_tuck_arms.status,
     cmd_untuck_arms.status,
     cmd_detect_plug_on_base.status,
     cmd_move_and_grasp_plug.status,
     cmd_stow_plug.status,
     cmd_detect_outlet_fine.status);

  // Bind parameters. Should be nice to say:
  // DetectPlugOnBase.Inactive feedback == detect_plug_on_base[cmd_detect_plug_on_base.end);
  // cmd_stow_plug.plug_state == feedback.plug_state
  contains(detect_plug_on_base.Inactive feedback_detect_plug_on_base);
  cmd_detect_plug_on_base meets feedback_detect_plug_on_base;

  // Provides input to grasp
  eq(cmd_move_and_grasp_plug.time_stamp, feedback_detect_plug_on_base.time_stamp);
  eq(cmd_move_and_grasp_plug.frame_id, feedback_detect_plug_on_base.frame_id);
  eq(cmd_move_and_grasp_plug.stowed, feedback_detect_plug_on_base.stowed);
  eq(cmd_move_and_grasp_plug.x, feedback_detect_plug_on_base.x);
  eq(cmd_move_and_grasp_plug.y, feedback_detect_plug_on_base.y);
  eq(cmd_move_and_grasp_plug.z, feedback_detect_plug_on_base.z);

  // Use a bogus point
  eq(cmd_detect_outlet_fine.time_stamp, feedback_detect_plug_on_base.time_stamp);
  eq(cmd_detect_outlet_fine.frame_id, "torso_lift_link");
  eq(cmd_detect_outlet_fine.x, 0.0);
  eq(cmd_detect_outlet_fine.y, 0.0);
  eq(cmd_detect_outlet_fine.z, 0.0);

  // Stow it back where we got it
  eq(cmd_stow_plug.time_stamp, feedback_detect_plug_on_base.time_stamp);
  eq(cmd_stow_plug.frame_id, feedback_detect_plug_on_base.frame_id);
  eq(cmd_stow_plug.stowed, feedback_detect_plug_on_base.stowed);
  eq(cmd_stow_plug.x, feedback_detect_plug_on_base.x);
  eq(cmd_stow_plug.y, feedback_detect_plug_on_base.y);
  eq(cmd_stow_plug.z, feedback_detect_plug_on_base.z);

  // End the action when the last command finishes
  concurrent(end, cmd_stow_plug.end);
/*
  contains(localize_plug_in_gripper.Active cmd_localize_plug_in_gripper);
  contains(stow_plug.Active cmd_stow_plug);
  contains(servo_to_outlet.Active cmd_servo_to_outlet);
  contains(insert_plug.Active cmd_insert_plug);
  contains(push_plug_in.Active cmd_push_plug_in);
  contains(unplug.Active cmd_unplug);
  contains(detect_plug_on_base.Active cmd_detect_plug_on_base_to_confirm);
  contains(safety_tuck_arms.Active cmd_tuck_arms_again);
*/

/*
  cmd_move_and_grasp_plug before cmd_localize_plug_in_gripper;
  cmd_localize_plug_in_gripper before cmd_stow_plug;
  cmd_stow_plug before cmd_servo_to_outlet;
  cmd_servo_to_outlet before cmd_insert_plug;
  cmd_insert_plug before cmd_push_plug_in;
  cmd_push_plug_in before cmd_unplug;
  cmd_unplug before cmd_detect_plug_on_base_to_confirm;
  cmd_detect_plug_on_base_to_confirm before cmd_tuck_arms_again;

  // require that the all execute successfully
  eq(SUCCESS,
     cmd_tuck_arms.status,
     cmd_untuck_arms.status,
     cmd_detect_plug_on_base.status,
     cmd_move_and_grasp_plug.status,
     cmd_localize_plug_in_gripper.status,
     cmd_stow_plug.status,
     cmd_insert_plug.status,
     cmd_push_plug_in.status,
     cmd_unplug.status,
     cmd_detect_plug_on_base_to_confirm.status,
     cmd_tuck_arms_again.status);
*/


/*
  // Provides input to stow
  get_state(cmd_stow_plug.object, feedback_detect_plug_on_base.object);

  // Finally, the action ends when the tuck arms finishes
  concurrent(end, cmd_tuck_arms_again.end);
*/
}

PlugActions plug_actions = new PlugActions();
