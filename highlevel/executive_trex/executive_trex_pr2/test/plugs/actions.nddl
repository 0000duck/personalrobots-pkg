/**
 * Actions used to support testing. These actions utilize an explict specification of
 * a plan to decompose an action into its parts. This is mainly used for testing the indivudual
 * actions as directly as possible.
 */
class PlugActions extends AgentActions {

  /**
   * Super simple - tuck, untuck, detect, tuck
   */
  predicate DetectPlug{}

  /**
   * Will execute actions as far as grapping the plug, and staging it, and then putting it back
   */
  predicate PickupAndRelease{}
};

PlugActions::DetectPlug {
  contains(safety_tuck_arms.Active cmd_tuck_arms);
  contains(plugs_untuck_arms.Active cmd_untuck_arms);
  contains(detect_plug_on_base.Active cmd_detect_plug_on_base);
  contains(detect_outlet_coarse.Active cmd_detect_outlet_coarse);
  contains(detect_outlet_fine.Active cmd_detect_outlet_fine);
  contains(safety_tuck_arms.Active cmd_tuck_arms_again);

  cmd_tuck_arms before cmd_untuck_arms;
  cmd_untuck_arms before cmd_detect_plug_on_base;
  cmd_detect_plug_on_base before cmd_detect_outlet_coarse;
  cmd_detect_outlet_coarse before cmd_detect_outlet_fine;
  cmd_detect_outlet_fine before cmd_tuck_arms_again;

  concurrent(end, cmd_tuck_arms_again.end);
}

PlugActions::PickupAndRelease {
  // Subgoal all the actions. It would be nice if they were sequenced in declaration
  // These are variable declarations, in the form of contains(${X}.active cmd_${X})
  // where X is a variable declared in plugs/imports.nddl.
  contains(safety_tuck_arms.Active cmd_tuck_arms);
  contains(plugs_untuck_arms.Active cmd_untuck_arms);
  contains(detect_plug_on_base.Active cmd_detect_plug_on_base);
  contains(move_and_grasp_plug.Active cmd_move_and_grasp_plug);
  contains(detect_outlet_fine.Active cmd_detect_outlet_fine);
  contains(stow_plug.Active cmd_stow_plug);

  // Sequence them
  cmd_tuck_arms before cmd_untuck_arms;
  cmd_untuck_arms before cmd_detect_plug_on_base;
  cmd_detect_plug_on_base before cmd_move_and_grasp_plug;
  cmd_move_and_grasp_plug before cmd_detect_outlet_fine;
  cmd_detect_outlet_fine before cmd_stow_plug;

  // Constrain all to be successful
  eq(SUCCESS,
     cmd_tuck_arms.status,
     cmd_untuck_arms.status,
     cmd_detect_plug_on_base.status,
     cmd_move_and_grasp_plug.status,
     cmd_stow_plug.status,
     cmd_detect_outlet_fine.status);

  // Bind parameters. Should be nice to say:
  // DetectPlugOnBase.Inactive feedback == detect_plug_on_base[cmd_detect_plug_on_base.end);
  // cmd_stow_plug.plug_state == feedback.plug_state
  contains(detect_plug_on_base.Inactive feedback_detect_plug_on_base);
  cmd_detect_plug_on_base meets feedback_detect_plug_on_base;

  // Provides input to grasp
  eq_plug_stow_msg(cmd_move_and_grasp_plug.object, feedback_detect_plug_on_base.object);

  // Use a bogus point. Do we even need a point
  eq(cmd_detect_outlet_fine.time_stamp, feedback_detect_plug_on_base.time_stamp);
  eq(cmd_detect_outlet_fine.frame_id, "torso_lift_link");
  eq(cmd_detect_outlet_fine.x, 0.0);
  eq(cmd_detect_outlet_fine.y, 0.0);
  eq(cmd_detect_outlet_fine.z, 0.0);

  // Stow it back where we got it
  eq_plug_stow_msg(cmd_stow_plug.object, feedback_detect_plug_on_base.object);

  // End the action when the last command finishes
  concurrent(end, cmd_stow_plug.end);
}

PlugActions plug_actions = new PlugActions();
