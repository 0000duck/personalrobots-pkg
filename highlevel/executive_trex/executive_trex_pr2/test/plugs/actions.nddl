/**
 * Actions used to support testing. These actions utilize an explict specification of
 * a plan to decompose an action into its parts. This is mainly used for testing the indivudual
 * actions as directly as possible.
 */
class PlugActions extends AgentActions {

  /**
   * Super simple - detect outlet and move to position based on feedback
   */
  predicate DetectOutlet{}

  /**
   * Will execute actions as far as grapping the plug, and staging it, and then putting it back
   */
  predicate PickupAndRelease{}
};

PlugActions::DetectOutlet {

  // Subgoals
  contains(detect_outlet_coarse.Active cmd_detect_outlet_coarse);
  contains(move_base_local.Active cmd_move_to_outlet);

  // Sequence
  cmd_detect_outlet_coarse before cmd_move_to_outlet;
  
  // They all succeed
  eq(SUCCESS, cmd_detect_outlet_coarse.status, cmd_move_to_outlet.status);

  // Params

  // Initial values in the base_footprint frame. Used to point the head
  eq(cmd_detect_outlet_coarse.frame_id, "base_footprint");
  eq(cmd_detect_outlet_coarse.x, 3.0);
  eq(cmd_detect_outlet_coarse.y, 0.0);
  eq(cmd_detect_outlet_coarse.z, 0.5);

  // Use detect outlet feedback to determine where to move base
  any(detect_outlet_coarse.Inactive feedback_detect_outlet_coarse);
  cmd_detect_outlet_coarse meets feedback_detect_outlet_coarse;
  plugs_get_offset_pose(feedback_detect_outlet_coarse.x, feedback_detect_outlet_coarse.y, 
                        feedback_detect_outlet_coarse.z, feedback_detect_outlet_coarse.qx, 
                        feedback_detect_outlet_coarse.qy, feedback_detect_outlet_coarse.qz,
                        feedback_detect_outlet_coarse.qw, 0.6, cmd_move_to_outlet.x, cmd_move_to_outlet.y,
                        cmd_move_to_outlet.z, cmd_move_to_outlet.qx, cmd_move_to_outlet.qy,
                        cmd_move_to_outlet.qz, cmd_move_to_outlet.qw);
  eq(cmd_move_to_outlet.frame_id, feedback_detect_outlet_coarse.frame_id);
  concurrent(end, cmd_move_to_outlet.end);
}

PlugActions::PickupAndRelease {
  // Subgoal all the actions. It would be nice if they were sequenced in declaration
  // These are variable declarations, in the form of contains(${X}.active cmd_${X})
  // where X is a variable declared in plugs/imports.nddl.
  contains(safety_tuck_arms.Active cmd_tuck_arms);
  contains(plugs_untuck_arms.Active cmd_untuck_arms);
  contains(detect_plug_on_base.Active cmd_detect_plug_on_base);
  contains(move_and_grasp_plug.Active cmd_move_and_grasp_plug);
  contains(detect_outlet_fine.Active cmd_detect_outlet_fine);
  contains(localize_plug_in_gripper.Active cmd_localize_plug_in_gripper);
  contains(plug_in.Active cmd_plug_in);
  contains(unplug.Active cmd_unplug);
  contains(stow_plug.Active cmd_stow_plug);

  // Sequence them
  cmd_tuck_arms before cmd_untuck_arms;
  cmd_untuck_arms before cmd_detect_plug_on_base;
  cmd_detect_plug_on_base before cmd_move_and_grasp_plug;
  cmd_move_and_grasp_plug before cmd_detect_outlet_fine;
  cmd_detect_outlet_fine before cmd_localize_plug_in_gripper;
  cmd_localize_plug_in_gripper before cmd_plug_in;
  cmd_plug_in before cmd_unplug;
  cmd_unplug before cmd_stow_plug;

  // Constrain all to be successful
  eq(SUCCESS,
     cmd_tuck_arms.status,
     cmd_untuck_arms.status,
     cmd_detect_plug_on_base.status,
     cmd_move_and_grasp_plug.status,
     cmd_detect_outlet_fine.status,
     cmd_localize_plug_in_gripper.status,
     cmd_plug_in.status,
     cmd_unplug.status,
     cmd_stow_plug.status);

  // Bind parameters. Should be nice to say:
  // DetectPlugOnBase.Inactive feedback == detect_plug_on_base[cmd_detect_plug_on_base.end);
  // cmd_stow_plug.plug_state == feedback.plug_state
  any(detect_plug_on_base.Inactive feedback_detect_plug_on_base);
  cmd_detect_plug_on_base meets feedback_detect_plug_on_base;

  // Provides input to grasp
  eq_plug_stow_msg(cmd_move_and_grasp_plug.object, feedback_detect_plug_on_base.object);

  // Use a bogus point. Do we even need a point
  //eq(cmd_detect_outlet_fine.time_stamp, feedback_detect_plug_on_base.time_stamp);
  eq(cmd_detect_outlet_fine.frame_id, "torso_lift_link");
  eq(cmd_detect_outlet_fine.x, 0.0);
  eq(cmd_detect_outlet_fine.y, 0.0);
  eq(cmd_detect_outlet_fine.z, 0.0);

  // Feedback from outlet detction used to target plug localization in the gripper
  any(detect_outlet_fine.Inactive feedback_detect_outlet_fine);
  cmd_detect_outlet_fine meets feedback_detect_outlet_fine;
  eq_pose_msg(feedback_detect_outlet_fine.object, cmd_localize_plug_in_gripper.object);

  // Stow it back where we got it
  eq_plug_stow_msg(cmd_stow_plug.object, feedback_detect_plug_on_base.object);

  // End the action when the last command finishes
  concurrent(end, cmd_stow_plug.end);
}

PlugActions plug_actions = new PlugActions();
