/**
 * @author Conor McGann
 * @brief Declares and Defines actions for testing the door domain at a pretty low level
 * @requires world_model
 */
class DoorActions extends AgentActions{

  /**
   * @brief A script to open the door, with no branching
   * @param DoorState a door message
   */
  predicate OpenDoor{
    MAP_KEY door_id;
  }
};

DoorActions::OpenDoor{
  // Verify it is a valid id
  neq(door_id, NO_KEY);

  // Here is the basic sequence. Could use a notation here that generated actions in order or something
  // to make such sequences eeasier to specify. There is alot of work in ANML that could apply here
  contained_by(MoveBase.Active cmd_move_to_detect);
  contained_by(DetectDoor.Active cmd_detect_door);
  contained_by(MoveBase.Active cmd_go_to_grasp_position);
  contained_by(GraspHandle.Active cmd_grasp_handle);
  contained_by(OpenDoorWithGrasp.Active cmd_open_door);

  // Impose ordering constraints
  cmd_move_to_detect before cmd_detect_door;
  cmd_detect_door before cmd_go_to_grasp_position;
  cmd_go_to_grasp_position before cmd_grasp_handle;
  cmd_grasp_handle before cmd_open_door;

  // Bind parameters. The code below constructs relations to propagate information

  // Get door data from the world model. This initial data is used to guide the door detector
  map_get_door_state(cmd_detect_door.state, door_id);

  // Obtain the detection base location based on the door data from this initial state value
  get_door_detection_base_position(cmd_move_to_detect.x, cmd_move_to_detect.y, cmd_move_to_detect.th,
				   cmd_detect_door.door_p1_x, cmd_detect_door.door_p1_y, cmd_detect_door.door_p2_x, cmd_detect_door.door_p2_y);

  // Bindings below are conditional because the world model will be evolving as underlying actions execute. The guard will not evaluate
  // until they have ended. Door State updates will flow from one action to another
  if(cmd_detect_door.end){ map_get_door_state(cmd_grasp_handle.state, door_id); }
  if(cmd_grasp_handle.end){ map_get_door_state(cmd_open_door.state, door_id); }
 
  // The base position for grasping is a function of the door state after we have detected the door, and thus the bound value in the door detection action
  get_door_grasp_base_position(cmd_go_to_grasp_position.x, cmd_go_to_grasp_position.y, cmd_go_to_grasp_position.th,
			       cmd_grasp_handle.door_p1_x, cmd_grasp_handle.door_p1_y, cmd_grasp_handle.door_p2_x, cmd_grasp_handle.door_p2_y);

  /*
  // Sequence the goals
  cmd_go_to_detection_position before cmd_detect_door;
  cmd_detect_door before cmd_go_to_grasp_position;
  cmd_go_to_grasp_position before cmd_grasp_handle;
  cmd_grasp_handle before cmd_open_door;
  */

}
