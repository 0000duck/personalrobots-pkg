/**
 * Execute a test of external actions in sequence
 */
#include "doors/imports.nddl"
#include "mechanism_control/exports.nddl"

close();

// The goal is to execute an OpenDoor action, where we give it the door data
rejectable(doors_tuck_arms.Active cmd_tuck_arms);
rejectable(detect_door.Active cmd_detect_door);
rejectable(detect_door.Inactive feedback_detect_door);
rejectable(detect_handle.Active cmd_detect_handle);
rejectable(detect_handle.Inactive feedback_detect_handle);
rejectable(move_base_local.Active cmd_move_to_grasp);
rejectable(grasp_handle.Active cmd_grasp_handle);
rejectable(unlatch_handle.Active cmd_unlatch_handle);
rejectable(open_door.Active cmd_open_door);
rejectable(move_base_door.Active cmd_move_base_door);
rejectable(release_handle.Active cmd_release_handle);

// Impose a temporal order
cmd_tuck_arms before cmd_detect_door;
cmd_detect_door meets feedback_detect_door;
cmd_detect_door before cmd_detect_handle;
cmd_detect_handle meets feedback_detect_handle;
cmd_detect_handle before cmd_move_to_grasp;
cmd_move_to_grasp before cmd_grasp_handle;
cmd_grasp_handle before cmd_unlatch_handle;
cmd_unlatch_handle before cmd_open_door;

// Final phase involves parallel activities, finishing up with releasing the handle
cmd_open_door starts_before cmd_move_base_door;
temporalDistance(cmd_move_base_door.end, [0, 1], cmd_open_door.end);
cmd_open_door before cmd_release_handle;

// All must succeed
eq(SUCCESS,
   cmd_tuck_arms.status,
   cmd_detect_door.status,
   cmd_detect_handle.status,
   cmd_move_to_grasp.status,
   cmd_grasp_handle.status,
   cmd_unlatch_handle.status,
   cmd_open_door.status,
   cmd_move_base_door.status,
   cmd_release_handle.status);

// Input is for door detection.
cmd_detect_door.frame_id = "base_footprint";
cmd_detect_door.frame_p1_x =  1.5;
cmd_detect_door.frame_p1_y = -0.5;
cmd_detect_door.frame_p1_z =  1.0;
cmd_detect_door.frame_p2_x =  1.5;
cmd_detect_door.frame_p2_y =  0.5;
cmd_detect_door.frame_p2_z =  1.0;
cmd_detect_door.door_p1_x =  1.5;
cmd_detect_door.door_p1_y = -0.5;
cmd_detect_door.door_p1_z =  1.0;
cmd_detect_door.door_p2_x =  1.5;
cmd_detect_door.door_p2_y =  0.5;
cmd_detect_door.door_p2_z =  1.0;
cmd_detect_door.handle_x =  1.5;
cmd_detect_door.handle_y =  0.5;
cmd_detect_door.handle_z =  1.0;
cmd_detect_door.height =  2.5;
cmd_detect_door.hinge =  UNKNOWN;
cmd_detect_door.rot_dir =  UNKNOWN;

eq_door_msg(cmd_detect_handle.object, feedback_detect_door.object);

// Set params for move base local
eq(cmd_move_to_grasp.frame_id, feedback_detect_handle.frame_id);
eq(cmd_move_to_grasp.time_stamp, feedback_detect_handle.time_stamp);
door_get_robot_pose_for_door(cmd_move_to_grasp.x, cmd_move_to_grasp.y, cmd_move_to_grasp.z,
			     cmd_move_to_grasp.qx, cmd_move_to_grasp.qy, cmd_move_to_grasp.qz, cmd_move_to_grasp.qw,
			     feedback_detect_handle.object,
			     GRASP_RANGE);

// The parameters for the final move base command can be derived from the door message, This time we will use a negative value
// to indicate how far across the frame we want to be.
float TRANSLATION_FROM_DOOR_FRAME = -1.0;
eq(cmd_move_base_door.frame_id, feedback_detect_handle.frame_id);
eq(cmd_move_base_door.time_stamp, feedback_detect_handle.time_stamp);
door_get_robot_pose_for_door(cmd_move_base_door.x, cmd_move_base_door.y, cmd_move_base_door.z,
			     cmd_move_base_door.qx, cmd_move_base_door.qy, cmd_move_base_door.qz, cmd_move_base_door.qw,
			     feedback_detect_handle.object,
			     TRANSLATION_FROM_DOOR_FRAME);

// Set params from handle detection feedback.
eq_door_msg(cmd_grasp_handle.object, feedback_detect_handle.object);
eq_door_msg(cmd_unlatch_handle.object, feedback_detect_handle.object);
eq_door_msg(cmd_open_door.object, feedback_detect_handle.object);
