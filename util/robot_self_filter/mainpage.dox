/**
\mainpage
\htmlinclude manifest.html

\b robot_self_filter can either remove points from a pointcloud that
are on the robot (parts the robot can see of itself) or it can
annotate the points by adding a channel with a name of choice that
will have values of 1.0 (point is outside the robot) or -1.0 (point is
on the robot)



<!-- 
In addition to providing an overview of your package,
this is the section where the specification and design/architecture 
should be detailed. While the original specification may be done on the
wiki, it should be transferred here once your package starts to take shape.
You can then link to this documentation page from the Wiki. 
-->


<!-- \section codeapi Code API
-->

<!--
Provide links to specific auto-generated API documentation within your
package that is of particular interest to a reader. Doxygen will
document pretty much every part of your code, so do your best here to
point the reader to the actual API.

If your codebase is fairly large or has different sets of APIs, you
should use the doxygen 'group' tag to keep these APIs together. For
example, the roscpp documentation has 'libros' group.
-->

\section rosapi ROS API

<!--
Names are very important in ROS because they can be remapped on the
command-line, so it is VERY IMPORTANT THAT YOU LIST NAMES AS THEY
APPEAR IN THE CODE. You should list names of every topic, service and
parameter used in your code. There is a template below that you can
use to document each node separately.
-->

List of nodes:
- \b self_filter
- \b test_filter

<!-- START: copy from here to 'END' for each node 

<hr>

\subsection self_filter self_filter

self_filter listents to a pointcloud on the 'cloud_in' topic and
broadcasts a pointcloud on 'cloud_out' topic.  There are two modes of
using this node: it can either remove points that are on the robot
from the input cloud and only broadcast the rest, or it can annotate
the points with another channel with a name of choice. 


\subsubsection Usage
\verbatim
$ self_filter [standard ROS params]
\endverbatim

\par Example

\verbatim
$ self_filter robot_description:=robotdesc/pr2 cloud_in:=tilt_cloud cloud_out:=tilt_cloud_filtered
\endverbatim


\subsubsection topics ROS topics

Subscribes to:
- \b "cloud_in": [robot_msgs/PointCloud] 

Publishes to:
- \b "cloud_out": [robot_msgs/PointCloud] 


\subsubsection parameters ROS parameters

Reads the following parameters from the parameter server

- \b "~annotate" : \b [string] if specified, this channel name will be added to the input pointcloud
and no points will be removed. The values of this channel will be only -1.0 (point on robot) and 1.0
(point outside)

- \b "~robot_description" : \b [string] the URDF description of the robot



\subsection test_filter test_filter

test_filter randomly generates points around & inside the robot and
uses the filter to only keep the ones inside or the ones outside. The
kept set is then sent as a visualization messages to rviz. This
provides a simpl means to test the filter.

\subsubsection Usage
\verbatim
$ test_filter [standard ROS params]
\endverbatim

\par Example

\verbatim
$ test_filter robot_description:=robotdesc/pr2
\endverbatim

\subsubsection parameters ROS parameters

Reads the following parameters from the parameter server

- \b "~robot_description" : \b [string] the URDF description of the robot

*/
