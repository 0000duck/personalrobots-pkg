Index: tests/kinfamtest.cpp
===================================================================
--- tests/kinfamtest.cpp	(revision 30213)
+++ tests/kinfamtest.cpp	(working copy)
@@ -1,6 +1,7 @@
 #include "kinfamtest.hpp"
 #include <frames_io.hpp>
 #include <kinfam_io.hpp>
+#include <chainfksolverpos_recursive.hpp>
 
 CPPUNIT_TEST_SUITE_REGISTRATION( KinFamTest );
 
@@ -199,6 +200,24 @@
     CPPUNIT_ASSERT(tree1.addTree(tree2,"Tree2","Segment2"));
     cout<<tree1<<endl;
 
+    Chain extract_chain1 = tree1.getChain("Segment2", "Segment4");
+    Chain extract_chain2 = tree1.getChain("Segment4", "Segment2");
+    CPPUNIT_ASSERT(extract_chain1.getNrOfJoints()==extract_chain2.getNrOfJoints());
+    CPPUNIT_ASSERT(extract_chain1.getNrOfSegments()==extract_chain2.getNrOfSegments());
+    ChainFkSolverPos_recursive solver1(extract_chain1);
+    ChainFkSolverPos_recursive solver2(extract_chain2);
+
+
+    Frame f1, f2;
+    JntArray jnt1(extract_chain2.getNrOfJoints());
+    JntArray jnt2(extract_chain2.getNrOfJoints());
+    for (int i=0; i<(int)extract_chain2.getNrOfJoints(); i++){
+      jnt1(i) = (i+1)*2;
+      jnt2((int)extract_chain2.getNrOfJoints()-i-1) = -jnt1(i);
+    }
+    solver1.JntToCart(jnt1, f1);
+    solver2.JntToCart(jnt2, f2);
+    CPPUNIT_ASSERT(f1 == f2.Inverse());
 }
 
 
Index: src/tree.hpp
===================================================================
--- src/tree.hpp	(revision 30213)
+++ src/tree.hpp	(working copy)
@@ -149,6 +149,15 @@
             return segments.find(segment_name);
         };
 
+        /**
+         * Request the chain of the tree between chain_root and chain_tip. The chain_root must be an ancester from chain_tip
+         *
+         * @param chain_root the name of the root segment of the chain
+         * @param chain_tip the name of the tip segment of the chain
+         *
+         * @return the chain form chain_root to chain_tip, copied from the tree
+         */
+        Chain getChain(const std::string& chain_root, const std::string& chain_tip)const;
 
 
         const SegmentMap& getSegments()const
Index: src/joint.cpp
===================================================================
--- src/joint.cpp	(revision 30213)
+++ src/joint.cpp	(working copy)
@@ -154,5 +154,10 @@
       }
   }
 
+  Vector Joint::JointOrigin() const
+  {
+    return origin;
+  }
+
 } // end of namespace KDL
 
Index: src/tree.cpp
===================================================================
--- src/tree.cpp	(revision 30213)
+++ src/tree.cpp	(working copy)
@@ -21,6 +21,7 @@
 
 #include "tree.hpp"
 #include <sstream>
+
 namespace KDL {
 using namespace std;
 
@@ -114,5 +115,53 @@
     return true;
 }
 
+Chain Tree::getChain(const std::string& chain_root, const std::string& chain_tip)const
+{
+  Chain chain;
+
+  // walk down from chain_root and chain_tip to the root of the tree
+  vector<string> parents_chain_root, parents_chain_tip;
+  for (SegmentMap::const_iterator s=getSegment(chain_root); s!=segments.end(); s=s->second.parent){
+    parents_chain_root.push_back(s->first);
+    if (s->first == "root") break;
+  }
+  if (parents_chain_root.empty() || parents_chain_root.back() != "root") return chain;
+  for (SegmentMap::const_iterator s=getSegment(chain_tip); s!=segments.end(); s=s->second.parent){
+    parents_chain_tip.push_back(s->first);
+    if (s->first == "root") break;
+  }
+  if (parents_chain_tip.empty() || parents_chain_tip.back()  != "root") return chain;
+
+  // remove common part of segment lists
+  string last_segment = "root";
+  while (!parents_chain_root.empty() && !parents_chain_tip.empty() &&
+         parents_chain_root.back() == parents_chain_tip.back()){
+    last_segment = parents_chain_root.back();
+    parents_chain_root.pop_back();
+    parents_chain_tip.pop_back();
+  }
+  parents_chain_root.push_back(last_segment);
+
+
+  // add the segments from the root to the common frame
+  for (unsigned int s=0; s<parents_chain_root.size()-1; s++){
+    Segment seg = getSegment(parents_chain_root[s])->second.segment;
+    Frame f_tip = seg.pose(0.0).Inverse();
+    Joint jnt = seg.getJoint();
+    if (jnt.getType() == Joint::RotX || jnt.getType() == Joint::RotY || jnt.getType() == Joint::RotZ || jnt.getType() == Joint::RotAxis)
+      jnt = Joint(f_tip*jnt.JointOrigin(), f_tip.M*jnt.JointAxis(), Joint::RotAxis);
+    else if (jnt.getType() == Joint::TransX || jnt.getType() == Joint::TransY || jnt.getType() == Joint::TransZ || jnt.getType() == Joint::TransAxis)
+      jnt = Joint(f_tip*jnt.JointOrigin(), f_tip.M*jnt.JointAxis(), Joint::TransAxis);
+    chain.addSegment(Segment(jnt, f_tip, getSegment(parents_chain_root[s+1])->second.segment.getInertia()));
+  }
+
+  // add the segments from the common frame to the tip frame
+  for (int s=parents_chain_tip.size()-1; s>-1; s--)
+    chain.addSegment(getSegment(parents_chain_tip[s])->second.segment);
+
+  return chain;
 }
 
+}
+
+
Index: src/joint.hpp
===================================================================
--- src/joint.hpp	(revision 30213)
+++ src/joint.hpp	(working copy)
@@ -102,6 +102,13 @@
          */
         Vector JointAxis() const;
 
+        /**                                                                     
+         * Request the Vector corresponding to the origin of a revolute joint.    
+         *                                                                      
+         * @return Vector
+         */
+        Vector JointOrigin() const;
+
         /**
          * Request the type of the joint.
          *
