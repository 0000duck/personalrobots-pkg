Index: src/tree.hpp
===================================================================
--- src/tree.hpp	(revision 30213)
+++ src/tree.hpp	(working copy)
@@ -149,6 +149,15 @@
             return segments.find(segment_name);
         };
 
+        /**
+         * Request the chain of the tree between chain_root and chain_tip. The chain_root must be an ancester from chain_tip
+         *
+         * @param chain_root the name of the root segment of the chain
+         * @param chain_tip the name of the tip segment of the chain
+         *
+         * @return the chain form chain_root to chain_tip, copied from the tree
+         */
+        Chain getChain(const std::string& chain_root, const std::string& chain_tip)const;
 
 
         const SegmentMap& getSegments()const
Index: src/joint.cpp
===================================================================
--- src/joint.cpp	(revision 30213)
+++ src/joint.cpp	(working copy)
@@ -154,5 +154,10 @@
       }
   }
 
+  Vector Joint::JointOrigin() const
+  {
+    return origin;
+  }
+
 } // end of namespace KDL
 
Index: src/tree.cpp
===================================================================
--- src/tree.cpp	(revision 30213)
+++ src/tree.cpp	(working copy)
@@ -21,6 +21,8 @@
 
 #include "tree.hpp"
 #include <sstream>
+#include <iostream>
+
 namespace KDL {
 using namespace std;
 
@@ -114,5 +116,52 @@
     return true;
 }
 
+Chain Tree::getChain(const std::string& chain_root, const std::string& chain_tip)const
+{
+  Chain chain;
+
+  // walk down from chain_root and chain_tip to the root of the tree
+  vector<string> parents_chain_root, parents_chain_tip;
+  for (SegmentMap::const_iterator s=getSegment(chain_root); s!=segments.end(); s=s->second.parent){
+    parents_chain_root.push_back(s->first);
+    if (s->first == "root") break;
+  }
+  cout << "root size " << parents_chain_root.size() << endl;
+  if (parents_chain_root.empty() || parents_chain_root.back() != "root") return chain;
+  for (SegmentMap::const_iterator s=getSegment(chain_tip); s!=segments.end(); s=s->second.parent){
+    parents_chain_tip.push_back(s->first);
+    if (s->first == "root") break;
+  }
+  if (parents_chain_tip.empty() || parents_chain_tip.back()  != "root") return chain;
+
+  // remove common part of segment lists
+  string last_segment = "root";
+  while (!parents_chain_root.empty() && !parents_chain_tip.empty() &&
+         parents_chain_root.back() == parents_chain_tip.back()){
+    last_segment = parents_chain_root.back();
+    parents_chain_root.pop_back();
+    parents_chain_tip.pop_back();
+  }
+  parents_chain_root.push_back(last_segment);
+
+
+  // add the segments from the root to the common frame
+  for (unsigned int s=0; s<parents_chain_root.size()-1; s++){
+    Segment seg = getSegment(parents_chain_root[s])->second.segment;
+    Frame f_tip = seg.pose(0.0).Inverse();
+    Joint jnt = seg.getJoint();
+    if (jnt.getType() != Joint::None)
+      jnt = Joint(f_tip*jnt.JointOrigin(), f_tip.M*jnt.JointAxis(), jnt.getType());
+    chain.addSegment(Segment(jnt, f_tip, getSegment(parents_chain_root[s+1])->second.segment.getInertia()));
+  }
+
+  // add the segments from the common frame to the tip frame
+  for (int s=parents_chain_tip.size()-1; s>-1; s--)
+    chain.addSegment(getSegment(parents_chain_tip[s])->second.segment);
+
+  return chain;
 }
 
+}
+
+
Index: src/chain.cpp
===================================================================
--- src/chain.cpp	(revision 30213)
+++ src/chain.cpp	(working copy)
@@ -71,6 +71,5 @@
     Chain::~Chain()
     {
     }
-
 }
 
Index: src/joint.hpp
===================================================================
--- src/joint.hpp	(revision 30213)
+++ src/joint.hpp	(working copy)
@@ -102,6 +102,13 @@
          */
         Vector JointAxis() const;
 
+        /**                                                                     
+         * Request the Vector corresponding to the origin of a revolute joint.    
+         *                                                                      
+         * @return Vector
+         */
+        Vector JointOrigin() const;
+
         /**
          * Request the type of the joint.
          *
