Index: ode/src/quickstep.cpp
===================================================================
--- ode/src/quickstep.cpp	(revision 1665)
+++ ode/src/quickstep.cpp	(working copy)
@@ -33,6 +33,8 @@
 #include "lcp.h"
 #include "util.h"
 
+#include <iostream>
+
 #define ALLOCA dALLOCA16
 
 typedef const dReal *dRealPtr;
@@ -66,6 +68,9 @@
 
 #define RANDOMLY_REORDER_CONSTRAINTS 1
 
+
+//#define TIMING
+
 //****************************************************************************
 // special matrix multipliers
 
@@ -142,7 +147,7 @@
 
 
 // compute out = inv(M)*J'*in.
-#if 0
+#if WARM_STARTING
 static void multiply_invM_JT (int m, int nb, dRealMutablePtr iMJ, int *jb,
 	dRealMutablePtr in, dRealMutablePtr out)
 {
@@ -589,6 +594,8 @@
 	// frame, and compute the rotational force and add it to the torque
 	// accumulator. I and invI are a vertical stack of 3x4 matrices, one per body.
         dRealAllocaArray (invI,3*4*nb);
+        dRealAllocaArray (tmpI,3*4*nb);
+        dRealAllocaArray (tmpM,1*4*nb);
 	for (i=0; i<nb; i++) {
 		dMatrix3 tmp;
 
@@ -596,6 +603,12 @@
 		dMULTIPLY2_333 (tmp,body[i]->invI,body[i]->posr.R);
 		dMULTIPLY0_333 (invI+i*12,body[i]->posr.R,tmp);
 
+		memcpy (tmpI+i*12, body[i]->mass.I,3*4*sizeof(dReal));
+		tmpM[i*4+0] = body[i]->mass.mass;
+		tmpM[i*4+1] = body[i]->mass.c[0];
+		tmpM[i*4+2] = body[i]->mass.c[1];
+		tmpM[i*4+3] = body[i]->mass.c[2];
+
         if (body[i]->flags & dxBodyGyroscopic) {
             dMatrix3 I;
             // compute inertia tensor in global frame
@@ -729,6 +742,11 @@
 		IFTIMING (dTimerNow ("compute rhs");)
 		dRealAllocaArray (tmp1,nb*6);
 		// put v/h + invM*fe into tmp1
+		//
+		// with damping or joint friction this becomes inv([M + ch])*fe + inv([M + ch])*M*v/h
+		// so we need to create invM_with_damping as well as invM_with_damping*M
+		// and do the same for both linear and angular inertias
+		//
 		for (i=0; i<nb; i++) {
 			dReal body_invMass = body[i]->invMass;
 			for (j=0; j<3; j++) tmp1[i*6+j] = body[i]->facc[j] * body_invMass + body[i]->lvel[j] * stepsize1;
@@ -760,6 +778,76 @@
 		dRealAllocaArray (cforce,nb*6);
 		SOR_LCP (m,nb,J,jb,body,invI,lambda,cforce,rhs,lo,hi,cfm,findex,&world->qs);
 
+#ifdef TIMING
+		std::cout << " m: total constraint dimention " << m
+		          << " nb: number of bounded variables " << nb
+		          << " nub: number of unbounded variables " << nb
+		          << " jb: array of body numbers for each joint row " << jb
+		          << " lo " << lo
+		          << " hi " << hi
+		          << " findex " << findex
+                          << std::endl;
+
+                FILE* fJ = fopen("/tmp/J.mat","w");
+		//std::cout << " J " << J << std::endl;
+                dPrintMatrix(J,m,12,"%10.4f",fJ);
+                fclose(fJ);
+
+                FILE* finvI = fopen("/tmp/invI.mat","w");
+		//std::cout << " invI " << invI << std::endl;
+                dPrintMatrix(invI,3*nb,4,"%10.4f",finvI); // 3x4 matrices stacked vertically, nb matrices.
+                fclose(finvI);
+
+                FILE* ftmpI = fopen("/tmp/tmpI.mat","w");
+		//std::cout << " tmpI " << tmpI << std::endl;
+                dPrintMatrix(tmpI,3*nb,4,"%10.4f",ftmpI); // 3x4 matrices stacked vertically, nb matrices.
+                fclose(ftmpI);
+
+                FILE* ftmpM = fopen("/tmp/tmpM.mat","w");
+		//std::cout << " tmpM " << tmpM << std::endl;
+                dPrintMatrix(tmpM,nb,4,"%10.4f",ftmpM); // 3x4 matrices stacked vertically, nb matrices.
+                fclose(ftmpM);
+
+                FILE* fc = fopen("/tmp/c.mat","w");
+		//std::cout << " c " << c << std::endl;
+                dPrintMatrix(c,1,m,"%10.4f",fc); // 3x4 matrices stacked vertically, nb matrices.
+                fclose(fc);
+
+                FILE* flambda = fopen("/tmp/lambda.mat","w");
+		//std::cout << " lambda " << lambda << std::endl;
+                dPrintMatrix(lambda,1,m,"%10.4f",flambda); // 3x4 matrices stacked vertically, nb matrices.
+                fclose(flambda);
+
+                FILE* fcforce = fopen("/tmp/cforce.mat","w");
+		//std::cout << " cforce " << cforce << std::endl;
+                dPrintMatrix(cforce,nb,6,"%10.4f",fcforce); // 3x4 matrices stacked vertically, nb matrices.
+                fclose(fcforce);
+
+                FILE* frhs = fopen("/tmp/rhs.mat","w");
+		//std::cout << " rhs " << rhs << std::endl;
+                dPrintMatrix(rhs,1,m,"%10.4f",frhs); // 3x4 matrices stacked vertically, nb matrices.
+                fclose(frhs);
+
+                // constraint forc mixing vector
+                FILE* flo = fopen("/tmp/lo.mat","w");
+		//std::cout << " lo " << lo << std::endl;
+                dPrintMatrix(lo,1,m,"%10.4f",flo); // 3x4 matrices stacked vertically, nb matrices.
+                fclose(flo);
+
+                // constraint forc mixing vector
+                FILE* fhi = fopen("/tmp/hi.mat","w");
+		//std::cout << " hi " << hi << std::endl;
+                dPrintMatrix(hi,1,m,"%10.4f",fhi); // 3x4 matrices stacked vertically, nb matrices.
+                fclose(fhi);
+
+                // constraint forc mixing vector
+                FILE* fcfm = fopen("/tmp/cfm.mat","w");
+		//std::cout << " cfm " << cfm << std::endl;
+                dPrintMatrix(cfm,1,m,"%10.4f",fcfm); // 3x4 matrices stacked vertically, nb matrices.
+                fclose(fcfm);
+#endif
+
+
 #ifdef WARM_STARTING
 		// save lambda for the next iteration
 		//@@@ note that this doesn't work for contact joints yet, as they are
@@ -823,6 +911,20 @@
 	}
 
 #if 0
+        for (i=0; i<nb; i++) {
+                for (j=0; j<3; j++)
+                {
+                  if (body[i]->lvel[j] >  1) body[i]->lvel[j] =  1;  // hack; hard limit on velocity
+                  if (body[i]->lvel[j] < -1) body[i]->lvel[j] = -1;  // hack; hard limit on velocity
+                }
+                for (j=0; j<3; j++)
+                {
+                  if (body[i]->avel[j] >  1) body[i]->avel[j] =  1;  // hack; hard limit on velocity
+                  if (body[i]->avel[j] < -1) body[i]->avel[j] = -1;  // hack; hard limit on velocity
+                }
+        }
+#endif
+#if 0
 	// check that the updated velocity obeys the constraint (this check needs unmodified J)
 	dRealAllocaArray (vel,nb*6);
 	for (i=0; i<nb; i++) {
