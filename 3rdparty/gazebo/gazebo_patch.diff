Index: libgazebo/gazebo.h
===================================================================
--- libgazebo/gazebo.h	(revision 7531)
+++ libgazebo/gazebo.h	(working copy)
@@ -556,7 +556,7 @@
 
 
 /// Maximum image pixels (width x height)
-#define GAZEBO_CAMERA_MAX_IMAGE_SIZE 640 * 480 * 3
+#define GAZEBO_CAMERA_MAX_IMAGE_SIZE 1024 * 1024 * 3
 
 /// \brief Camera interface data
 class CameraData
@@ -852,6 +852,10 @@
 
   /// Commaned range count
   public: int cmd_range_count;
+
+  /// Is laser stream opened?  if unopened, skip sensor update to save cpu
+  public: bool opened;
+  
 };
 
 /// \brief Laser interface
@@ -870,6 +874,7 @@
           {
             Iface::Create(server,id); 
             this->data = (LaserData*)this->mMap; 
+            this->data->opened=false;
           }
 
   /// \brief Open an existing interface
@@ -879,8 +884,16 @@
           {
             Iface::Open(client,id); 
             this->data = (LaserData*)this->mMap; 
+            this->data->opened=true;
           }
 
+  /// \brief Close an existing interface
+  public: virtual void Close()
+          {
+            Iface::Close();
+            this->data->opened=false;
+          }
+
   /// Pointer to the laser data
   public: LaserData *data;
 };
@@ -1244,6 +1257,9 @@
   /// position / speed comand
   public: unsigned int joint_mode[GAZEBO_ACTARRAY_MAX_NUM_ACTUATORS];
   
+  /// Is camera stream opened? if unopened, skip sensor update to save cpu
+  public: bool opened;
+  
 };
 
 /// \brief The Actarray interface
@@ -1281,6 +1297,8 @@
 /// \} */
 
 
+
+
 /***************************************************************************/
 /// \addtogroup libgazebo_iface
 /// \{
@@ -1361,7 +1379,7 @@
 \{
 */
 
-#define GAZEBO_STEREO_CAMERA_MAX_RGB_SIZE 640 * 480 * 3
+#define GAZEBO_STEREO_CAMERA_MAX_RGB_SIZE 640 * 480 * 9
 #define GAZEBO_STEREO_CAMERA_MAX_DISPARITY_SIZE 640 * 480
 
 /// \brief Stereo data
@@ -1401,6 +1419,10 @@
 
   public: char left_camera_iface_name[256];
   public: char right_camera_iface_name[256];
+
+  /// Is stereo camera stream opened?
+  public: bool opened;
+  
 }; 
 
 
@@ -1418,6 +1440,7 @@
           {
             Iface::Create(server,id); 
             this->data = (StereoCameraData*)this->mMap; 
+            this->data->opened=false;
           }
 
   /// \brief Open the iface 
@@ -1425,8 +1448,16 @@
           {
             Iface::Open(client,id); 
             this->data = (StereoCameraData*)this->mMap; 
+            this->data->opened=true;
           }
 
+  /// \brief Close the iface 
+  public: virtual void Close()
+          {
+            Iface::Close();
+            this->data->opened=false;
+          }
+
   /// Pointer to the stereo data
   public: StereoCameraData *data;
 };
Index: server/physics/MapGeom.hh
===================================================================
--- server/physics/MapGeom.hh	(revision 7531)
+++ server/physics/MapGeom.hh	(working copy)
@@ -27,7 +27,11 @@
 #ifndef MAPGEOM_HH
 #define MAPGEOM_HH
 
-#include <Ogre.h>
+//switch to using opencv so we can run headless with map
+//#include <Ogre.h>
+#include <cv.h>
+#include <highgui.h>
+#include <cxcore.h>
 #include <deque>
 
 #include "Vector2.hh"
@@ -141,7 +145,8 @@
 
     private: ParamT<double> *wallHeightP;
 
-    private: Ogre::Image mapImage;
+    //private: Ogre::Image mapImage; //switch to using opencv so we can run headless with map
+    private: IplImage* img;
 
     private: QuadNode *root;
 
Index: server/physics/MapGeom.cc
===================================================================
--- server/physics/MapGeom.cc	(revision 7531)
+++ server/physics/MapGeom.cc	(working copy)
@@ -25,16 +25,15 @@
  */
 
 #include <ode/ode.h>
-#include <Ogre.h>
+//#include <Ogre.h> // switch to opencv so we can run headless
 #include <iostream>
 #include <string.h>
 #include <math.h>
 
 #include "BoxGeom.hh"
 #include "GazeboError.hh"
-#include "OgreAdaptor.hh"
+//#include "OgreAdaptor.hh" // switch to opencv so we can run headless
 #include "Simulator.hh"
-#include "OgreAdaptor.hh"
 #include "OgreVisual.hh"
 #include "Global.hh"
 #include "Body.hh"
@@ -88,9 +87,9 @@
 /// Load the heightmap
 void MapGeom::LoadChild(XMLConfigNode *node)
 {
-  OgreAdaptor *ogreAdaptor;
+  //OgreAdaptor *ogreAdaptor;  // switch to opencv so we can run headless
 
-  ogreAdaptor = Simulator::Instance()->GetRenderEngine();
+  //ogreAdaptor = Simulator::Instance()->GetRenderEngine();  // switch to opencv so we can run headless
 
   std::string imageFilename = node->GetString("image","",1);
 
@@ -106,14 +105,25 @@
   if (this->thresholdP->GetValue() <=0) this->thresholdP->SetValue(200);
   if (this->wallHeightP->GetValue() <= 0) this->wallHeightP->SetValue( 1.0 );
 
-  // Load the image 
-  this->mapImage.load(imageFilename,
-                Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
+  // Load the image   // switch to opencv so we can run headless
+  //this->mapImage.load(imageFilename,
+  //              Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
+  char *gazebo_resource_path = getenv("GAZEBO_RESOURCE_PATH");
+  if (gazebo_resource_path)
+    imageFilename = std::string(gazebo_resource_path)+std::string("/Media/materials/textures/")+imageFilename;
+  img=cvLoadImage(imageFilename.c_str());
+  if (!img)
+  {
+          printf("couldn't open file %s\n", imageFilename.c_str());
+          exit(0);
+  }
 
   this->root->x = 0;
   this->root->y = 0;
-  this->root->width = this->mapImage.getWidth();
-  this->root->height = this->mapImage.getHeight();
+  //this->root->width = this->mapImage.getWidth();
+  //this->root->height = this->mapImage.getHeight();
+  this->root->width = this->img->width;
+  this->root->height = this->img->height;
 
   this->BuildTree(this->root);
 
@@ -126,7 +136,8 @@
 
   this->CreateBoxes(this->root);
 
-  this->visualNode->MakeStatic();
+  if (Simulator::Instance()->GetRenderEngineEnabled())
+    this->visualNode->MakeStatic();
 }
 
 
@@ -307,7 +318,9 @@
 
   int diff = labs(freePixels - occPixels);
 
-  if (diff > this->granularityP->GetValue())
+  //if (diff > this->granularityP->GetValue())
+  // use pixel size for granularity instead of occupancy
+  if (node->width*node->height > this->granularityP->GetValue())
   {
     float newX, newY;
     float newW, newH;
@@ -353,7 +366,7 @@
         newY += ceil(newH);
     }
 
-    node->occupied = true;
+    node->occupied = false; // bug fix, better map fit
     node->leaf = false;
   }
   else if (occPixels == 0)
@@ -376,7 +389,8 @@
                                  unsigned int &freePixels, 
                                  unsigned int &occPixels )
 {
-  Ogre::ColourValue pixColor;
+  //Ogre::ColourValue pixColor;
+  CvScalar pixColor;
   unsigned char v;
   unsigned int x,y;
 
@@ -386,8 +400,11 @@
   {
     for (x = xStart; x < xStart + width; x++)
     {
-      pixColor = this->mapImage.getColourAt(x, y, 0);
-      v = (unsigned char)(255 * ((pixColor[0] + pixColor[1] + pixColor[2]) / 3.0));
+      //pixColor = this->mapImage.getColourAt(x, y, 0);
+      pixColor = cvGet2D(this->img,y,x);
+      //v = (unsigned char)(255 * ((pixColor[0] + pixColor[1] + pixColor[2]) / 3.0));
+      v = (unsigned char)((pixColor.val[0] + pixColor.val[1] + pixColor.val[2]) / 3.0);
+
       if (this->negativeP->GetValue())
         v = 255 - v;
 
Index: server/physics/Joint.hh
===================================================================
--- server/physics/Joint.hh	(revision 7531)
+++ server/physics/Joint.hh	(working copy)
@@ -156,6 +156,8 @@
     /// Name of this joint
     private: ParamT<double> *erpP;
     private: ParamT<double> *cfmP;
+    private: ParamT<double> *stopKpP; // joint limit Kp setting
+    private: ParamT<double> *stopKdP; // joint limit Kd setting
     private: ParamT<std::string> *body1NameP;
     private: ParamT<std::string> *body2NameP;
     private: ParamT<std::string> *anchorBodyNameP;
@@ -163,6 +165,43 @@
     private: ParamT<bool> *provideFeedbackP;
     private: ParamT<double> *fudgeFactorP;
 
+    /// Added for mimicing other joints
+    private: ParamT<std::string> *mimicJointP;
+    private: ParamT<double> *mimicMultP;
+    private: ParamT<double> *mimicOffsetP;
+    private: ParamT<double> *mimicKpP;
+    private: ParamT<double> *mimicKdP;
+    private: ParamT<double> *mimicFMaxP;
+
+    private: Joint *mimicJoint;
+    private: bool enableMimic;
+    private: double mimicMult;
+    private: double mimicOffset;
+    private: double mimicKp;
+    private: double mimicKd;
+    private: double mimicFMax;
+    private: double current_time_mimic, last_time_mimic;
+    private: double current_error_mimic, last_error_mimic;
+
+    // FIXME: latch is a total hack for door simulation, I need to figure a cleaner way to implement this function
+    //        works for now.
+    private: ParamT<std::string> *latchJointP;
+    private: ParamT<double> *latchAngleP;
+    private: ParamT<double> *doorClosedAngleP;
+    private: ParamT<double> *latchKpP;
+    private: ParamT<double> *latchKdP;
+    private: ParamT<double> *latchFMaxP;
+
+    private: Joint* latchJoint;
+    private: bool enableLatch;
+    private: double latchAngle;
+    private: double doorClosedAngle;
+    private: double latchKp;
+    private: double latchKd;
+    private: double latchFMax;
+    private: double current_time_latch, last_time_latch;
+    private: double current_error_latch, last_error_latch;
+
     /// Feedback data for this joint
     private: dJointFeedback *feedback;
 
Index: server/physics/ContactParams.cc
===================================================================
--- server/physics/ContactParams.cc	(revision 7531)
+++ server/physics/ContactParams.cc	(working copy)
@@ -35,11 +35,11 @@
 // Default constructor
 ContactParams::ContactParams()
 {
-  this->kp = 10000.0; //dInfinity;
-  this->kd = 0;
-  this->bounce = 0.1;
-  this->bounceVel = 0.1;
-  this->softCfm = 0.01;
+  this->kp = 100000000.0; //dInfinity; // make stiffer
+  this->kd = 1.0; // more damping for constraints
+  this->bounce = 0.0; // try not to bounce off each others, coefficient of restitution
+  this->bounceVel = 10.0; // minimum velocity before bounce is applied
+  this->softCfm = 0.01; // not used
 
   this->mu1 = dInfinity;
   this->mu2 = dInfinity;
Index: server/physics/Joint.cc
===================================================================
--- server/physics/Joint.cc	(revision 7531)
+++ server/physics/Joint.cc	(working copy)
@@ -30,6 +30,9 @@
 #include "Model.hh"
 #include "World.hh"
 #include "Joint.hh"
+#include "HingeJoint.hh"
+#include "Simulator.hh"
+#include "PhysicsEngine.hh"
 
 using namespace gazebo;
 
@@ -41,16 +44,39 @@
   this->visual = NULL;
   this->model = NULL;
 
+  this->enableMimic = false;
+  this->mimicJoint = NULL;
+
+  this->enableLatch = false;
+  this->latchJoint = NULL;
+
   Param::Begin(&this->parameters);
   this->erpP = new ParamT<double>("erp",0.4,0);
   this->cfmP = new ParamT<double>("cfm",10e-3,0);
+  this->stopKpP = new ParamT<double>("stopKp",1000000.0,0);
+  this->stopKdP = new ParamT<double>("stopKd",1.0,0);
   this->body1NameP = new ParamT<std::string>("body1",std::string(),1);
   this->body2NameP = new ParamT<std::string>("body2",std::string(),1);
   this->anchorBodyNameP = new ParamT<std::string>("anchor",std::string(),0);
   this->anchorOffsetP = new ParamT<Vector3>("anchorOffset",Vector3(0,0,0), 0);
   this->provideFeedbackP = new ParamT<bool>("provideFeedback", false, 0);
   this->fudgeFactorP = new ParamT<double>( "fudgeFactor", 1.0, 0 );
+
+  this->mimicJointP = new ParamT<std::string>("mimicJoint", std::string(), 0);
+  this->mimicMultP = new ParamT<double>("mimicMult", 1.0, 0);
+  this->mimicOffsetP = new ParamT<double>("mimicOffset", 0.0, 0);
+  this->mimicKpP = new ParamT<double>("mimicKp", 10.0, 0);
+  this->mimicKdP = new ParamT<double>("mimicKd", 0.0, 0);
+  this->mimicFMaxP = new ParamT<double>("mimicFMax", 1000.0, 0);
+
+  this->latchJointP = new ParamT<std::string>("latchJoint", std::string(), 0);
+  this->latchAngleP = new ParamT<double>("latchAngle", 0.0, 0);
+  this->doorClosedAngleP = new ParamT<double>("doorClosedAngle", 0.0, 0);
+  this->latchKpP = new ParamT<double>("latchKp", 10.0, 0);
+  this->latchKdP = new ParamT<double>("latchKd", 0.0, 0);
+  this->latchFMaxP = new ParamT<double>("latchFMax", 1000.0, 0);
   Param::End();
+
 }
 
 
@@ -61,12 +87,26 @@
   dJointDestroy( this->jointId );
   delete this->erpP;
   delete this->cfmP;
+  delete this->stopKpP;
+  delete this->stopKdP;
   delete this->body1NameP;
   delete this->body2NameP;
   delete this->anchorBodyNameP;
   delete this->anchorOffsetP;
   delete this->provideFeedbackP;
   delete this->fudgeFactorP;
+  delete this->mimicJointP;
+  delete this->mimicMultP;
+  delete this->mimicOffsetP;
+  delete this->mimicKpP;
+  delete this->mimicKdP;
+  delete this->mimicFMaxP;
+  delete this->latchJointP;
+  delete this->latchAngleP;
+  delete this->doorClosedAngleP;
+  delete this->latchKpP;
+  delete this->latchKdP;
+  delete this->latchFMaxP;
 }
 
 
@@ -90,8 +130,22 @@
   this->anchorOffsetP->Load(node);
   this->erpP->Load(node);
   this->cfmP->Load(node);
+  this->stopKpP->Load(node);
+  this->stopKdP->Load(node);
   this->provideFeedbackP->Load(node);
   this->fudgeFactorP->Load(node);
+  this->mimicJointP->Load(node);
+  this->mimicMultP->Load(node);
+  this->mimicOffsetP->Load(node);
+  this->mimicKpP->Load(node);
+  this->mimicKdP->Load(node);
+  this->mimicFMaxP->Load(node);
+  this->latchJointP->Load(node);
+  this->latchAngleP->Load(node);
+  this->doorClosedAngleP->Load(node);
+  this->latchKpP->Load(node);
+  this->latchKdP->Load(node);
+  this->latchFMaxP->Load(node);
 
   Body *body1 = this->model->GetBody( **(this->body1NameP));
   Body *body2 = this->model->GetBody(**(this->body2NameP));
@@ -108,6 +162,11 @@
   // Set joint parameters
   this->SetParam(dParamSuspensionERP, **(this->erpP));
   this->SetParam(dParamCFM, **(this->cfmP));
+  double h = World::Instance()->GetPhysicsEngine()->GetStepTime();
+  double stopErp = h * this->stopKpP->GetValue() / (h * this->stopKpP->GetValue() + this->stopKdP->GetValue());
+  double stopCfm = 1.0 / (h * this->stopKpP->GetValue() + this->stopKdP->GetValue());
+  this->SetParam(dParamStopERP, stopErp);
+  this->SetParam(dParamStopCFM, stopCfm);
   this->SetParam(dParamFudgeFactor, **(this->fudgeFactorP));
   this->SetParam(dParamVel,0);
   this->SetParam(dParamFMax,0);
@@ -116,23 +175,26 @@
   this->Attach(body1,body2);
 
   /// Add a renderable for the joint
-  this->visual = new OgreVisual(this->model->GetVisualNode());
-  this->visual->AttachMesh("joint_anchor");
-  this->visual->SetVisible(false);
+  if (Simulator::Instance()->GetRenderEngineEnabled())
+  {
+    this->visual = new OgreVisual(this->model->GetVisualNode());
+    this->visual->AttachMesh("joint_anchor");
+    this->visual->SetVisible(false);
 
-  this->line1 = new OgreDynamicLines(OgreDynamicRenderable::OT_LINE_LIST);
-  this->line2 = new OgreDynamicLines(OgreDynamicRenderable::OT_LINE_LIST);
+    this->line1 = new OgreDynamicLines(OgreDynamicRenderable::OT_LINE_LIST);
+    this->line2 = new OgreDynamicLines(OgreDynamicRenderable::OT_LINE_LIST);
 
-  this->line1->setMaterial("Gazebo/BlueEmissive");
-  this->line2->setMaterial("Gazebo/BlueEmissive");
+    this->line1->setMaterial("Gazebo/BlueEmissive");
+    this->line2->setMaterial("Gazebo/BlueEmissive");
 
-  this->visual->AttachObject(this->line1);
-  this->visual->AttachObject(this->line2);
+    this->visual->AttachObject(this->line1);
+    this->visual->AttachObject(this->line2);
 
-  this->line1->AddPoint(Vector3(0,0,0));
-  this->line1->AddPoint(Vector3(0,0,0));
-  this->line2->AddPoint(Vector3(0,0,0));
-  this->line2->AddPoint(Vector3(0,0,0));
+    this->line1->AddPoint(Vector3(0,0,0));
+    this->line1->AddPoint(Vector3(0,0,0));
+    this->line2->AddPoint(Vector3(0,0,0));
+    this->line2->AddPoint(Vector3(0,0,0));
+  }
 
   if (**this->provideFeedbackP)
   {
@@ -147,6 +209,37 @@
   {
     this->SetAnchor(anchorVec);
   }
+
+  // Check mimic option
+  if (this->type == Joint::HINGE && **(this->mimicJointP) != std::string())
+  {
+    // enforce constraint
+    this->enableMimic = true;
+
+    this->mimicMult   = this->mimicMultP->GetValue();
+    this->mimicOffset = this->mimicOffsetP->GetValue();
+    this->mimicKp     = this->mimicKpP->GetValue();
+    this->mimicKd     = this->mimicKdP->GetValue();
+    this->mimicFMax   = this->mimicFMaxP->GetValue();
+
+    dynamic_cast<HingeJoint*>(this)->SetParam(dParamFMax, this->mimicFMax);
+    dynamic_cast<HingeJoint*>(this)->SetTorque(0);
+
+  }
+
+  if (this->type == Joint::HINGE && **(this->latchJointP) != std::string())
+  {
+    this->enableLatch = true;
+    this->latchAngle = this->latchAngleP->GetValue();
+    this->doorClosedAngle = this->doorClosedAngleP->GetValue();
+    this->latchKp     = this->latchKpP->GetValue();
+    this->latchKd     = this->latchKdP->GetValue();
+    this->latchFMax   = this->latchFMaxP->GetValue();
+
+    dynamic_cast<HingeJoint*>(this)->SetParam(dParamFMax, this->latchFMax);
+    dynamic_cast<HingeJoint*>(this)->SetTorque(0);
+
+  }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -172,6 +265,8 @@
 
   stream << prefix << "  " << *(this->erpP) << "\n";
   stream << prefix << "  " << *(this->cfmP) << "\n";
+  stream << prefix << "  " << *(this->stopKpP) << "\n";
+  stream << prefix << "  " << *(this->stopKdP) << "\n";
   stream << prefix << "  " << *(this->fudgeFactorP) << "\n";
 
   std::string p = prefix + "  ";
@@ -184,13 +279,121 @@
 /// Update the joint
 void Joint::Update()
 {
-//TODO: Evaluate impact of this code on performance
-  this->visual->SetVisible(World::Instance()->GetShowJoints());
+  // enforce mimic
+  // only enforce constraint for same type hinge joints
+  if (this->enableMimic           == true         &&
+      this->type                  == Joint::HINGE )
+  {
+    // get the joint
+    if (this->mimicJoint == NULL)
+    {
+      this->mimicJoint = this->model->GetJoint( **(this->mimicJointP));
+      if (this->mimicJoint == NULL || this->mimicJoint == this || this->mimicJoint->GetType() != Joint::HINGE) // check initialization
+        this->enableMimic = false;
+      else
+      {
+        // initialize a few things
+        std::cout << " this joint " << this->nameP->GetValue() << " will mimic joint " << this->mimicJointP->GetValue() << std::endl;
+        current_time_mimic = Simulator::Instance()->GetSimTime();
+        last_time_mimic = current_time_mimic;
+        current_error_mimic = (this->mimicMult*((dynamic_cast<HingeJoint*>(this->mimicJoint))->GetAngle()) - this->mimicOffset - dynamic_cast<HingeJoint*>(this)->GetAngle());
+        last_error_mimic = current_error_mimic;
+      }
+    }
+    else
+    {
+      current_time_mimic = Simulator::Instance()->GetSimTime();
+      current_error_mimic = (this->mimicMult*((dynamic_cast<HingeJoint*>(this->mimicJoint))->GetAngle()) - this->mimicOffset - dynamic_cast<HingeJoint*>(this)->GetAngle());
 
+      double cmd =  this->mimicKp * current_error_mimic
+                  + this->mimicKd * (current_error_mimic - last_error_mimic) * (current_time_mimic - last_time_mimic);
+
+      dynamic_cast<HingeJoint*>(this)->SetParam(dParamVel, cmd);
+
+      last_error_mimic = current_error_mimic;
+      last_time_mimic = current_time_mimic;
+      // std::cout <<   " joint name " << this->nameP->GetValue()
+      //           <<" current_error " << this->current_error_mimic
+      //           <<   " last_error " << this->last_error_mimic
+      //           <<          " cmd " << cmd
+      //           << " mimic offset " << this->mimicOffset
+      //           << " mimic multip " << this->mimicMult
+      //           << " mimic     Kp " << this->mimicKp
+      //           << " mimic     Kd " << this->mimicKd
+      //           <<     "    fmax  " << (dynamic_cast<HingeJoint*>(this))->GetParam(dParamFMax)
+      //           <<     "     vel  " << (dynamic_cast<HingeJoint*>(this))->GetParam(dParamVel)
+      //           <<     "     ang  " << (dynamic_cast<HingeJoint*>(this))->GetAngle()
+      //           << std::endl;
+    }
+  }
+
+  // Check latch option
+  if (this->enableLatch)
+  {
+    if (this->latchJoint == NULL)
+    {
+      this->latchJoint = this->model->GetJoint( **(this->latchJointP));
+      if (this->latchJoint == NULL || this->latchJoint == this) // check initialization
+        this->enableLatch = false;
+      else
+      {
+        std::cout << " this joint " << this->nameP->GetValue() << " latched by joint " << this->latchJoint << " by angle " << this->latchAngle << std::endl;
+        // initialize a few things
+        current_time_latch = Simulator::Instance()->GetSimTime();
+        last_time_latch = current_time_latch;
+        current_error_latch = (dynamic_cast<HingeJoint*>(this->latchJoint))->GetAngle() - this->doorClosedAngle;
+        last_error_latch = current_error_latch;
+      }
+    }
+    else
+    {
+
+      // enforce latch constraint if door in conditions match
+      if (fabs((dynamic_cast<HingeJoint*>(this))            ->GetAngle() - this->doorClosedAngle) <= 0.01 &&   // door at closed position
+          fabs((dynamic_cast<HingeJoint*>(this->latchJoint))->GetAngle() - this->latchAngle     ) <= 0.01)   // handle at latched position
+      {
+        dynamic_cast<HingeJoint*>(this)->SetParam(dParamFMax, this->latchFMax);
+        // latch door
+        current_time_latch = Simulator::Instance()->GetSimTime();
+        current_error_latch = this->doorClosedAngle - (dynamic_cast<HingeJoint*>(this))->GetAngle();
+
+        double cmd =  this->latchKp * current_error_latch
+                    + this->latchKd * (current_error_latch - last_error_latch) * (current_time_latch - last_time_latch);
+
+        dynamic_cast<HingeJoint*>(this)->SetParam(dParamVel, cmd);
+
+        last_error_latch = current_error_latch;
+        last_time_latch = current_time_latch;
+        // std::cout <<   " joint name " << this->nameP->GetValue()
+        //           <<" current_error " << this->current_error_latch
+        //           <<   " last_error " << this->last_error_latch
+        //           <<          " cmd " << cmd
+        //           << " latch     Kp " << this->latchKp
+        //           << " latch     Kd " << this->latchKd
+        //           <<     "    fmax  " << (dynamic_cast<HingeJoint*>(this))->GetParam(dParamFMax)
+        //           <<     "     vel  " << (dynamic_cast<HingeJoint*>(this))->GetParam(dParamVel)
+        //           <<     "     ang  " << (dynamic_cast<HingeJoint*>(this))->GetAngle()
+        //           << std::endl;
+      }
+      else
+      {
+        dynamic_cast<HingeJoint*>(this)->SetParam(dParamFMax, 0.0);
+      }
+    }
+  }
+
+
+
+
+  //TODO: Evaluate impact of this code on performance
+  if (Simulator::Instance()->GetRenderEngineEnabled())
+    this->visual->SetVisible(World::Instance()->GetShowJoints());
+
   if (!World::Instance()->GetShowJoints())
     return;
 
-  this->visual->SetPosition(this->GetAnchor());
+  if (Simulator::Instance()->GetRenderEngineEnabled())
+    this->visual->SetPosition(this->GetAnchor());
 
   Vector3 start;
   if (this->body1)
@@ -206,6 +409,7 @@
     this->line2->SetPoint(0, start);
     this->line2->Update();
   }
+
 }
 
 //////////////////////////////////////////////////////////////////////////////
Index: server/Model.hh
===================================================================
--- server/Model.hh	(revision 7531)
+++ server/Model.hh	(working copy)
@@ -39,6 +39,10 @@
 #include "Entity.hh"
 #include "gazebo.h"
 
+#include <boost/thread/mutex.hpp>
+#include <boost/bind.hpp>
+#include <boost/thread/thread.hpp>
+#include <boost/thread/condition.hpp>
 
 namespace gazebo
 {
@@ -160,6 +164,9 @@
   
     /// \brief Load a renderable model (like a light source).
     private: void LoadRenderable(XMLConfigNode *node);
+
+    /// \brief threaded flag set?
+    private: bool IsThreaded();
   
     /// \brief Type of the model (such as Pioneer2DX, or SimpleSolid)
     private: std::string type;
@@ -193,8 +200,8 @@
     private: ParamT<Quatern> *rpyP;
     private: ParamT<std::string> *parentBodyNameP;
     private: ParamT<std::string> *myBodyNameP;
+    private: ParamT<bool> *threadP;
 
-
     // Name of a light (if the model is renderable:light)
     private: std::string lightName;
 
@@ -202,6 +209,7 @@
       private: PyObject *pModule;
       private: PyObject *pFuncUpdate;
     */
+
   };
   /// \}
 }
Index: server/Global.hh
===================================================================
--- server/Global.hh	(revision 7531)
+++ server/Global.hh	(working copy)
@@ -88,4 +88,7 @@
 
 #define GZ_DELETE(p) { if(p) { delete (p);  (p)=NULL; } }
 
+// Timing Debug
+//#define TIMING
+
 #endif
Index: server/rendering/UserCamera.hh
===================================================================
--- server/rendering/UserCamera.hh	(revision 7531)
+++ server/rendering/UserCamera.hh	(working copy)
@@ -81,6 +81,10 @@
     private: std::string name;
     private: static unsigned int cameraCount;
     private: static int count;
+
+    protected: ParamT<bool> *UCSaveFramesP;
+    /// List of all the parameters
+    protected: std::vector<Param*> UCParameters;
   };
 }
 
Index: server/rendering/UserCamera.cc
===================================================================
--- server/rendering/UserCamera.cc	(revision 7531)
+++ server/rendering/UserCamera.cc	(working copy)
@@ -51,6 +51,10 @@
 
   stream << "UserCamera_" << this->count++;
   this->name = stream.str(); 
+
+  Param::Begin(&this->UCParameters);
+  this->UCSaveFramesP = new ParamT<bool>("UCSaveFrames", false, 0);
+  Param::End();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -65,6 +69,9 @@
 {
   OgreCamera::LoadCam(node);
 
+  if (node)
+    this->UCSaveFramesP->Load(node);
+
   this->SetClipDist(0.1, 100);
   this->SetFOV( DTOR(60) );
 }
@@ -94,8 +101,7 @@
 
   OgreAdaptor::Instance()->UpdateWindow(this->window, this);
 
-
-  if (this->saveFramesP->GetValue())
+  if (this->UCSaveFramesP->GetValue())
   {
     char tmp[1024];
     if (!this->savePathnameP->GetValue().empty())
Index: server/Model.cc
===================================================================
--- server/Model.cc	(revision 7531)
+++ server/Model.cc	(working copy)
@@ -46,7 +46,12 @@
 #include "ControllerFactory.hh"
 #include "IfaceFactory.hh"
 #include "Model.hh"
+#include "Simulator.hh"
 
+#ifdef TIMING
+#include "Simulator.hh"// for timing
+#endif
+
 using namespace gazebo;
 
 uint Model::lightNumber = 0;
@@ -68,6 +73,8 @@
 
   this->rpyP = new ParamT<Quatern>("rpy", Quatern(1,0,0,0), 0);
   this->rpyP->Callback( &Model::SetRotation, this);
+
+  this->threadP = new ParamT<bool>("model_thread",false,0);
   Param::End();
 
   this->parentBodyNameP = NULL;
@@ -101,8 +108,14 @@
   }
   this->controllers.clear();
 
+  GZ_DELETE(this->xyzP);
+  GZ_DELETE(this->rpyP);
+
   GZ_DELETE(this->parentBodyNameP);
   GZ_DELETE(this->myBodyNameP);
+
+  GZ_DELETE(this->threadP);
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -118,6 +131,7 @@
   this->canonicalBodyNameP->Load(node);
   this->xyzP->Load(node);
   this->rpyP->Load(node);
+  this->threadP->Load(node);
 
   this->xmlNode = node;
   this->type=node->GetName();
@@ -127,7 +141,10 @@
   if (this->type == "physical")
     this->LoadPhysical(node);
   else if (this->type == "renderable")
-    this->LoadRenderable(node);
+  {
+    if (Simulator::Instance()->GetRenderEngineEnabled())
+      this->LoadRenderable(node);
+  }
   else if (this->type != "empty")
   {
     gzthrow("Invalid model type[" + this->type + "]\n");
@@ -172,8 +189,6 @@
   // Record the model's initial pose (for reseting)
   this->SetInitPose(pose);
 
-  return 0;
-
   // Get the name of the python module
   /*this->pName.reset(PyString_FromString(node->GetString("python","",0).c_str()));
   //this->pName.reset(PyString_FromString("pioneer2dx"));
@@ -193,6 +208,9 @@
       this->pFuncUpdate = NULL;
   }
   */
+
+  return 0;
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -255,10 +273,11 @@
   }
   else
   {
-    if (!this->lightName.empty())
-    {
-      OgreCreator::SaveLight(p, this->lightName, stream);
-    }
+    if (Simulator::Instance()->GetRenderEngineEnabled())
+      if (!this->lightName.empty())
+      {
+        OgreCreator::SaveLight(p, this->lightName, stream);
+      }
   }
 
   if (this->parentBodyNameP && this->myBodyNameP)
@@ -316,6 +335,10 @@
 
   Pose3d bodyPose, newPose, oldPose;
 
+#ifdef TIMING
+  double tmpT1 = Simulator::Instance()->GetWallTime();
+#endif
+
   for (bodyIter=this->bodies.begin(); bodyIter!=this->bodies.end(); bodyIter++)
   {
     if (bodyIter->second)
@@ -324,6 +347,11 @@
     }
   }
 
+#ifdef TIMING
+  double tmpT2 = Simulator::Instance()->GetWallTime();
+  std::cout << "      ALL Bodies DT (" << this->GetName() << ") (" << tmpT2-tmpT1 << ")" << std::endl;
+#endif
+
   for (contIter=this->controllers.begin();
        contIter!=this->controllers.end(); contIter++)
   {
@@ -332,6 +360,11 @@
       contIter->second->Update();
   }
 
+#ifdef TIMING
+  double tmpT3 = Simulator::Instance()->GetWallTime();
+  std::cout << "      ALL Controllers DT (" << this->GetName() << ") (" << tmpT3-tmpT2 << ")" << std::endl;
+#endif
+
   for (jointIter = this->joints.begin(); jointIter != this->joints.end(); jointIter++)
   {
     jointIter->second->Update();
@@ -350,9 +383,26 @@
     this->rpyP->SetValue(this->pose.rot);
   }
 
+#ifdef TIMING
+  double tmpT4 = Simulator::Instance()->GetWallTime();
+  std::cout << "      ALL Joints/canonical body (" << this->GetName() << ") DT (" << tmpT4-tmpT3 << ")" << std::endl;
+#endif
+
+
+#ifdef TIMING
+  int update_error = this->UpdateChild();
+  double tmpT5 = Simulator::Instance()->GetWallTime();
+  std::cout << "      ALL child (" << this->GetName() << ") update DT (" << tmpT5-tmpT4 << ")" << std::endl;
+  std::cout << "      Models::Update() (" << this->GetName() << ") Total DT (" << tmpT5-tmpT1 << ")" << std::endl;
+  return update_error;
+#else
   return this->UpdateChild();
+#endif
+
+
 }
 
+
 ////////////////////////////////////////////////////////////////////////////////
 // Finalize the model
 int Model::Fini()
@@ -730,10 +780,11 @@
   body->SetPose(Pose3d());
   this->bodies[body->GetName()] = body;
 
-  if ((childNode = node->GetChild("light")))
-  {
-    this->lightName = OgreCreator::CreateLight(childNode, body->GetVisualNode());
-  }
+  if (Simulator::Instance()->GetRenderEngineEnabled())
+    if ((childNode = node->GetChild("light")))
+    {
+      this->lightName = OgreCreator::CreateLight(childNode, body->GetVisualNode());
+    }
 
 }
 
@@ -779,3 +830,11 @@
   }
 
 }
+
+////////////////////////////////////////////////////////////////////////////////
+// Load a physical model
+bool Model::IsThreaded()
+{
+  return this->threadP->GetValue();
+}
+
Index: SConstruct
===================================================================
--- SConstruct	(revision 7531)
+++ SConstruct	(working copy)
@@ -5,7 +5,7 @@
 
 exec(open('build.py'))
 
-PKG_CONFIG_VERSION = '0.23'
+PKG_CONFIG_VERSION = '0.21'
 OGRE_VERSION = '= 1.4.9'
 ODE_VERSION = '>= 0.10.1'
 
@@ -21,20 +21,29 @@
 opts.Add('destdir', 'The root directory to install into. Useful mainly for binary package building', '/')
 opts.Add('mode','Defines how Gazebo will be built, options available: optimized, profile, debug','debug')
 opts.Add('with_audio','Builds support for 3d sound. Options available: no, yes ', 'no')
+opts.Add('boost_lflags','boost link flags', '')
+opts.Add('boost_cflags','boost compile flags', '')
+opts.Add('intel_lflags','intel link flags', '')
+opts.Add('intel_cflags','intel compile flags', '')
 
 #
 # 3rd party packages
 #
 parseConfigs=['pkg-config --cflags --libs OGRE',
+              'pkg-config --cflags --libs freeimage', 
+              'ode-config --cflags --libs', 
               'xml2-config --cflags --libs', 
-      	      'ode-config --cflags --libs',
               'fltk-config --cflags --libs --ldflags --use-gl --use-images',
-              'pkg-config --cflags --libs xft'
+              'pkg-config --cflags --libs xft',
+              'pkg-config --cflags --libs opencv'
               ]
 
 #
 # setup the build environment
 #
+#  CC = '/opt/intel/cc/10.1.008/bin/icc',
+#  CXX = '/opt/intel/cc/10.1.008/bin/icpc',
+#  LD = '/opt/intel/cc/10.1.008/bin/xild',
 env = Environment (
   CC = 'g++',
 
@@ -61,7 +70,7 @@
   LIBPATH=Split('#libgazebo'),
     
   #LIBS=Split('gazebo boost_python')
-  LIBS=Split('gazebo boost_signals'),
+  LIBS=Split('gazebo'),
   LINKFLAGS=Split('-export-dynamic'),
 
   TARFLAGS = '-c -z',
@@ -70,6 +79,19 @@
   options=opts
 )
 
+env['CCFLAGS']   +=   Split(env['boost_cflags'])
+env['LINKFLAGS'] +=   Split(env['boost_lflags'])
+
+env['CCFLAGS']   +=   Split(env['intel_cflags'])
+env['LINKFLAGS'] +=   Split(env['intel_lflags'])
+
+# Do not use boost_signals if boost_lflags are specified
+if not env['boost_lflags']:
+  print "Using boost_signals"
+  env['LIBS'] += ['boost_signals']
+else:
+  print "Using boost_lflags:",env['boost_lflags']
+
 Help(opts.GenerateHelpText(env))
 
 if env['destdir'] != '/':
@@ -86,7 +108,7 @@
 rcconfig = env.RCConfig(target='gazeborc', source=Value(install_prefix))
 
 # DEFAULT list of subdirectories to build
-subdirs = ['libgazebo','server', 'player']
+subdirs = ['libgazebo','server']
 
 # Set the compile mode
 if env['mode'] == 'debug':
@@ -154,9 +176,10 @@
         Exit(1)
 
 # Check for trimesh support in ODE
-if not conf.CheckODELib():
-  print '  Error: ODE not compiled with trimesh support.'
-  Exit(1)
+if not env.GetOption('clean'):
+  if not conf.CheckODELib():
+    print '  Error: ODE not compiled with trimesh support.'
+    Exit(1)
 
 env = conf.Finish()
 
