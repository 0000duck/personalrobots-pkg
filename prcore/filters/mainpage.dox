/**
@mainpage
@htmlinclude manifest.html

@section filters Filters
@subsection summary Summary
The filters library is designed to allow runtime reconfiguration of data processing within C++ code, including processes running in realtime. 

To implement this filters have a standardized interface which allows them to be programatically constructed and used without knowing the exact type of filter. 

To setup the filter_chain there is a method filter_chain::configure which looks like this
\code
filter_chain_instance.configureFromXMLString(1, filter_xml_string);
\endcode

The processing step is a single function call: 
\code
filter_chain_instance.update (unfiltered_in, filtered_out);
\endcode

There are fullly functional examples in \ref example

@section implementation_requirements Requirements for using a filter
It is recommended to use a filter_chain whenever you use a filter. To use a filter::FilterChain<T>
the requirementes are:
 - include filters/filter_chain.h
 - include the header files for all filters potentially to be used
 - configure the filter chain from xml filters::FilterChain::configure or filters::FilterChain::configureFromXMLString
 - Call filters::FilterChain::update to process data.  

The requirments for using an indivudual filter only are:
 - Include the header file which defines the filter.
 - Configure the filter with virtual filters::FilterBase::configure
 - Call update on the filter virtual filters::FilterBase::update



@section requirements Requirements for implementing a filter
The requirements for making a filter:
 - A filter must be a templated class (MyFilterType<T>) derived from filters::FilterBase<T>
 - The filter must implement the methods configure() and update(const std::vector<T>& data_in, std::vector<T>& data_out) and have a default constructor and destructor.
 - For every valid template value you must call ROS_REGISTER_FILTER(MyFilterType, TemplateType)


Here are the filters generic filters which are currently implemented and realtime safe:
 \li \ref filters::MedianFilter "MedianFilter"
 \li \ref filters::MeanFilter "MeanFilter"
 \li \ref filters::TransferFunctionFilter "TransferFunctionFilter"

@section concepts Concepts
@subsection use Intended Use 
The intended use of this library is to
allow reconfigurable data processing.  Examples of using the filters
for controls are input and output data conditioning for controllers.
If each controller has an input and output filter chain.  By default
they will pass through.  However if there is a problem with noise from
a sensor a filter can be set in the XML of the launch and relaunched
removing the noise.  As long as the filters are realtime safe the
filter_chain will also be realtiem safe.  Examples of using the
filters for vision algorithms are discarding fringing data from laser
scans and classifying points in point clouds.

@subsection chain Filter Chain 
To make constructing and calling a
sequence of filters easy filters::FilterChain class was created.  It
has the same style of interface, with configure and update as the
primary interaction.  Inside the filter chain, on configure() it will
construct all the filters designated by the XML, configure the
filters, and preallocated intermediate buffers.  And on update() it
will sequentially call each filter using the input and intermediate
buffers ending with the outputof the last filter in the output buffer.

@subsection parameters Parameters from XML 
Embedded in each filter's XML
can be any arbitrary parameters which the filters::FilterBase provides
accessors for the derived class.  In addition access to the raw XML is
available for advanced users.  For example see the
laser_scan::LaserMedianFilter which passes XML through to the
filters::MedianFilter which is used internally to process the raw
range and intensity readings.



@page example Example Usage
This page provides examples of how to use the filters package documented  at \ref mainpage.

Below is example code \ref source.  Followed by example XML filter parameters \ref params.  With 
example launch files \ref launch.  All these examples are simply code from the laser_scan package.  


@section source Source Code Example
\code
#include "ros/node.h"
#include "laser_scan/LaserScan.h"
#include "laser_scan/median_filter.h"
#include "laser_scan/intensity_filter.h"
#include "laser_scan/scan_shadows_filter.h"

static std::string median_filter_xml = "<!-- NO FILTER DEFINED-->";


class GenericLaserScanFilterNode 
{
public:
  laser_scan::LaserScan msg;


  GenericLaserScanFilterNode(ros::Node& anode) :  filter_chain_(), node_(anode)
  {
    node_.advertise<laser_scan::LaserScan>("~output", 1000);

    std::string filter_xml;
    node_.param("~filters", filter_xml, std::string("<filters><!--Filter Parameter Not Set--></filters>"));
    ROS_INFO("Got parameter'~filters' as: %s\n", filter_xml.c_str());
    
    filter_chain_.configureFromXMLString(1, filter_xml);
    node_.subscribe("scan_in", msg, &GenericLaserScanFilterNode::callback,this, 3);
  }
  void callback()
  {
    filter_chain_.update (msg, msg);
    node_.publish("~output", msg);
  }

protected:
  filters::FilterChain<laser_scan::LaserScan> filter_chain_;
  ros::Node& node_;
};

int main(int argc, char **argv)
{
  ros::init(argc, argv);
  ros::Node ros_node("scan_filter_node");
  
  GenericLaserScanFilterNode t(ros_node);
  ros_node.spin();
  
  return 0;
}
\endcode

@section params XML Parameter Files
This is the ScanShadows Filter configuration from the laser_scan package.  
\verbatim
<filters>
  <filter type="ScanShadowsFilter" name="shadows">
    <params min_angle="10" max_angle="170" window="1"/>
  </filter>

</filters>
\endverbatim

An example with multiple filters is:
\verbatim
<filters>
  <filter type="LaserMedianFilter" name="laser_median_test_7_from_file"> 
    <filters>
      <filter type="MedianFilter" name="median_test_7_from_file"> 
	<params number_of_observations="10"/>
      </filter>
      <filter type="MedianFilter" name="median_test_7a_from_file"> 
	<params number_of_observations="10"/>
      </filter>
  
  
    </filters>
  </filter>
  <filter type="LaserScanIntensityFilter" name="intensity"> 
    <params lower_threshold="7999"/>
  </filter>
  <filter type="ScanShadowsFilter" name="shadows">
    <params min_angle="10" max_angle="170" window="1"/>
  </filter>

</filters>
\endverbatim

@section launch Launch Files

To launch the above filters a launch script like this could be used:
\verbatim
<launch>
<node pkg="laser_scan" type="generic_laser_filter_node" output="screen" name="laser_shadows_filter">
      <remap from="scan_in" to="base_scan" />
      <param name="filters" textfile="$(find laser_scan)/filter_definition.xml" />
</node>
</launch>
\endverbatim
Where filter_definiiton.xml contains the above xml \ref params.


**/
