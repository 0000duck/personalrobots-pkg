/* auto-generated by genmsg_cpp from /u/pantofaru/Install/ros/ros-pkg/vision/people/msg/PositionMeasurement.msg.  Do not edit! */
#ifndef PEOPLE_POSITIONMEASUREMENT_H
#define PEOPLE_POSITIONMEASUREMENT_H

#include <string>
#include <vector>
#include "ros/message.h"
#include "ros/time.h"

#include "roslib/Header.h"
#include "robot_msgs/Point.h"

namespace people
{

//! \htmlinclude PositionMeasurement.msg.html

class PositionMeasurement : public ros::Message
{
public:
  roslib::Header header;
  std::string name;
  std::string object_id;
  robot_msgs::Point pos;
  double reliability;
  std::vector<double> covariance;
  int8_t initialization;

  PositionMeasurement() : ros::Message(),
    reliability(0),
    initialization(0)
  {
  covariance.resize(9);
  }
  PositionMeasurement(const PositionMeasurement &copy) : ros::Message(),
    header(copy.header),
    name(copy.name),
    object_id(copy.object_id),
    pos(copy.pos),
    reliability(copy.reliability),
    initialization(copy.initialization)
  {
    (void)copy;
    covariance = copy.covariance;
  }
  PositionMeasurement &operator =(const PositionMeasurement &copy)
  {
    if (this == &copy)
      return *this;
    covariance.clear();
    header = copy.header;
    name = copy.name;
    object_id = copy.object_id;
    pos = copy.pos;
    reliability = copy.reliability;
    covariance = copy.covariance;
    initialization = copy.initialization;
    return *this;
  }
  virtual ~PositionMeasurement() 
  {
    covariance.clear();
  }
  inline static std::string __s_getDataType() { return std::string("people/PositionMeasurement"); }
  inline static std::string __s_getMD5Sum() { return std::string("9da2997e69ab83d26b742b4c5d4d0d04"); }
  inline static std::string __s_getMessageDefinition()
  {
    return std::string(
    "Header          header\n"
    "string          name\n"
    "string          object_id\n"
    "robot_msgs/Point  pos\n"
    "float64         reliability\n"
    "float64[9]      covariance\n"
    "byte            initialization\n"
    "================================================================================\n"
    "MSG: roslib/Header\n"
    "#Standard metadata for higher-level flow data types\n"
    "#sequence ID: consecutively increasing ID \n"
    "uint32 seq\n"
    "#Two-integer timestamp that is expressed as:\n"
    "# * stamp.secs: seconds (stamp_secs) since epoch\n"
    "# * stamp.nsecs: nanoseconds since stamp_secs\n"
    "# time-handling sugar is provided by the client library\n"
    "time stamp\n"
    "#Frame this data is associated with\n"
    "# 0: no frame\n"
    "# 1: global frame\n"
    "string frame_id\n"
    "\n"
    "================================================================================\n"
    "MSG: robot_msgs/Point\n"
    "float64 x\n"
    "float64 y\n"
    "float64 z\n"
    "\n"
    "\n"
    "\n"
    );
  }
  inline virtual const std::string __getDataType() const { return __s_getDataType(); }
  inline virtual const std::string __getMD5Sum() const { return __s_getMD5Sum(); }
  inline virtual const std::string __getMessageDefinition() const { return __s_getMessageDefinition(); }
  inline uint32_t get_covariance_size() const { return 9; }
  inline void get_covariance_vec (std::vector<double> &__ros_vec) const
  {
    __ros_vec = this->covariance;
  }
  inline void set_covariance_vec(const std::vector<double> &__ros_vec)
  {
    this->covariance = __ros_vec;
  }
  inline uint32_t serializationLength() const
  {
    unsigned __l = 0;
    __l += header.serializationLength(); // header
    __l += 4 + name.length(); // name
    __l += 4 + object_id.length(); // object_id
    __l += pos.serializationLength(); // pos
    __l += 8; // reliability
    __l += 9 * 8; // covariance
    __l += 1; // initialization
    return __l;
  }
  virtual uint8_t *serialize(uint8_t *write_ptr, uint32_t seq) const
  {
    roslib::Header _ser_header = header;
    bool __reset_seq = (header.seq == 0);
    if (__reset_seq) _ser_header.seq = seq;
    bool __reset_timestamp = header.stamp.is_zero();
    if (__reset_timestamp)
      _ser_header.stamp = ros::Time::now();
    write_ptr = _ser_header.serialize(write_ptr, seq);
    unsigned __ros_name_len = name.length();
    SROS_SERIALIZE_PRIMITIVE(write_ptr, __ros_name_len);
    SROS_SERIALIZE_BUFFER(write_ptr, name.c_str(), __ros_name_len);
    unsigned __ros_object_id_len = object_id.length();
    SROS_SERIALIZE_PRIMITIVE(write_ptr, __ros_object_id_len);
    SROS_SERIALIZE_BUFFER(write_ptr, object_id.c_str(), __ros_object_id_len);
    write_ptr = pos.serialize(write_ptr, seq);
    SROS_SERIALIZE_PRIMITIVE(write_ptr, reliability);
    memcpy(write_ptr, &covariance[0], sizeof(double) * 9);
    write_ptr += sizeof(double) * 9;
    SROS_SERIALIZE_PRIMITIVE(write_ptr, initialization);
    return write_ptr;
  }
  virtual uint8_t *deserialize(uint8_t *read_ptr)
  {
    read_ptr = header.deserialize(read_ptr);
    unsigned __ros_name_len;
    SROS_DESERIALIZE_PRIMITIVE(read_ptr, __ros_name_len);
    name = std::string((const char *)read_ptr, __ros_name_len);
    read_ptr += __ros_name_len;
    unsigned __ros_object_id_len;
    SROS_DESERIALIZE_PRIMITIVE(read_ptr, __ros_object_id_len);
    object_id = std::string((const char *)read_ptr, __ros_object_id_len);
    read_ptr += __ros_object_id_len;
    read_ptr = pos.deserialize(read_ptr);
    SROS_DESERIALIZE_PRIMITIVE(read_ptr, reliability);
    memcpy(&covariance[0], read_ptr, sizeof(double) * 9);
    read_ptr += sizeof(double) * 9;
    SROS_DESERIALIZE_PRIMITIVE(read_ptr, initialization);
    return read_ptr;
  }
};

typedef boost::shared_ptr<PositionMeasurement> PositionMeasurementPtr;
typedef boost::shared_ptr<PositionMeasurement const> PositionMeasurementConstPtr;


}

#endif
