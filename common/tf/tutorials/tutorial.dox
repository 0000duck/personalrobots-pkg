/** 
\page tutorial Tutorial

This is a tutorial for the tf package the main documentations is at \ref index

There are two parts 
 - @ref tutorial_sending
 - @ref tutorial_recieving

\section tutorial_sending Sending tf_messages
In the tf system nodes which have primary information about the relationship 
between two coordinate frames broadcast their best estimate for that transform
using tf::tfMessage data type over the /tf_messages topic.  Anyone can publish 
these messages on these topics, however for convenience there is a helper class to make
this quick to implement.  The helper class is the tf::TransformBroadcaster class.  

There is also a node which allows command line tool which makes sending static transforms simple.  
See @ref transform_sender. 


@section tutorial_recieving Recieving and using tf_messages
The core tf functionality is implemented in the tf::Transformer class.  
This class provides the core features and is ROS agnostic.  However in 
most use cases the integrated tf::TransformListener which inherits form 
tf::Transformer will be used.  

@subsection tutorial_listener tutorial_listener.cpp
There is an example file tf/tutorials/tutorial_listener.cpp which demonstrates
a few of the API features.  

@par basic_api The Basic tools
The most basic calls for most purposes is transform**** where **** is one 
of the geometric primitives supported by tf.  @ref datatypes 

@par zero_time Zero Time means Latest
A time of zero passed into any tf API call means provide the most
recent common timestamp possible for the request.  

@par time_travel_example Time Traveling Transforms
Often things have been observed in the past and their previous position 
in a current frame is desired.  All tf APIs have a simple and a long form.  
The long form includes not only a target frame, but a target time and a fixed 
frame, allowing the transformation of data in time. 

@par can_transform canTransform
There is a non throwing way to check whether a transform is possible.  This
is a lower computatioinal cost if the call is expected to fail frequenly.  
It does not provide as much diagnostics, and even if it returns true, that does
not guarentee a successful transform even if called immediately with the same 
parameters, so you still need a try catch block for robustness.  

@par notifier_example The MessageNotifier
The tf::MessageMotifier class is a convenient and efficient way to hold data until
transform information is available.  There is an example of data coming in 
and being held until transforms become available at the bottom of the page.  

@par running_tutorial Running the Tutorial 
Simple cd to tf/tutorials and 
\code
roslaunch complete_tutorial.launch
\endcode

@subsection common_tasks Common tasks using tf


*/