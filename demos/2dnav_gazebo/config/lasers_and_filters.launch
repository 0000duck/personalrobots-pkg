<launch>

<include file="$(find 3dnav_pr2)/launch/pr2_planning_environment.launch" />

<node pkg="mechanism_control" type="spawner.py" args="$(find pr2_experimental_controllers)/laser_tilt/laser_tilt_controller.xml" />
<node pkg="pr2_mechanism_controllers" type="send_periodic_cmd.py" args="laser_tilt_controller linear 2 .65 .25" />

<!-- filter robot self -->
<!-- reads tilt_laser_cloud_filtered and publishes robotlinks_cloud_filtered -->
<include file="$(find robot_self_filter)/start_robotlinks_filter.ros.xml"/>

<!-- laser scan -->
<!-- accumulate tilt_scan and publish by service call point_cloud_assembler_srv/build_cloud -->
<!--
<node pkg="point_cloud_assembler" type="laser_scan_assembler_srv" output="screen"  name="laser_scan_assembler">
  <remap from="scan_in" to="tilt_scan"/>
  <param name="tf_cache_time_secs" type="double" value="10.0" />
  <param name="max_scans" type="int" value="400" />
  <param name="ignore_laser_skew" type="bool" value="true" />
  <param name="fixed_frame" type="string" value="odom_combined" />
</node>
-->
<!-- accumulate point_cloud_filtered and publish by service call point_cloud_assembler_srv/build_cloud -->
<node pkg="point_cloud_assembler" type="point_cloud_assembler_srv" output="screen"  name="point_cloud_assembler_filtered">
  <remap from="scan_in" to="robotlinks_cloud_filtered"/>
  <param name="tf_cache_time_secs" type="double" value="10.0" />
  <param name="max_scans" type="int" value="400" />
  <param name="fixed_frame" type="string" value="odom_combined" />
  <param name="downsample_factor" type="int" value="2" />
</node>
<!-- at laser_tilt_controller/laser_scanner_signal,
     reads accumulated point cloud from point_cloud_assembler_srv by invoking point_cloud_assembler/build_cloud service call,
     and publishes full_cloud, which is remapped to snapshot_cloud_filtered -->
<node pkg="point_cloud_assembler" type="point_cloud_snapshotter" output="screen" name="snapshotter_filtered">
  <remap from="laser_scanner_signal" to="laser_tilt_controller/laser_scanner_signal"/>
  <remap from="build_cloud" to="point_cloud_assembler_filtered/build_cloud" />
  <remap from="full_cloud" to="snapshot_cloud_filtered" />
</node>

<!-- Filter for tilt laser shadowing/veiling -->
<node pkg="laser_scan" type="scan_to_cloud" respawn="true" machine="three" name="tilt_shadow_filter">
  <rosparam command="load" ns="scan_filters" file="$(find laser_scan)/default_scan_shadows.yaml" />
  <rosparam command="load" ns="cloud_filters" file="$(find laser_scan)/point_cloud_footprint.filters.yaml" />
  <param name="scan_topic" value="tilt_scan" />
  <param name="cloud_topic" value="tilt_scan_shadow_filtered" />
  <param name="high_fidelity" value="true" />
</node>

<!-- Filter for tilt laser scans that hit the body of the robot -->
<node pkg="robot_self_filter" type="self_filter" name="tilt_laser_self_filter" respawn="true" output="screen">

  <!-- The topic for the input cloud -->
  <remap from="cloud_in" to="tilt_scan_shadow_filtered" />

  <!-- The topic for the output cloud -->
  <remap from="cloud_out" to="tilt_scan_filtered" />

  <!-- The frame of the sensor used to obtain the data to be
    filtered; This parameter is optional. If it is not specified,
    shadow points will be considered outside -->
  <param name="sensor_frame" type="string" value="laser_tilt_link" />

  <!-- Minimum distance to sensor (for point not to be considered inside) -->
  <param name="min_sensor_dist" type="double" value="0.01" />

  <!-- The padding to be added for the body parts the robot can see -->
  <param name="self_see_padd" type="double" value="0.01" />

  <!-- The scaling to be added for the body parts the robot can see -->
  <param name="self_see_scale" type="double" value="1.0" />
  
  <!-- The names of the links the sensor can see -->
  <param name="self_see_links" type="string" value="l_upper_arm_link
                l_upper_arm_roll_link
                l_elbow_flex_link
                l_forearm_link
                l_forearm_roll_link
                l_wrist_flex_link
                l_wrist_roll_link
                l_gripper_l_finger_link
                l_gripper_l_finger_tip_link
                l_gripper_r_finger_link
                l_gripper_r_finger_tip_link
                l_shoulder_pan_link
                l_shoulder_lift_link
                r_upper_arm_link
                r_upper_arm_roll_link
                r_elbow_flex_link
                r_forearm_link
                r_forearm_roll_link
                r_wrist_flex_link
                r_wrist_roll_link
                r_gripper_l_finger_link
                r_gripper_l_finger_tip_link
                r_gripper_r_finger_link
                r_gripper_r_finger_tip_link
                r_shoulder_pan_link
                r_shoulder_lift_link
                base_laser
                base_link" />
  
</node>

<!-- Filter for base laser shadowing/veiling -->
<node pkg="laser_scan" type="scan_to_cloud" respawn="true" machine="three" name="base_shadow_filter" >
  <rosparam command="load" ns="scan_filters" file="$(find laser_scan)/default_scan_shadows.yaml" />
  <rosparam command="load" ns="cloud_filters" file="$(find laser_scan)/point_cloud_footprint.filters.yaml" />
  <param name="scan_topic" value="base_scan" />
  <param name="cloud_topic" value="base_scan_shadow_filtered" />
</node>

<!-- Filter for base laser scans that hit the body of the robot -->
<node pkg="robot_self_filter" type="self_filter" name="base_laser_self_filter" respawn="true" output="screen">

  <!-- The topic for the input cloud -->
  <remap from="cloud_in" to="base_scan_shadow_filtered" />

  <!-- The topic for the output cloud -->
  <remap from="cloud_out" to="base_scan_marking" />

  <!-- The frame of the sensor used to obtain the data to be
    filtered; This parameter is optional. If it is not specified,
    shadow points will be considered outside -->
  <param name="sensor_frame" type="string" value="base_laser" />

  <!-- Minimum distance to sensor (for point not to be considered inside) -->
  <param name="min_sensor_dist" type="double" value="0.01" />

  <!-- The padding to be added for the body parts the robot can see -->
  <param name="self_see_padd" type="double" value="0.01" />

  <!-- The scaling to be added for the body parts the robot can see -->
  <param name="self_see_scale" type="double" value="1.0" />
  
  <!-- The names of the links the sensor can see -->
  <param name="self_see_links" type="string" value="l_upper_arm_link
                l_upper_arm_roll_link
                l_elbow_flex_link
                l_forearm_link
                l_forearm_roll_link
                l_wrist_flex_link
                l_wrist_roll_link
                l_gripper_l_finger_link
                l_gripper_l_finger_tip_link
                l_gripper_r_finger_link
                l_gripper_r_finger_tip_link
                l_shoulder_pan_link
                l_shoulder_lift_link
                r_upper_arm_link
                r_upper_arm_roll_link
                r_elbow_flex_link
                r_forearm_link
                r_forearm_roll_link
                r_wrist_flex_link
                r_wrist_roll_link
                r_gripper_l_finger_link
                r_gripper_l_finger_tip_link
                r_gripper_r_finger_link
                r_gripper_r_finger_tip_link
                r_shoulder_pan_link
                r_shoulder_lift_link" />
  
</node>


</launch>
