Index: ode/src/quickstep.cpp
===================================================================
--- ode/src/quickstep.cpp	(revision 1669)
+++ ode/src/quickstep.cpp	(working copy)
@@ -33,6 +33,8 @@
 #include "lcp.h"
 #include "util.h"
 
+#include <iostream>
+
 #define ALLOCA dALLOCA16
 
 typedef const dReal *dRealPtr;
@@ -66,6 +68,9 @@
 
 #define RANDOMLY_REORDER_CONSTRAINTS 1
 
+
+//#define TIMING
+
 //****************************************************************************
 // special matrix multipliers
 
@@ -142,7 +147,7 @@
 
 
 // compute out = inv(M)*J'*in.
-#if 0
+#if WARM_STARTING
 static void multiply_invM_JT (int m, int nb, dRealMutablePtr iMJ, int *jb,
 	dRealMutablePtr in, dRealMutablePtr out)
 {
@@ -589,6 +594,8 @@
 	// frame, and compute the rotational force and add it to the torque
 	// accumulator. I and invI are a vertical stack of 3x4 matrices, one per body.
         dRealAllocaArray (invI,3*4*nb);
+        dRealAllocaArray (tmpI,3*4*nb);
+        dRealAllocaArray (tmpM,1*4*nb);
 	for (i=0; i<nb; i++) {
 		dMatrix3 tmp;
 
@@ -596,6 +603,12 @@
 		dMULTIPLY2_333 (tmp,body[i]->invI,body[i]->posr.R);
 		dMULTIPLY0_333 (invI+i*12,body[i]->posr.R,tmp);
 
+		memcpy (tmpI+i*12, body[i]->mass.I,3*4*sizeof(dReal));
+		tmpM[i*4+0] = body[i]->mass.mass;
+		tmpM[i*4+1] = body[i]->mass.c[0];
+		tmpM[i*4+2] = body[i]->mass.c[1];
+		tmpM[i*4+3] = body[i]->mass.c[2];
+
         if (body[i]->flags & dxBodyGyroscopic) {
             dMatrix3 I;
             // compute inertia tensor in global frame
@@ -760,6 +773,87 @@
 		dRealAllocaArray (cforce,nb*6);
 		SOR_LCP (m,nb,J,jb,body,invI,lambda,cforce,rhs,lo,hi,cfm,findex,&world->qs);
 
+#ifdef TIMING
+		std::cout << " m: total constraint dimention " << m
+		          << " nb: number of bounded variables " << nb
+		          << " nub: number of unbounded variables " << nb
+		          << " jb: array of body numbers for each joint row " << jb
+		          << " lo " << lo
+		          << " hi " << hi
+		          << " findex " << findex
+                          << std::endl;
+
+                FILE* fJ = fopen("/tmp/J.mat","a");
+		//std::cout << " J " << J << std::endl;
+                fprintf(fJ,"\n");
+                dPrintMatrix(J,m,12,"%10.4f",fJ);
+                fclose(fJ);
+
+                FILE* finvI = fopen("/tmp/invI.mat","a");
+		//std::cout << " invI " << invI << std::endl;
+                fprintf(finvI,"\n");
+                dPrintMatrix(invI,3*nb,4,"%10.4f",finvI);
+                fclose(finvI);
+
+                FILE* ftmpI = fopen("/tmp/tmpI.mat","a");
+		//std::cout << " tmpI " << tmpI << std::endl;
+                fprintf(ftmpI,"\n");
+                dPrintMatrix(tmpI,3*nb,4,"%10.4f",ftmpI);
+                fclose(ftmpI);
+
+                FILE* ftmpM = fopen("/tmp/tmpM.mat","a");
+		//std::cout << " tmpM " << tmpM << std::endl;
+                fprintf(ftmpM,"\n");
+                dPrintMatrix(tmpM,nb,4,"%10.4f",ftmpM);
+                fclose(ftmpM);
+
+                FILE* fc = fopen("/tmp/c.mat","a");
+		//std::cout << " c " << c << std::endl;
+                fprintf(fc,"\n");
+                dPrintMatrix(c,1,m,"%10.4f",fc);
+                fclose(fc);
+
+                FILE* flambda = fopen("/tmp/lambda.mat","a");
+		//std::cout << " lambda " << lambda << std::endl;
+                fprintf(flambda,"\n");
+                dPrintMatrix(lambda,1,m,"%10.4f",flambda);
+                fclose(flambda);
+
+                FILE* fcforce = fopen("/tmp/cforce.mat","a");
+                fprintf(fcforce,"\n");
+		//std::cout << " cforce " << cforce << std::endl;
+                dPrintMatrix(cforce,nb,6,"%10.4f",fcforce);
+                fclose(fcforce);
+
+                FILE* frhs = fopen("/tmp/rhs.mat","a");
+		//std::cout << " rhs " << rhs << std::endl;
+                fprintf(frhs,"\n");
+                dPrintMatrix(rhs,1,m,"%10.4f",frhs);
+                fclose(frhs);
+
+                // constraint forc mixing vector
+                FILE* flo = fopen("/tmp/lo.mat","a");
+		//std::cout << " lo " << lo << std::endl;
+                fprintf(flo,"\n");
+                dPrintMatrix(lo,1,m,"%10.4f",flo);
+                fclose(flo);
+
+                // constraint forc mixing vector
+                FILE* fhi = fopen("/tmp/hi.mat","a");
+		//std::cout << " hi " << hi << std::endl;
+                fprintf(fhi,"\n");
+                dPrintMatrix(hi,1,m,"%10.4f",fhi);
+                fclose(fhi);
+
+                // constraint forc mixing vector
+                FILE* fcfm = fopen("/tmp/cfm.mat","a");
+		//std::cout << " cfm " << cfm << std::endl;
+                fprintf(fcfm,"\n");
+                dPrintMatrix(cfm,1,m,"%10.4f",fcfm);
+                fclose(fcfm);
+#endif
+
+
 #ifdef WARM_STARTING
 		// save lambda for the next iteration
 		//@@@ note that this doesn't work for contact joints yet, as they are
