/* auto-generated by genmsg_cpp from /u/ethand/ros/ros-pkg/sandbox/follower/msg/WaitActionState.msg.  Do not edit! */
#ifndef FOLLOWER_WAITACTIONSTATE_H
#define FOLLOWER_WAITACTIONSTATE_H

#include <string>
#include <vector>
#include "ros/message.h"
#include "ros/time.h"

#include "roslib/Header.h"
#include "robot_actions/ActionStatus.h"
#include "follower/WaitActionGoal.h"
#include "std_msgs/Empty.h"

namespace follower
{

//! \htmlinclude WaitActionState.msg.html

class WaitActionState : public ros::Message
{
public:
  typedef boost::shared_ptr<WaitActionState> Ptr;
  typedef boost::shared_ptr<WaitActionState const> ConstPtr;

  roslib::Header header;
  robot_actions::ActionStatus status;
  follower::WaitActionGoal goal;
  std_msgs::Empty feedback;

  WaitActionState() : ros::Message()
  {
  }
  WaitActionState(const WaitActionState &copy) : ros::Message(),
    header(copy.header),
    status(copy.status),
    goal(copy.goal),
    feedback(copy.feedback)
  {
    (void)copy;
  }
  WaitActionState &operator =(const WaitActionState &copy)
  {
    if (this == &copy)
      return *this;
    header = copy.header;
    status = copy.status;
    goal = copy.goal;
    feedback = copy.feedback;
    return *this;
  }
  virtual ~WaitActionState() 
  {
  }
  inline static std::string __s_getDataType() { return std::string("follower/WaitActionState"); }
  inline static std::string __s_getMD5Sum() { return std::string("3da8cfb44ffcd3ffb1b26035cdd0dbb5"); }
  inline static std::string __s_getMessageDefinition()
  {
    return std::string(
    "Header header\n"
    "robot_actions/ActionStatus status\n"
    "follower/WaitActionGoal goal\n"
    "std_msgs/Empty feedback\n"
    "================================================================================\n"
    "MSG: roslib/Header\n"
    "#Standard metadata for higher-level flow data types\n"
    "#sequence ID: consecutively increasing ID \n"
    "uint32 seq\n"
    "#Two-integer timestamp that is expressed as:\n"
    "# * stamp.secs: seconds (stamp_secs) since epoch\n"
    "# * stamp.nsecs: nanoseconds since stamp_secs\n"
    "# time-handling sugar is provided by the client library\n"
    "time stamp\n"
    "#Frame this data is associated with\n"
    "# 0: no frame\n"
    "# 1: global frame\n"
    "string frame_id\n"
    "\n"
    "================================================================================\n"
    "MSG: robot_actions/ActionStatus\n"
    "# This message defines the expected format for robot action status messages\n"
    "# Embed this in the feedback state message of robot actions\n"
    "\n"
    "# The action is inactive, and has just been reset.\n"
    "byte RESET=0\n"
    "\n"
    "# The action has successfuly completed and is now inactive\n"
    "byte SUCCESS=1\n"
    "\n"
    "# The action has failed and given up. It is now inactive\n"
    "byte ABORTED=2\n"
    "\n"
    "# The action has been preempted. It is now inactive\n"
    "byte PREEMPTED=3\n"
    "\n"
    "# The action is active to accomplish a requested goal\n"
    "byte ACTIVE=4\n"
    "\n"
    "# Status of the controller = {UNDEFINED, SUCCESS, ABORTED, PREEMPTED, ACTIVE}\n"
    "byte value\n"
    "\n"
    "#Comment for debug\n"
    "string comment\n"
    "================================================================================\n"
    "MSG: follower/WaitActionGoal\n"
    "int32 num_events\n"
    "string topic_name\n"
    "\n"
    "================================================================================\n"
    "MSG: std_msgs/Empty\n"
    "\n"
    "\n"
    "\n"
    );
  }
  inline virtual const std::string __getDataType() const { return __s_getDataType(); }
  inline virtual const std::string __getMD5Sum() const { return __s_getMD5Sum(); }
  inline virtual const std::string __getMessageDefinition() const { return __s_getMessageDefinition(); }
  inline uint32_t serializationLength() const
  {
    unsigned __l = 0;
    __l += header.serializationLength(); // header
    __l += status.serializationLength(); // status
    __l += goal.serializationLength(); // goal
    __l += feedback.serializationLength(); // feedback
    return __l;
  }
  virtual uint8_t *serialize(uint8_t *write_ptr, uint32_t seq) const
  {
    roslib::Header _ser_header = header;
    bool __reset_seq = (header.seq == 0);
    if (__reset_seq) _ser_header.seq = seq;
    bool __reset_timestamp = header.stamp.is_zero();
    if (__reset_timestamp)
      _ser_header.stamp = ros::Time::now();
    write_ptr = _ser_header.serialize(write_ptr, seq);
    write_ptr = status.serialize(write_ptr, seq);
    write_ptr = goal.serialize(write_ptr, seq);
    write_ptr = feedback.serialize(write_ptr, seq);
    return write_ptr;
  }
  virtual uint8_t *deserialize(uint8_t *read_ptr)
  {
    read_ptr = header.deserialize(read_ptr);
    read_ptr = status.deserialize(read_ptr);
    read_ptr = goal.deserialize(read_ptr);
    read_ptr = feedback.deserialize(read_ptr);
    return read_ptr;
  }
};

typedef boost::shared_ptr<WaitActionState> WaitActionStatePtr;
typedef boost::shared_ptr<WaitActionState const> WaitActionStateConstPtr;


}

#endif
