#!/usr/bin/env python
##############################################################################
# dbviewer
# This program allows a user to view and search a EUROPA token network.
##############################################################################

import sys
import csv
import copy
import re
import os
import StringIO

import gtk
import gtk.gdk

# Add local python path
sys.path.insert(0, os.path.abspath("./ext"))

# GvGen for generating graphviz dot files
from gvgen import *

# XDot for rendering graphviz dot files
import xdot

# GTKCodeBuffer for doing syntax hilighting for NDDL file display
from gtkcodebuffer import CodeBuffer, SyntaxLoader, add_syntax_path

# Initialize dictionaries
slots = {}
tokens = {}
rules = {}
vars = {}
rule_src = {}

# Gui dictionaries
prop_windows = {}
srccode_windows = {}
search_window = None
control_window = None
window = {}

# Graph structures
graph = None

# Global status
log_path = ""
data_path = ""
tick = 0
progress = None

# Precompiled regex
number_bound_regex = re.compile("\[*([^\]]+)\]*")

##############################################################################
# ProgressTracker
#   This class tracks the prorgess of the currently active task.
##############################################################################

class ProgressTracker():
  def __init__(self):
    self.total_steps = 0.0
    self.current_step = 0.0

  def reset(self):
    self.current_step = 0.0

  def total(self,total_steps):
    self.total_steps = float(total_steps)

  def step(self):
    self.current_step = self.current_step + 1.0

  def status(self):
    return self.current_step/self.total_steps


##############################################################################
# MyDotWindow
#   This window allows the user to browse and interact with the token network.
##############################################################################

class MyDotWindow(xdot.DotWindow):
  def __init__(self):
    xdot.DotWindow.__init__(self)
    self.set_title("TREX DbViewer")
    self.widget.connect('clicked', self.on_node_clicked)
    self.set_size_request(1500,500)
    self.set_position(gtk.WIN_POS_CENTER)

  def on_node_clicked(self, widget, userdata, event):
    if prop_windows.has_key(userdata):
      prop_win = prop_windows[userdata]
      prop_win.present()	
    else:
      prop_win = PropertyWindow(userdata)
      prop_windows[userdata] = prop_win
      prop_win.show()

    return True

##############################################################################
# SrccodeWindow
#   This window provides a user with a source code view.
##############################################################################

class SrccodeWindow(gtk.Window):
  def __init__(self,rule_name):
    super(SrccodeWindow,self).__init__()

    # Store the rule name
    self.rule_name = rule_name

    # Create the syntax hilighter and code buffer
    lang = SyntaxLoader("cpp")
    buff = CodeBuffer(lang=lang)

    scr = gtk.ScrolledWindow()
    self.add(scr)
    scr.add(gtk.TextView(buff))
	    
    # Get the source file path, and start line
    src_path = rule_src[rule_name][0]
    src_line_start = int(rule_src[rule_name][1])-1

    # Open the source file
    src_file = open(src_path,'r')
    src_file_lines = src_file.readlines()
    src_line_end = len(src_file_lines)
    
    # Find the line on which the next rule is defined
    for line in range(src_line_start+1,len(src_file_lines)):
      if src_file_lines[line].find("::") != -1:
	src_line_end = line;
	break

    # Display the source code of just this rule
    srccode = "".join(src_file_lines[src_line_start:src_line_end])

    buff.set_text(srccode)
    self.set_title(src_path)
    self.set_default_size(400,400)
    self.set_position(gtk.WIN_POS_CENTER)

    self.connect("destroy", self.on_destroy)

    self.show_all()

  def on_destroy(self,widget):
    del srccode_windows[self.rule_name]

##############################################################################
# PropertyWindow
#   This window provides a user with a list of token or rule variables.
#   If available, it has a button which will spawn a code view window with
#   the source code that produced this rule or token.
##############################################################################

class PropertyWindow(gtk.Window):
  def __init__(self,userdata):
    super(PropertyWindow,self).__init__()

    self.userdata = userdata
    self.key = 0

    self.set_size_request(500, 400)
    self.set_position(gtk.WIN_POS_CENTER)

    self.connect("destroy", self.on_destroy)

    self.entity_type = (userdata.split(':')[0])
    self.key = int(userdata.split(':')[1])

    if self.entity_type == "Token":
      self.entity = tokens[self.key]
    else:
      self.entity = rules[self.key]

    self.set_title(str(self.entity))
    vbox = gtk.VBox(False, 8)

    sw = gtk.ScrolledWindow()
    sw.set_shadow_type(gtk.SHADOW_ETCHED_IN)
    sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)

    vbox.pack_start(sw, True, True, 0)

    store = self.create_model()

    treeView = gtk.TreeView(store)
    treeView.connect("row-activated", self.on_activated)
    treeView.set_rules_hint(True)
    sw.add(treeView)

    self.create_columns(treeView)

    ###################################################
    hbox = gtk.HBox(False, 8)
    srccode_but = gtk.Button("View NDDL Source")
    srccode_but.connect("clicked",self.on_srccode_clicked)

    if not rule_src.has_key(self.entity.name):
      srccode_but.set_sensitive(False)

    hbox.pack_start(srccode_but, False, False, 0)
    vbox.pack_start(hbox, False, False, 0)
    ###################################################

    self.statusbar = gtk.Statusbar()
    vbox.pack_start(self.statusbar, False, False, 0)

    self.add(vbox)
    self.show_all()

  def on_destroy(self,widget):
    del prop_windows[self.userdata]

  def create_model(self):
    store = gtk.ListStore(str, str, str, str)

    for vid in self.entity.vars:
      var = vars[vid]
      store.append([ vid, var.type, var.name, var.values])
    return store

  def create_columns(self, treeView):
    rendererText = gtk.CellRendererText()
    column = gtk.TreeViewColumn("Key", rendererText, text=0)
    column.set_sort_column_id(0)    
    treeView.append_column(column)
    
    rendererText = gtk.CellRendererText()
    column = gtk.TreeViewColumn("Type", rendererText, text=1)
    column.set_sort_column_id(1)
    treeView.append_column(column)

    rendererText = gtk.CellRendererText()
    column = gtk.TreeViewColumn("Name", rendererText, text=2)
    column.set_sort_column_id(2)
    treeView.append_column(column)

    rendererText = gtk.CellRendererText()
    column = gtk.TreeViewColumn("Value", rendererText, text=3)
    column.set_sort_column_id(3)
    treeView.append_column(column)

  def on_activated(self, widget, row, col):
    model = widget.get_model()
    text = model[row][0] + ", " + model[row][1] + ", " + model[row][2]
    self.statusbar.push(0, text)

  def on_srccode_clicked(self, widget):
    if srccode_windows.has_key(self.entity.name):
      srccode_win = srccode_windows[self.entity.name]
      srccode_win.present()	
    else:
      srccode_win = SrccodeWindow(self.entity.name)
      srccode_windows[self.entity.name] = srccode_win
      srccode_win.show()

##############################################################################
# SearchWindow
#   This window provides a user with a search field that can be used to either
#   string or regex match across the graph.
##############################################################################

class SearchWindow(gtk.Window):
  def __init__(self):
    super(SearchWindow, self).__init__()
    self.set_title("Search")
    self.set_size_request(400, 50)
    #self.set_position(gtk.WIN_POS_CENTER)

    vbox = gtk.VBox(False, 8)

    ################################################
    self.search_entry = gtk.Entry()
    self.search_entry.set_activates_default(True)
    search_but = gtk.Button("String")
    search_but.set_flags(gtk.CAN_DEFAULT)
    self.set_default(search_but)

    search_regex_but = gtk.Button("REGEX")
    search_regex_but.set_flags(gtk.CAN_DEFAULT)

    search_but.connect("clicked",self.search_string)
    search_regex_but.connect("clicked",self.search_regex)
    
    search_hbox = gtk.HBox(False,4)
    search_hbox.pack_start(self.search_entry, True, True, 0)

    search_hbox.pack_end(search_but, False, False, 0)
    search_hbox.pack_end(search_regex_but, False, False, 0)

    vbox.pack_start(search_hbox, False, False, 4)
    
    ################################################
    timeline_check = gtk.CheckButton("Timelines")
    token_check = gtk.CheckButton("Tokens")
    rule_check = gtk.CheckButton("Rules")
    variable_check = gtk.CheckButton("Variables")

    timeline_check.connect("clicked",self.toggle_timeline)
    token_check.connect("clicked",self.toggle_timeline)
    rule_check.connect("clicked",self.toggle_timeline)
    variable_check.connect("clicked",self.toggle_timeline)

    scope_frame = gtk.Frame("Scope")

    scope_vbox = gtk.HBox(True,2)

    scope_vbox.pack_end(timeline_check,False,False,0)
    scope_vbox.pack_end(token_check,False,False,0)
    scope_vbox.pack_end(rule_check,False,False,0)
    scope_vbox.pack_end(variable_check,False,False,0)

    scope_frame.add(scope_vbox)
    #vbox.pack_start(scope_frame,False,False,0)
    #################################################

    self.add(vbox)

    self.connect("destroy", self.on_destroy)
    self.show_all()
  
  def on_destroy(self,widget):
    # If we don't make a new one here, you can't anywhere else
    search_window = SearchWindow()

  def toggle_timeline(self, widget):
    search_timeline = widget.get_active()

  def toggle_token(self, widget):
    search_token = widget.get_active()

  def toggle_rule(self, widget):
    search_rule = widget.get_active()

  def toggle_variable(self, widget):
    search_variable = widget.get_active()

  def search_string(self, widget):
    # Crete a string stream
    dotfile = StringIO.StringIO()

    # Search the graph
    search_graph(dotfile,search=self.search_entry.get_text())

    # Set the dotcode
    window.set_dotcode(dotfile.getvalue())

    # Close the string stream
    dotfile.close()

  def search_regex(self, widget):
    # Compile the regular expression
    try:
      regex = re.compile(self.search_entry.get_text())
    except:
      print "ERROR: Cound not parse regular expression: \"%s\"" % self.search_entry.get_text()
      return

    # Crete a string stream
    dotfile = StringIO.StringIO()

    # Search the graph
    search_graph(dotfile,regex=regex)

    # Set the dotcode
    window.set_dotcode(dotfile.getvalue())

    # Close the string stream
    dotfile.close()

##############################################################################
# ControlWindow
#   This window provides a user with controls to step to any tick and re-run
#   the data loader.
##############################################################################

class ControlWindow(gtk.Window):
  def __init__(self):
    super(ControlWindow, self).__init__()
    self.set_title("Assembly Navigator Control")
    #self.set_size_request(300, 200)
    self.set_position(gtk.WIN_POS_CENTER)

    self.reactor_paths = []
    self.ticks = []

    vbox = gtk.VBox(False, 8)

    ################################################
    source_frame = gtk.Frame("Source: ")
    source_table = gtk.Table(2,2,homogeneous=False)

    self.path_chooser = gtk.Entry()
    self.path_chooser.connect("changed",self.on_path_change)
    path_label = gtk.Label("Path: ")

    halign = gtk.Alignment(1,0.5,0,0.5)
    halign.add(path_label)

    source_table.attach(halign, 0,1,0,1, gtk.FILL, gtk.FILL,0,0)
    source_table.attach(self.path_chooser, 1,2,0,1, gtk.FILL|gtk.EXPAND, gtk.SHRINK)

    self.reactor_chooser = gtk.combo_box_new_text()

    reactor_label = gtk.Label("Reactor: ")

    source_table.attach(reactor_label, 0,1,1,2, gtk.SHRINK, gtk.SHRINK)
    source_table.attach(self.reactor_chooser, 1,2,1,2, gtk.FILL|gtk.EXPAND, gtk.SHRINK)

    padding = gtk.Alignment(1.0,0.5,1,1)
    padding.set_padding(4,4,4,4)
    padding.add(source_table)

    source_frame.add(padding)
    vbox.pack_start(source_frame, False, False, 4)

    ################################################

    tick_frame = gtk.Frame("Tick Control")

    self.tick_entry = gtk.Entry()
    self.tick_entry.set_activates_default(True)
    self.tick_entry.set_text(str(tick))
    self.go_but = gtk.Button("go:")
    self.go_but.set_flags(gtk.CAN_DEFAULT)
    self.set_default(self.go_but)
    self.go_but.connect("clicked",self.go_tick)

    self.en_but = gtk.Button(">|")
    self.fw_but = gtk.Button(">")
    self.bk_but = gtk.Button("<")
    self.st_but = gtk.Button("|<")

    self.latest_but = gtk.ToggleButton("Latest")

    self.st_but.connect("clicked",self.go_first)
    self.fw_but.connect("clicked",self.step_forward)
    self.bk_but.connect("clicked",self.step_back)
    self.en_but.connect("clicked",self.go_last)
    
    search_hbox = gtk.HBox(False,4)

    search_hbox.pack_end(self.latest_but, False, False, 0)
    search_hbox.pack_end(self.en_but, False, False, 0)
    search_hbox.pack_end(self.fw_but, False, False, 0)
    search_hbox.pack_end(self.tick_entry, True, True, 0)
    search_hbox.pack_end(self.go_but, False, False, 0)
    search_hbox.pack_end(self.bk_but, False, False, 0)
    search_hbox.pack_end(self.st_but, False, False, 0)

    padding = gtk.Alignment(1.0,0.5,1,1)
    padding.set_padding(4,4,4,4)
    padding.add(search_hbox)

    tick_frame.add(padding)
    vbox.pack_start(tick_frame, False, False, 4)
    
    ################################################

    self.statusbar = gtk.Statusbar()
    vbox.pack_end(self.statusbar, False, False, 0)

    self.add(vbox)

    self.load_log_path()
    self.load_data_path()
    self.load_ticks_path()

    self.load(self.ticks[-1])

    self.reactor_chooser.connect("changed",self.on_reactor_change)
    self.connect("destroy", self.on_destroy)
    self.connect("enter_notify_event", self.load_ticks_path)
    self.show_all()

  def on_destroy(self,widget):
    # If we don't make a new one here, you can't anywhere else
    control_window = ControlWindow()

  def load_log_path(self):
    global log_path

    self.path_chooser.set_text(log_path)

    # Try to load the reactors at the given log path
    try:
      assembly_dumps_path = os.path.join(log_path,"assembly_dumps")

      for p in self.reactor_paths:
	self.reactor_chooser.remove_text(0)

      self.reactor_paths = os.listdir(assembly_dumps_path)
      for reactor_name in self.reactor_paths:
	self.reactor_chooser.append_text(reactor_name)

      self.reactor_chooser.set_active(0)
    except:
      self.statusbar.push(0,"Failed to load reactor list from log path.")

    # Try to load the available ticks
    try:
      self.load_ticks_path()
    except:
      self.statusbar.push(0,"Failed to load any ticks from log path.")


  def load_data_path(self):
    global data_path
    try:
      data_path = os.path.join(log_path,"assembly_dumps",self.reactor_chooser.get_active_text())
    except:
      pass

  def load_ticks_path(self, widget=None, event = None):
    tick_paths = os.listdir(data_path)
    self.ticks = [int(os.path.basename(s)[4:]) for s in tick_paths if s[0:4] == "tick"]
    self.ticks.sort()
    self.update_available_buttons()

  def on_path_change(self,widget):
    global log_path
    log_path = self.path_chooser.get_text()
    self.load_log_path()

  def on_reactor_change(self,widget):
    self.load_data_path()
    self.load(tick)

  def tick_increment(self, index_inc):
    new_tick = 0
    try:
      cur_index = self.ticks.index(tick)
      new_tick = self.ticks[cur_index + index_inc]
    except:
      self.statusbar.push(0,"Tick %d not available." % (new_tick))

    return new_tick

  def go_first(self, widget):
    self.load_ticks_path()
    self.load(self.ticks[0])

  def go_last(self, widget):
    self.load_ticks_path()
    self.load(self.ticks[-1])

  def go_tick(self, widget):
    # Reload the ticks path
    self.load_ticks_path()
    self.load(self.tick_entry.get_text())

  def step_forward(self, widget):
    self.load_ticks_path()
    self.load(self.tick_increment(1))

  def step_back(self, widget):
    self.load_ticks_path()
    self.load(self.tick_increment(-1))

  def update_text(self):
    self.tick_entry.set_text(str(tick))

  def load(self,new_tick):
    global tick

    try:
      new_tick = int(new_tick)

      # Check if this tick exists
      if new_tick not in self.ticks:
	self.statusbar.push(0,"Tick %d not available." % (new_tick))
	return

      tick = new_tick
      self.update_text()
      run()
      self.statusbar.push(0,"Loaded Tick [%d] from \"%s\"" % (tick,self.reactor_chooser.get_active_text()))
    except ValueError:
      self.statusbar.push(0,"Invalid tick entry!")
    except:
      self.statusbar.push(0,"Could not load Tick [%d] from \"%s\"" % (tick,self.reactor_chooser.get_active_text()))

  def update_available_buttons(self):
    try:
      if self.ticks.index(tick) == 0:
	self.bk_but.set_sensitive(False)
	self.st_but.set_sensitive(False)
      else:
	self.bk_but.set_sensitive(True)
	self.st_but.set_sensitive(True)

      if self.ticks.index(tick) == len(self.ticks)-1:
	self.en_but.set_sensitive(False) 
	self.fw_but.set_sensitive(False)
      else:
	self.en_but.set_sensitive(True) 
	self.fw_but.set_sensitive(True)
    except:
      pass

##############################################################################
# Model Classes
#   These are used to represent the different entities inside of EUROPA
##############################################################################

class Variable():
  def __init__(self,key, token, name, domain, values, type):
    self.key = key
    self.token = token 
    self.name = name 
    self.domain = domain
    self.values = values 
    self.type = type

  def __str__(self):
    return "%s = %s (%s)" % (self.name, self.values, self.key)

  def matches(self,search=None,regex=None):
    if search:
      return str(self).find(search) != -1
    if regex:
      match = False
      match = match or regex.match(self.name)
      match = match or regex.match(str(self.token))
      match = match or regex.match(self.values)
      return match

class Slot():
  def __init__(self,id,tokens = []):
    self.id = id
    self.tokens = tokens

    self.node = None

  def __str__(self):
    return "Slot (%d)" % (self.id)

class Token():
  def __init__(self,key,slot_id,name,start_key,end_key,slot_index,token_vars):
    self.key = key
    self.name = name
    self.slot_id = slot_id
    self.slot_index = slot_index
    self.start_key = start_key
    self.end_key = end_key

    self.node = None
    self.vars = token_vars

  def __str__(self):
    return "%s (%d)" % (self.name, self.key)

  def matches(self,search=None,regex=None):
    if search:
      return str(self).find(search) != -1
    if regex:
      match = False
      match = match or regex.match(self.name)
      match = match or regex.match(str(self.key))
      return match

class Rule():
  def __init__(self,key,name,token,filename,line,slaves=[],vars=[]):
    self.key = key
    self.name = name
    self.token = token
    self.slaves = slaves
    self.vars = vars
    self.filename = filename
    self.line = line

    self.node = None

  def __str__(self):
    return "%s (%d)" % (self.name, self.key)

  def matches(self,search=None,regex=None):
    if search:
      return str(self).find(search) != -1
    if regex:
      match = False
      match = match or regex.match(self.name)
      match = match or regex.match(str(self.key))
      match = match or regex.match(str(self.token))
      return match

##############################################################################
# Hilight Functions
#   These set a given entity a style based on it's properties
##############################################################################

def hilight_token(tid):
  graph.styleApply("TokenHilight", tokens[tid].node)

def lolight_token(tid):
  global tick
  if tokens[tid].slot_id != -1:
    if tokens[tid].slot_index == 0:
      graph.styleApply("Token", tokens[tid].node)
    else:
      graph.styleApply("MergedToken", tokens[tid].node)
  else:
    graph.styleApply("InactiveToken", tokens[tid].node)

  start_bounds = number_bound_regex.findall(vars[tokens[tid].start_key].values)
  start_bounds = start_bounds[0].split(" ")

  end_bounds = number_bound_regex.findall(vars[tokens[tid].end_key].values)
  end_bounds = end_bounds[0].split(" ")

  if len(start_bounds) != 1 and float(start_bounds[1]) > tick:
    graph.styleApply("PlannedToken", tokens[tid].node)

def hilight_rule(rid):
  graph.styleApply("RuleHilight", rules[rid].node)

def lolight_rule(rid):
  graph.styleApply("Rule", rules[rid].node)

##############################################################################
# Graph Functions
# 
# hilight_graph(search=None,regex=None)
#   This iterates over all tokens anr rules, and applies the correct styles
#   to both of them, based on search criterion and object properties.
#   This accesses the global graph. Styles can be applied and re-applied in
#   GvGen without having to create a new graph
#
# search_graph(dotfile,search=None,regex=None)
#   This calls hilight_graph with the given search criteria, and then performs
#   a deep copy on the graph for generating a dot file.
#   Note that when GvGen creates a dotfile, it is actually destructive to the
#   internal structure of the graph.
#   "dotfile" is a file handle or virtual file handle to which the dotcode is
#   to be written.
# 
# populate_graph(dotfile)
#   This iterates over all structures that model the EUROPA db and
#   instantiates node in the GvGen graph for them. It then calls search_graph
#   with no search criterion and the dotfile handle that was passed to it.
#
# define_graph_styles()
#   This defines all of the relevant styles used by hilight_graph and
#   populate graph. It accesses the global GvGen graph.
##############################################################################

def hilight_graph(search=None,regex=None):
  # Search over tokens
  for tid in tokens:
    if (search and search != "" and tokens[tid].matches(search=search)) or (regex and regex != "" and tokens[tid].matches(regex=regex)):
      hilight_token(tid)
    else:
      lolight_token(tid)

      # Search token variables
      for vid in tokens[tid].vars:
	if (search and search != "" and vars[vid].matches(search=search)) or (regex and regex != "" and vars[vid].matches(regex=regex)):
	  hilight_token(tid)

  # Search over rules
  for rid in rules:
    if (search and rules[rid].matches(search=search)) or (regex and rules[rid].matches(regex=regex)):
      hilight_rule(rid)
    else:
      lolight_rule(rid)

def search_graph(dotfile,search=None,regex=None):
  hilight_graph(search,regex)

  # Copy the graph for drawing
  graph_to_draw = copy.deepcopy(graph)

  # Generate dotfile
  graph_to_draw.dot(dotfile)

def populate_graph(dotfile):
  for sid in slots:
    if sid != -1:
      slots[sid].node = graph.newItem(slots[sid]);
      graph.styleApply("Slot", slots[sid].node)

  for tid in tokens:
    if tokens[tid].slot_id != -1:
      tokens[tid].node = graph.newItem(tokens[tid],slots[tokens[tid].slot_id].node);
    else:
      tokens[tid].node = graph.newItem(tokens[tid]);

    # Set the user data to link up clickthroughs
    graph.propertyAppend(tokens[tid].node,"URL","Token:%d" % tid)

  for rid in rules:
    rules[rid].node = graph.newItem(rules[rid]);
    graph.newLink(tokens[rules[rid].token].node,rules[rid].node)
    for tid in rules[rid].slaves:
      graph.newLink(rules[rid].node,tokens[tid].node)

    # Set the user data to link up clickthroughs
    graph.propertyAppend(rules[rid].node,"URL","Rule:%d" % rid)

  # Generate the GvGen graph
  search_graph(dotfile)

def define_graph_styles():
  graph.styleAppend("Token", "shape", "rectangle")
  graph.styleAppend("Token", "style", "filled")
  graph.styleAppend("Token", "fillcolor", "#EEEEEE")

  graph.styleAppend("TokenHilight", "shape", "rectangle")
  graph.styleAppend("TokenHilight", "style", "filled")
  graph.styleAppend("TokenHilight", "color", "#8F5E03")
  graph.styleAppend("TokenHilight", "fillcolor", "#FFB223")
  graph.styleAppend("TokenHilight", "fontcolor", "#000000")

  graph.styleAppend("PlannedToken", "shape", "rectangle")
  graph.styleAppend("PlannedToken", "style", "filled")
  graph.styleAppend("PlannedToken", "fillcolor", "#666666")
  graph.styleAppend("PlannedToken", "fontcolor", "#CCCCCC")

  graph.styleAppend("MergedToken", "shape", "rectangle")
  graph.styleAppend("MergedToken", "style", "filled")
  graph.styleAppend("MergedToken", "fillcolor", "#CCCCCC")
  graph.styleAppend("MergedToken", "fontcolor", "#444444")

  graph.styleAppend("InactiveToken", "shape", "rectangle")
  graph.styleAppend("InactiveToken", "style", "filled")
  graph.styleAppend("InactiveToken", "fillcolor", "#FFFFFF")
  graph.styleAppend("InactiveToken", "fontcolor", "#444444")

  graph.styleAppend("Rule", "shape", "diamond")
  graph.styleAppend("Rule", "style", "rounded,filled")
  graph.styleAppend("Rule", "fillcolor", "#95AEBC")
  graph.styleAppend("Rule", "color", "#476170")

  graph.styleAppend("RuleHilight", "shape", "diamond")
  graph.styleAppend("RuleHilight", "style", "rounded,filled")
  graph.styleAppend("RuleHilight", "color", "#8F5E03")
  graph.styleAppend("RuleHilight", "fillcolor", "#FFB223")
  graph.styleAppend("RuleHilight", "fontcolor", "#000000")

  graph.styleAppend("Slot", "shape", "rectangle")
  graph.styleAppend("Slot", "style", "rounded,filled")
  graph.styleAppend("Slot", "color", "#CCCCCC")
  graph.styleAppend("Slot", "fontcolor", "#444444")


##############################################################################
# load_data()
#   This reads in the data from the global data_path and tick. It populates
#   the model dictionaries.
##############################################################################

def load_data():
  global slots
  global tokens
  global rules
  global vars
  global rule_src

  slots = {}
  tokens = {}
  rules = {}
  vars = {}
  rule_src = {}

  # Generate the step path
  step_path = os.path.join(data_path, "tick%s" % tick, "tick%s" % tick)

  # Read in rule source code paths
  rule_src_reader = csv.reader(open(os.path.join(data_path,"rules")),delimiter='\t')

  line_regex = re.compile("^(.+)\,([0-9]+)$")
  for row in rule_src_reader:
    rule_name = row[1]
    rule_path_line_str = row[2]

    rule_path_line = line_regex.findall(rule_path_line_str)

    rule_src[rule_name] = rule_path_line[0]

  # Read in tokens
  tokens_reader = csv.reader(open("%s.tokens" % step_path),delimiter='\t')
  for row in tokens_reader:
    token_key = int(row[0])
    slot_id = int(["-1",row[2]][row[2]!='\N'])
    start_key = int(row[7])
    end_key = int(row[8])
    predicate_name = row[11]
    variable_keys = row[15]
    slot_index = int(row[16])

    # Append variable keys
    #token_vars = [int(var) for var in variable_keys.split(':') if var != '' and var != '\N'];

    tokens[token_key] = Token(token_key,slot_id,predicate_name,start_key,end_key,slot_index,[])

    # Append token key to slot
    if slots.has_key(slot_id):
      slots[slot_id].tokens.append(token_key)
    else:
      slots[slot_id] = Slot(slot_id,[token_key])

  # Read in rule instances
  rule_instances_reader = csv.reader(open("%s.ruleInstances" % step_path),delimiter='\t')
  
  for row in rule_instances_reader:
    rule_key = int(row[0])
    rule_name = row[3]
    rule_token_key = int(row[4])
    slave_token_keys = row[5]
    variable_keys = row[6]

    rule_filename = rule_src[rule_name][0]
    rule_line = rule_src[rule_name][1]
    
    # Get rule slaves
    rule_slaves = [int(slave) for slave in slave_token_keys.split(',') if slave != '' and slave != '\N'];
    #rule_vars = [int(var) for var in variable_keys.split(',') if var != '' and var != '\N'];

    rules[rule_key] = Rule(rule_key, rule_name, rule_token_key, rule_filename, rule_line, rule_slaves, [])

  # Read in variables
  vars_reader = csv.reader(open("%s.variables" % step_path),delimiter='\t')
  for row in vars_reader:
    var_key = int(row[0])
    var_token = int(row[2])
    var_name = row[3]
    var_domain = row[4]
    var_values = row[5]
    if var_values == '\N':
      var_values = "[%s %s]" % (row[7], row[8])
    var_type = row[9]

    vars[var_key] = Variable(var_key,var_token,var_name,var_domain, var_values, var_type)

    # Add variable reference to token
    if var_type != "MEMBER_VAR":
      if var_type == "RULE_VAR":
	rules[var_token].vars.append(var_key)
      else:
	tokens[var_token].vars.append(var_key)

##############################################################################
# run()
#   This loads the data, creates a new graph, defines the styles, populates
#   it, and then passes the graph to the XDot window.
#   
#   This function can be used repeatedly to reload different datasets.
##############################################################################
def run():
  # set task progress
  global progress
  progress.reset()
  progress.total(5)

  # load data
  load_data()
  progress.step()

  # Create a new graph with GvGen
  global graph
  graph = GvGen()
  progress.step()

  # Create graph styles
  define_graph_styles()
  progress.step()

  # Populate graph
  dotfile = StringIO.StringIO()
  populate_graph(dotfile)
  progress.step()

  # Pass the graph to XDot
  window.set_dotcode(dotfile.getvalue())
  dotfile.close()
  progress.step()

##############################################################################
# main()
#   This instantiates all of the GUI windows, and loads the data from command
#   line arguments.
##############################################################################
def main():
  global log_path
  global tick

  usagestr = """Usage: dbviewer path [tick]
    path: a path to a TREX log file
    tick: a tick during which the assemblies were dumped to disk"""

  # Check arguments
  if len(sys.argv) < 2:
    print usagestr
    return

  # Read in arguments
  log_path = sys.argv[1]

  if len(sys.argv) == 3:
    tick = int(sys.argv[2])
  else:
    tick = 0

  # Spawn the progress tracked
  global progress
  progress = ProgressTracker()

  # Spawn a search window
  global search_window
  search_window = SearchWindow()

  # Spawn the dot window
  global window
  window = MyDotWindow()
  window.set_filter('dot')
  window.connect('destroy', gtk.main_quit)

  # Spawn a control window
  global control_window
  control_window = ControlWindow()

  # Run gtk
  gtk.main()

if __name__ == '__main__':
  main()
