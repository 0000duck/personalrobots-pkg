#!/usr/bin/env python
##############################################################################
# dbviewer
# This program allows a user to view and search a EUROPA token network.
##############################################################################

import sys
import csv
import copy
import re
import os
import StringIO

import gtk
import gtk.gdk

# Add local python path
sys.path.insert(0, os.path.abspath("./ext"))

# GvGen for generating graphviz dot files
from gvgen import *

# XDot for rendering graphviz dot files
import xdot

# GTKCodeBuffer for doing syntax hilighting for NDDL file display
from gtkcodebuffer import CodeBuffer, SyntaxLoader, add_syntax_path
add_syntax_path(os.path.abspath("./ext/PyGTKCodeBuffer-1.0-RC2/syntax"))


# Initialize dictionaries
slots = {}
tokens = {}
rules = {}
vars = {}
rule_src = {}

# Gui dictionaries
prop_windows = {}
srccode_windows = {}
search_window = None
control_window = None
window = {}

# Graph structures
graph = None

# Global status
log_path = ""
data_path = ""
tick = 0
progress = None

# Precompiled regex
number_bound_regex = re.compile("\[*([^\]]+)\]*")

##############################################################################
# ProgressTracker
#   This class tracks the prorgess of the currently active task.
##############################################################################

class ProgressTracker():
  def __init__(self):
    self.total_steps = 0.0
    self.current_step = 0.0

  def reset(self):
    self.current_step = 0.0

  def total(self,total_steps):
    self.total_steps = float(total_steps)

  def step(self):
    self.current_step = self.current_step + 1.0

  def status(self):
    return self.current_step/self.total_steps


##############################################################################
# MyDotWindow
#   This window allows the user to browse and interact with the token network.
##############################################################################

class MyDotWindow(xdot.DotWindow):
  def __init__(self):
    xdot.DotWindow.__init__(self)
    self.set_title("TREX DbViewer")
    self.widget.connect('clicked', self.on_node_clicked)
    self.set_size_request(1500,500)
    self.set_position(gtk.WIN_POS_CENTER)

  def on_node_clicked(self, widget, userdata, event):
    if prop_windows.has_key(userdata):
      prop_win = prop_windows[userdata]
      prop_win.present()	
    else:
      prop_win = PropertyWindow(userdata)
      prop_windows[userdata] = prop_win
      prop_win.show()

    return True

  def clear(self):
    dotfile = StringIO.StringIO()
    graph_to_clear = GvGen()
    try:
      graph_to_clear.dot(dotfile)
      self.set_dotcode(dotfile.getvalue())
    except:
      pass
    dotfile.close()

  def draw(self):
    # Crete a string stream
    dotfile = StringIO.StringIO()

    # Copy the graph for drawing
    graph_to_draw = copy.deepcopy(graph)

    # Generate dotfile
    graph_to_draw.dot(dotfile)

    # Set the dotcode
    try:
      window.set_dotcode(dotfile.getvalue())
    except:
      control_window.statusbar.push(0,"No nodes to view at tick [%s]",tick)
    # Close the string stream
    dotfile.close()


##############################################################################
# SrccodeWindow
#   This window provides a user with a source code view.
##############################################################################

class SrccodeWindow(gtk.Window):
  def __init__(self,rule_name):
    super(SrccodeWindow,self).__init__()

    # Store the rule name
    self.rule_name = rule_name

    # Create the syntax hilighter and code buffer
    lang = SyntaxLoader("cpp")
    buff = CodeBuffer(lang=lang)

    scr = gtk.ScrolledWindow()
    self.add(scr)
    scr.add(gtk.TextView(buff))
	    
    # Get the source file path, and start line
    src_path = rule_src[rule_name][0]
    src_line_start = int(rule_src[rule_name][1])-1

    # Open the source file
    src_file = open(src_path,'r')
    src_file_lines = src_file.readlines()
    src_line_end = len(src_file_lines)
    
    # Find the line on which the next rule is defined
    for line in range(src_line_start+1,len(src_file_lines)):
      if src_file_lines[line].find("::") != -1:
	src_line_end = line;
	break

    # Display the source code of just this rule
    srccode = "".join(src_file_lines[src_line_start:src_line_end])

    buff.set_text(srccode)
    self.set_title(src_path)
    self.set_default_size(400,400)
    self.set_position(gtk.WIN_POS_CENTER)

    self.connect("destroy", self.on_destroy)

    self.show_all()

  def on_destroy(self,widget):
    del srccode_windows[self.rule_name]

##############################################################################
# PropertyWindow
#   This window provides a user with a list of token or rule variables.
#   If available, it has a button which will spawn a code view window with
#   the source code that produced this rule or token.
##############################################################################

class PropertyWindow(gtk.Window):
  def __init__(self,userdata):
    super(PropertyWindow,self).__init__()

    self.userdata = userdata
    self.key = 0

    self.set_size_request(500, 400)
    self.set_position(gtk.WIN_POS_CENTER)

    self.connect("destroy", self.on_destroy)

    self.entity_type = (userdata.split(':')[0])
    self.key = int(userdata.split(':')[1])

    if self.entity_type == "Token":
      self.entity = tokens[self.key]
    else:
      self.entity = rules[self.key]

    self.set_title(str(self.entity))
    vbox = gtk.VBox(False, 8)

    sw = gtk.ScrolledWindow()
    sw.set_shadow_type(gtk.SHADOW_ETCHED_IN)
    sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)

    vbox.pack_start(sw, True, True, 0)

    store = self.create_model()

    treeView = gtk.TreeView(store)
    treeView.connect("row-activated", self.on_activated)
    treeView.set_rules_hint(True)
    sw.add(treeView)

    self.create_columns(treeView)

    ###################################################


    ###################################################


    if rule_src.has_key(self.entity.name):
      rule_name = self.entity.name

      # Create the syntax hilighter and code buffer
      lang = SyntaxLoader("cpp")
      buff = CodeBuffer(lang=lang)

      hbox = gtk.HBox(False, 8)
      scr = gtk.ScrolledWindow()
      scr.add(gtk.TextView(buff))
      scr.set_shadow_type(gtk.SHADOW_ETCHED_IN)
      scr.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)	      

      # Get the source file path, and start line
      src_path = rule_src[rule_name][0]
      src_line_start = int(rule_src[rule_name][1])-1

      # Open the source file
      src_file = open(src_path,'r')
      src_file_lines = src_file.readlines()
      src_line_end = len(src_file_lines)
      
      # Find the line on which the next rule is defined
      for line in range(src_line_start+1,len(src_file_lines)):
	if src_file_lines[line].find("::") != -1:
	  src_line_end = line;
	  break

      # Display the source code of just this rule
      srccode = "".join(src_file_lines[src_line_start:src_line_end])

      buff.set_text(srccode)
      hbox.pack_start(scr, True, True, 0)
      vbox.pack_start(hbox, True, True, 0)

    ##################################################

    self.statusbar = gtk.Statusbar()
    vbox.pack_start(self.statusbar, False, False, 0)

    self.add(vbox)
    self.show_all()

  def on_destroy(self,widget):
    del prop_windows[self.userdata]

  def create_model(self):
    store = gtk.ListStore(str, str, str, str)

    for var in self.entity.vars:
      store.append([ var.key, var.type, var.name, var.values])
    return store

  def create_columns(self, treeView):
    rendererText = gtk.CellRendererText()
    column = gtk.TreeViewColumn("Key", rendererText, text=0)
    column.set_sort_column_id(0)    
    treeView.append_column(column)
    
    rendererText = gtk.CellRendererText()
    column = gtk.TreeViewColumn("Type", rendererText, text=1)
    column.set_sort_column_id(1)
    treeView.append_column(column)

    rendererText = gtk.CellRendererText()
    column = gtk.TreeViewColumn("Name", rendererText, text=2)
    column.set_sort_column_id(2)
    treeView.append_column(column)

    rendererText = gtk.CellRendererText()
    column = gtk.TreeViewColumn("Value", rendererText, text=3)
    column.set_sort_column_id(3)
    treeView.append_column(column)

  def on_activated(self, widget, row, col):
    model = widget.get_model()
    text = model[row][0] + ", " + model[row][1] + ", " + model[row][2]
    self.statusbar.push(0, text)

  def on_srccode_clicked(self, widget):
    if srccode_windows.has_key(self.entity.name):
      srccode_win = srccode_windows[self.entity.name]
      srccode_win.present()	
    else:
      srccode_win = SrccodeWindow(self.entity.name)
      srccode_windows[self.entity.name] = srccode_win
      srccode_win.show()

##############################################################################
# SearchWindow
#   This window provides a user with a search field that can be used to either
#   string or regex match across the graph.
##############################################################################

class SearchWindow(gtk.Window):
  def __init__(self):
    super(SearchWindow, self).__init__()
    self.set_title("Search Filters")
    self.set_size_request(400, 300)
    #self.set_position(gtk.WIN_POS_CENTER)

    vbox = gtk.VBox(False, 8)
    ###################################################
    sw = gtk.ScrolledWindow()
    sw.set_shadow_type(gtk.SHADOW_ETCHED_IN)
    sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)


    store = self.create_model()

    self.filter_view = gtk.TreeView(store)
    self.filter_view.connect("row-activated", self.on_activated)
    self.filter_view.connect('key_press_event', self.on_key_press)
    self.filter_view.set_rules_hint(True)
    sw.add(self.filter_view)

    self.create_columns(self.filter_view)
    vbox.pack_start(sw, True, True, 0)

    ################################################
    filter_hbox = gtk.HBox(False,4)

    add_but = gtk.Button("Add")
    add_but.connect("clicked",self.add_filter)

    rep_but = gtk.Button("Replace")
    rep_but.connect("clicked",self.replace_filter)
    rep_but.set_flags(gtk.CAN_DEFAULT)

    self.filter_entry = gtk.Entry()
    self.filter_entry.set_activates_default(True)
    self.set_default(rep_but)


    filter_hbox.pack_start(self.filter_entry, True, True, 0)
    filter_hbox.pack_start(rep_but, False, False, 0)
    filter_hbox.pack_start(add_but, False, False, 0)

    vbox.pack_start(filter_hbox, False, False, 4)
    
    #################################################

    opt_frame = gtk.Frame("Options")
    opt_table = gtk.Table(2,1,homogeneous=False)

    ignore_check = gtk.CheckButton("Ignore Case ")
    halign = gtk.Alignment(1,0.5,0,0.5)
    halign.add(ignore_check)
    opt_table.attach(halign, 0,1,0,1, gtk.FILL, gtk.FILL,0,0)

    regex_check = gtk.CheckButton("Use Regex")
    halign = gtk.Alignment(1,0.5,0,0.5)
    halign.add(regex_check)
    opt_table.attach(halign, 1,2,0,1, gtk.FILL, gtk.FILL,0,0)


    padding = gtk.Alignment(1.0,0.5,1,1)
    padding.set_padding(4,4,4,4)
    padding.add(opt_table)
    opt_frame.add(padding)

    vbox.pack_start(opt_frame, False, False, 4)

    self.add(vbox)

    self.connect("destroy", self.on_destroy)
    self.show_all()

  def add_filter(self,widget):
    filter = self.filter_entry.get_text()
    self.store.append([ True, filter])
    self.post_refilter()

  def replace_filter(self,widget):
    selection = self.filter_view.get_selection()
    model, iter = selection.get_selected()
    first_iter = self.store.get_iter_first()
    if iter:
      self.store.remove(iter)
    elif first_iter:
      self.store.remove(first_iter)
    self.add_filter(widget)

  def remove_selected_filter(self):
    selection = self.filter_view.get_selection()
    model, iter = selection.get_selected()
    if iter:
      model.remove(iter)
    self.post_refilter()

  def on_key_press(self,widget,event):
    keyname = gtk.gdk.keyval_name(event.keyval)
    if keyname == "BackSpace" or keyname == "Delete":
      self.remove_selected_filter()

  def create_model(self):
    self.store = gtk.ListStore(bool, str)
    
    self.store.append([ True, "SUCCESS"])
    self.store.append([ True, "Inactive"])

    return self.store

  def on_set_include(self, model, row):
    model[row][0] = not model[row][0]
    self.post_refilter(model)

  def create_columns(self, treeView):
    # Create checkbox column
    cell = gtk.CellRendererToggle()
    cell.set_property( 'activatable', True )
    cell.connect_object( 'toggled', self.on_set_include, self.store )

    column = gtk.TreeViewColumn("On", cell)
    column.set_sort_column_id(0)    
    column.add_attribute( cell, 'active', 0)

    treeView.append_column(column)

    # Create pattern column
    rendererText = gtk.CellRendererText()
    column = gtk.TreeViewColumn("Pattern", rendererText, text=1)
    column.set_sort_column_id(1)
    treeView.append_column(column)

  def on_activated(self, widget, row, col):
    pass
  
  def on_destroy(self,widget):
    # If we don't make a new one here, you can't anywhere else
    search_window = SearchWindow()

  def post_refilter(self,model=None):
    # Generate entity list
    filtered = tokens.values() + rules.values() 

    # Apply all enabled filters to shrink list
    enabled_patterns = [row[1] for row in self.store if row[0]]
    if len(enabled_patterns) != 0:
      for pattern in enabled_patterns:
	entities = filtered
	filtered = []
	for entity in entities:
	  if entity.matches(pattern):
	    filtered.append(entity)
	    entity.hilight()
	  else:
	    entity.lolight()
    else:
      for entity in filtered:
	entity.lolight()

    # Redraw dotcode
    window.draw()

  def search_regex(self, widget):
    # Compile the regular expression
    try:
      regex = re.compile(self.search_entry.get_text())
    except:
      print "ERROR: Cound not parse regular expression: \"%s\"" % self.search_entry.get_text()
      return

##############################################################################
# ControlWindow
#   This window provides a user with controls to step to any tick and re-run
#   the data loader.
##############################################################################

class ControlWindow(gtk.Window):
  def __init__(self):
    super(ControlWindow, self).__init__()
    self.set_title("Assembly Navigator Control")
    #self.set_size_request(300, 200)
    self.set_position(gtk.WIN_POS_CENTER)

    self.reactor_paths = []
    self.ticks = []

    vbox = gtk.VBox(False, 8)

    ################################################
    source_frame = gtk.Frame("Source: ")
    source_table = gtk.Table(2,2,homogeneous=False)


    self.fc_dialog = gtk.FileChooserDialog(
	"Select a TREX log path...",
	action=gtk.FILE_CHOOSER_ACTION_OPEN | gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER,
	buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OPEN,gtk.RESPONSE_OK))
    self.fc_dialog.set_default_response(gtk.RESPONSE_OK)
    self.fc_dialog.add_shortcut_folder(os.environ["TREX_LOG_DIR"])
    self.fc_dialog.set_filename(log_path)

    self.path_chooser = gtk.FileChooserButton(self.fc_dialog)
    self.path_chooser.connect("selection-changed",self.on_path_change)
    path_label = gtk.Label("Path: ")

    halign = gtk.Alignment(1,0.5,0,0.5)
    halign.add(path_label)

    source_table.attach(halign, 0,1,0,1, gtk.FILL, gtk.FILL,0,0)
    source_table.attach(self.path_chooser, 1,2,0,1, gtk.FILL|gtk.EXPAND, gtk.SHRINK)

    self.reactor_chooser = gtk.combo_box_new_text()

    reactor_label = gtk.Label("Reactor: ")

    source_table.attach(reactor_label, 0,1,1,2, gtk.SHRINK, gtk.SHRINK)
    source_table.attach(self.reactor_chooser, 1,2,1,2, gtk.FILL|gtk.EXPAND, gtk.SHRINK)

    padding = gtk.Alignment(1.0,0.5,1,1)
    padding.set_padding(4,4,4,4)
    padding.add(source_table)

    source_frame.add(padding)
    vbox.pack_start(source_frame, False, False, 4)

    ################################################

    tick_frame = gtk.Frame("Tick Control")

    self.tick_entry = gtk.Entry()
    self.tick_entry.set_activates_default(True)
    self.tick_entry.set_text(str(tick))
    self.go_but = gtk.Button("go:")
    self.go_but.set_flags(gtk.CAN_DEFAULT)
    self.set_default(self.go_but)
    self.go_but.connect("clicked",self.go_tick)

    self.en_but = gtk.Button(">|")
    self.fw_but = gtk.Button(">")
    self.bk_but = gtk.Button("<")
    self.st_but = gtk.Button("|<")

    self.latest_but = gtk.ToggleButton("Latest")

    self.st_but.connect("clicked",self.go_first)
    self.fw_but.connect("clicked",self.step_forward)
    self.bk_but.connect("clicked",self.step_back)
    self.en_but.connect("clicked",self.go_last)
    
    search_hbox = gtk.HBox(False,4)

    search_hbox.pack_end(self.latest_but, False, False, 0)
    search_hbox.pack_end(self.en_but, False, False, 0)
    search_hbox.pack_end(self.fw_but, False, False, 0)
    search_hbox.pack_end(self.tick_entry, True, True, 0)
    search_hbox.pack_end(self.go_but, False, False, 0)
    search_hbox.pack_end(self.bk_but, False, False, 0)
    search_hbox.pack_end(self.st_but, False, False, 0)

    padding = gtk.Alignment(1.0,0.5,1,1)
    padding.set_padding(4,4,4,4)
    padding.add(search_hbox)

    tick_frame.add(padding)
    vbox.pack_start(tick_frame, False, False, 4)
    
    ################################################

    self.statusbar = gtk.Statusbar()
    vbox.pack_end(self.statusbar, False, False, 0)

    self.add(vbox)

    self.load_log_path()
    self.load_data_path()
    self.load_ticks_path()

    # try to load the latest
    if len(self.ticks) > 0:
      self.load(self.ticks[-1])

    self.reactor_chooser.connect("changed",self.on_reactor_change)
    self.connect("destroy", self.on_destroy)
    self.connect("enter_notify_event", self.load_ticks_path)
    self.show_all()

  def on_destroy(self,widget):
    # If we don't make a new one here, you can't anywhere else
    control_window = ControlWindow()

  def on_path_change(self,widget):
    global log_path
    log_path = self.path_chooser.get_filename()
    self.load_log_path()

  def load_log_path(self):
    global log_path

    # Try to load the reactors at the given log path
    try:
      assembly_dumps_path = os.path.join(log_path,"assembly_dumps")

      for p in self.reactor_paths:
	self.reactor_chooser.remove_text(0)

      self.reactor_paths = os.listdir(assembly_dumps_path)
      for reactor_name in self.reactor_paths:
	self.reactor_chooser.append_text(reactor_name)

      self.reactor_chooser.set_active(0)
    except:
      window.clear()
      self.statusbar.push(0,"Failed to load reactor list from log path.")

    # Try to load the available ticks
    try:
      self.load_ticks_path()
    except:
      self.statusbar.push(0,"Failed to load any ticks from log path.")
      window.clear()

  def load_data_path(self):
    global data_path
    try:
      data_path = os.path.join(log_path,"assembly_dumps",self.reactor_chooser.get_active_text())
    except:
      pass

  def load_ticks_path(self, widget=None, event = None):
    try:
      tick_paths = os.listdir(data_path)
      self.ticks = [int(os.path.basename(s)[4:]) for s in tick_paths if s[0:4] == "tick"]
      self.ticks.sort()
      self.update_available_buttons()
    except:
      self.statusbar.push(0,"No data at log path yet.")

  def on_reactor_change(self,widget):
    self.load_data_path()
    self.load(tick)

  def tick_increment(self, index_inc):
    new_tick = 0
    try:
      cur_index = self.ticks.index(tick)
      new_tick = self.ticks[cur_index + index_inc]
    except:
      self.statusbar.push(0,"Tick %d not available." % (new_tick))

    return new_tick

  def go_first(self, widget):
    self.load_ticks_path()
    self.load(self.ticks[0])

  def go_last(self, widget):
    self.load_ticks_path()
    self.load(self.ticks[-1])

  def go_tick(self, widget):
    self.load_ticks_path()
    self.load(self.tick_entry.get_text())

  def step_forward(self, widget):
    self.load_ticks_path()
    self.load(self.tick_increment(1))

  def step_back(self, widget):
    self.load_ticks_path()
    self.load(self.tick_increment(-1))

  def update_available_buttons(self):
    try:
      if self.ticks.index(tick) == 0:
	self.bk_but.set_sensitive(False)
	self.st_but.set_sensitive(False)
      else:
	self.bk_but.set_sensitive(True)
	self.st_but.set_sensitive(True)

      if self.ticks.index(tick) == len(self.ticks)-1:
	self.en_but.set_sensitive(False) 
	self.fw_but.set_sensitive(False)
      else:
	self.en_but.set_sensitive(True) 
	self.fw_but.set_sensitive(True)
    except:
      pass

  def update_text(self):
    self.tick_entry.set_text(str(tick))

  def load(self,new_tick):
    global tick

    try:
      new_tick = int(new_tick)

      # Check if this tick exists
      if new_tick not in self.ticks:
	self.statusbar.push(0,"Tick %d not available." % (new_tick))
	return

      tick = new_tick
      self.update_text()

      # Load data
      load_data()

      # Create a new graph with GvGen
      global graph
      graph = GvGen()

      # Create graph styles
      define_graph_styles()

      # Populate graph
      self.populate_graph()

      # Refilter and display the data
      search_window.post_refilter()
      self.statusbar.push(0,"Loaded Tick [%d] from \"%s\"" % (tick,self.reactor_chooser.get_active_text()))
    except ValueError:
      self.statusbar.push(0,"Invalid tick entry!")
    except:
      self.statusbar.push(0,"Could not load Tick [%d] from \"%s\"" % (tick,self.reactor_chooser.get_active_text()))

  def populate_graph(self):
    for sid in slots:
      if sid != -1:
	slots[sid].node = graph.newItem(slots[sid]);
	graph.styleApply("Slot", slots[sid].node)

    for tid in tokens:
      if tokens[tid].slot_id != -1:
	tokens[tid].node = graph.newItem(tokens[tid],slots[tokens[tid].slot_id].node);
      else:
	tokens[tid].node = graph.newItem(tokens[tid]);

      # Set the user data to link up clickthroughs
      graph.propertyAppend(tokens[tid].node,"URL","Token:%d" % tid)

    for rid in rules:
      rules[rid].node = graph.newItem(rules[rid]);
      graph.newLink(rules[rid].token.node,rules[rid].node)
      for token in rules[rid].slaves:
	graph.newLink(rules[rid].node,token.node)

      # Set the user data to link up clickthroughs
      graph.propertyAppend(rules[rid].node,"URL","Rule:%d" % rid)

    # Set entities to be unselected by default
    entities = tokens.values() + rules.values() 
    for entity in entities:
      entity.lolight()


##############################################################################
# Model Classes
#   These are used to represent the different entities inside of EUROPA
##############################################################################

class Variable():
  def __init__(self,key, token, name, domain, values, type):
    self.key = key
    self.token = token 
    self.name = name 
    self.domain = domain
    self.values = values 
    self.type = type

  def __str__(self):
    return "%s = %s (%s)" % (self.name, self.values, self.key)

  def matches(self,pattern):
    matched = False
    matched = matched or str(self.key).find(pattern) != -1
    matched = matched or str(self.name).find(pattern) != -1
    matched = matched or str(self.values).find(pattern) != -1
    matched = matched or str(self.type).find(pattern) != -1
    return matched

class Slot():
  def __init__(self,id,tokens = []):
    self.id = id
    self.tokens = tokens

    self.node = None

  def __str__(self):
    return "Slot (%d)" % (self.id)

class Token():
  def __init__(self,key,slot_id,name,start_key,end_key,slot_index,token_vars):
    self.key = key
    self.name = name
    self.slot_id = slot_id
    self.slot_index = slot_index
    self.start_key = start_key
    self.end_key = end_key

    self.vars = token_vars
    self.node = None

  def __str__(self):
    return "%s (%d)" % (self.name, self.key)

  def matches(self,pattern):
    matched = str(self).find(pattern) != -1

    for var in self.vars:
      matched = matched or var.matches(pattern)

    return matched

  def hilight(self):
    graph.styleApply("TokenHilight", self.node)

  def lolight(self):
    global tick
    if self.slot_id != -1:
      if self.slot_index == 0:
	graph.styleApply("Token", self.node)
      else:
	graph.styleApply("MergedToken", self.node)
    else:
      graph.styleApply("InactiveToken", self.node)

    start_bounds = number_bound_regex.findall(vars[self.start_key].values)
    start_bounds = start_bounds[0].split(" ")

    end_bounds = number_bound_regex.findall(vars[self.end_key].values)
    end_bounds = end_bounds[0].split(" ")

    if len(start_bounds) != 1 and float(start_bounds[1]) > tick and self.slot_index==0:
      graph.styleApply("PlannedToken", self.node)


class Rule():
  def __init__(self,key,name,token,filename,line,slaves=[],vars=[]):
    self.key = key
    self.name = name
    self.token = token
    self.slaves = slaves
    self.vars = vars
    self.filename = filename
    self.line = line

    self.node = None

  def __str__(self):
    return "%s (%d)" % (self.name, self.key)

  def matches(self,pattern):
    return str(self).find(pattern) != -1

  def hilight(self):
    graph.styleApply("RuleHilight", self.node)

  def lolight(self):
    graph.styleApply("Rule", self.node)


##############################################################################
# Hilight Functions
#   These set a given entity a style based on it's properties
##############################################################################

##############################################################################
# Graph Functions
# 
# hilight_graph(search=None,regex=None)
#   This iterates over all tokens anr rules, and applies the correct styles
#   to both of them, based on search criterion and object properties.
#   This accesses the global graph. Styles can be applied and re-applied in
#   GvGen without having to create a new graph
#
# search_graph(dotfile,search=None,regex=None)
#   This calls hilight_graph with the given search criteria, and then performs
#   a deep copy on the graph for generating a dot file.
#   Note that when GvGen creates a dotfile, it is actually destructive to the
#   internal structure of the graph.
#   "dotfile" is a file handle or virtual file handle to which the dotcode is
#   to be written.
# 
# populate_graph(dotfile)
#   This iterates over all structures that model the EUROPA db and
#   instantiates node in the GvGen graph for them. It then calls search_graph
#   with no search criterion and the dotfile handle that was passed to it.
#
# define_graph_styles()
#   This defines all of the relevant styles used by hilight_graph and
#   populate graph. It accesses the global GvGen graph.
##############################################################################

def define_graph_styles():
  graph.styleAppend("Token", "shape", "rectangle")
  graph.styleAppend("Token", "style", "filled")
  graph.styleAppend("Token", "fillcolor", "#EEEEEE")

  graph.styleAppend("TokenHilight", "shape", "rectangle")
  graph.styleAppend("TokenHilight", "style", "filled")
  graph.styleAppend("TokenHilight", "color", "#8F5E03")
  graph.styleAppend("TokenHilight", "fillcolor", "#FFB223")
  graph.styleAppend("TokenHilight", "fontcolor", "#000000")

  graph.styleAppend("PlannedToken", "shape", "rectangle")
  graph.styleAppend("PlannedToken", "style", "filled")
  graph.styleAppend("PlannedToken", "fillcolor", "#666666")
  graph.styleAppend("PlannedToken", "fontcolor", "#CCCCCC")

  graph.styleAppend("MergedToken", "shape", "rectangle")
  graph.styleAppend("MergedToken", "style", "filled")
  graph.styleAppend("MergedToken", "fillcolor", "#CCCCCC")
  graph.styleAppend("MergedToken", "fontcolor", "#444444")

  graph.styleAppend("InactiveToken", "shape", "rectangle")
  graph.styleAppend("InactiveToken", "style", "filled")
  graph.styleAppend("InactiveToken", "fillcolor", "#FFFFFF")
  graph.styleAppend("InactiveToken", "fontcolor", "#444444")

  graph.styleAppend("Rule", "shape", "diamond")
  graph.styleAppend("Rule", "style", "rounded,filled")
  graph.styleAppend("Rule", "fillcolor", "#95AEBC")
  graph.styleAppend("Rule", "color", "#476170")

  graph.styleAppend("RuleHilight", "shape", "diamond")
  graph.styleAppend("RuleHilight", "style", "rounded,filled")
  graph.styleAppend("RuleHilight", "color", "#8F5E03")
  graph.styleAppend("RuleHilight", "fillcolor", "#FFB223")
  graph.styleAppend("RuleHilight", "fontcolor", "#000000")

  graph.styleAppend("Slot", "shape", "rectangle")
  graph.styleAppend("Slot", "style", "rounded,filled")
  graph.styleAppend("Slot", "color", "#CCCCCC")
  graph.styleAppend("Slot", "fontcolor", "#444444")


##############################################################################
# load_data()
#   This reads in the data from the global data_path and tick. It populates
#   the model dictionaries.
##############################################################################

def load_data():
  global slots
  global tokens
  global rules
  global vars
  global rule_src

  slots = {}
  tokens = {}
  rules = {}
  vars = {}
  rule_src = {}

  # Generate the step path
  step_path = os.path.join(data_path, "tick%s" % tick, "tick%s" % tick)

  # Read in rule source code paths
  rule_src_reader = csv.reader(open(os.path.join(data_path,"rules")),delimiter='\t')

  line_regex = re.compile("^(.+)\,([0-9]+)$")
  for row in rule_src_reader:
    rule_name = row[1]
    rule_path_line_str = row[2]

    rule_path_line = line_regex.findall(rule_path_line_str)

    rule_src[rule_name] = rule_path_line[0]

  # Read in tokens
  tokens_reader = csv.reader(open("%s.tokens" % step_path),delimiter='\t')
  for row in tokens_reader:
    token_key = int(row[0])
    slot_id = int(["-1",row[2]][row[2]!='\N'])
    start_key = int(row[7])
    end_key = int(row[8])
    predicate_name = row[11]
    variable_keys = row[15]
    slot_index = int(row[16])

    # Append variable keys
    #token_vars = [int(var) for var in variable_keys.split(':') if var != '' and var != '\N'];

    tokens[token_key] = Token(token_key,slot_id,predicate_name,start_key,end_key,slot_index,[])

    # Append token key to slot
    if slots.has_key(slot_id):
      slots[slot_id].tokens.append(tokens[token_key])
    else:
      slots[slot_id] = Slot(slot_id,[tokens[token_key]])

  # Read in rule instances
  rule_instances_reader = csv.reader(open("%s.ruleInstances" % step_path),delimiter='\t')
  
  for row in rule_instances_reader:
    rule_key = int(row[0])
    rule_name = row[3]
    rule_token_key = int(row[4])
    slave_token_keys = row[5]
    variable_keys = row[6]

    rule_filename = rule_src[rule_name][0]
    rule_line = rule_src[rule_name][1]
    
    # Get rule slaves
    rule_slaves = [tokens[int(slave)] for slave in slave_token_keys.split(',') if slave != '' and slave != '\N'];
    #rule_vars = [int(var) for var in variable_keys.split(',') if var != '' and var != '\N'];

    rules[rule_key] = Rule(rule_key, rule_name, tokens[rule_token_key], rule_filename, rule_line, rule_slaves, [])

  # Read in variables
  vars_reader = csv.reader(open("%s.variables" % step_path),delimiter='\t')
  for row in vars_reader:
    var_key = int(row[0])
    var_token_key = int(row[2])
    var_name = row[3]
    var_domain = row[4]
    var_values = row[5]
    if var_values == '\N':
      var_values = "[%s %s]" % (row[7], row[8])
    var_type = row[9]

    # Add variable reference to token
    entity = None
    if var_type != "MEMBER_VAR":
      if var_type == "RULE_VAR":
	entity = rules[var_token_key]
      else:
	entity = tokens[var_token_key]

    vars[var_key] = Variable(var_key,entity,var_name,var_domain, var_values, var_type)
    if entity:
      entity.vars.append(vars[var_key])

##############################################################################
# main()
#   This instantiates all of the GUI windows, and loads the data from command
#   line arguments.
##############################################################################
def main():
  global log_path
  global tick

  usagestr = """Usage: dbviewer path [tick]
    path: a path to a TREX log file
    tick: a tick during which the assemblies were dumped to disk"""

  # Check arguments
  if len(sys.argv) == 2 and sys.argv[1] == "-h":
    print usagestr
    return

  # Read in arguments
  if len(sys.argv) > 1:
    log_path = sys.argv[1]
  else:
    log_path = "."

  if len(sys.argv) == 3:
    tick = int(sys.argv[2])
  else:
    tick = 0

  # Create a new graph with GvGen
  global graph
  graph = GvGen()

  # Create graph styles
  define_graph_styles()

  # Spawn the dot window
  global window
  window = MyDotWindow()
  window.set_filter('dot')
  window.connect('destroy', gtk.main_quit)

  # Spawn a search window
  global search_window
  search_window = SearchWindow()

  # Spawn a control window
  global control_window
  control_window = ControlWindow()

  # Run gtk
  gtk.main()

if __name__ == '__main__':
  main()
