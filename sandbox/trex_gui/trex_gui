#!/usr/bin/env python
# Software License Agreement (BSD License)
#
# Copyright (c) 2008, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of the Willow Garage nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

__doc__ = """
trex_gui
GUI for TREX."""

# ROS Stuff
PKG = 'trex_gui' # this package name
NAME = 'trex_gui'

import roslib; roslib.load_manifest(PKG)
import rospy
from trex_ros.msg import *

# Python Stuff
import colorsys
import random
import sys
import time
import wx
import math
import bisect

ID_ABOUT=101
ID_EXIT=110

###############################################################################
# Token
###############################################################################
class Token():
  def __init__(self, token, timeline):
    self.name = token.name
    self.start = [int(t) for t in token.start]
    self.end = [int(t) for t in token.end]
    self.key = int(token.key)

    self.timeline = timeline
    self.active = True
    self.tick = 0

class Timeline():
  def __init__(self, name, index, color='#333333'):
    # Constant properties
    self.name = name
    self.index = index
    self.color = color
    
    # Data
    self.tokens = []

    # Drawing counters
    self.earliest_start = 0
    self.latest_end = 0

class Plan():
  def __init__(self, name='', timelines=[]):
    self.name = name
    self.timelines = timelines


###############################################################################
# TimelineLabelCanvas 
###############################################################################
class TimelineLabelCanvas(wx.ScrolledWindow):
  def __init__(self, parent, id=wx.ID_ANY ):
    wx.ScrolledWindow.__init__(self, parent, id=wx.ID_ANY, style=wx.VSCROLL|wx.FULL_REPAINT_ON_RESIZE|wx.ALWAYS_SHOW_SB)
    
    # Store members
    self.reactor = parent

    # Set up scrolling
    self.EnableScrolling(True,True)
    self.SetVirtualSize(size = (200, 400))
    self.SetScrollRate(1,self.reactor.TIMELINE_HEIGHT+self.reactor.TIMELINE_SPACE)

    # Bind repaint events
    self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
    self.Bind(wx.EVT_PAINT, self.OnPaint)

  def OnEraseBackground(self, event):
    pass

  def OnPaint(self, event):
    if self.reactor.plan_desc.name is not '':
      # Capture the controller states
      self.tick_scale = self.reactor.trex_frame.tick_scale.GetValue()/10.0

      # Update virtual size
      self.SetVirtualSize(size=(200, len(self.reactor.plan.timelines)*(self.reactor.TIMELINE_HEIGHT+self.reactor.TIMELINE_SPACE)))

      # Paint
      dc = wx.BufferedPaintDC(self)
      self.DoPrepareDC(dc) 
      dc.Clear()

      self.tl_index = 0

      # Draw labels
      for timeline in self.reactor.plan_desc.internal + self.reactor.plan_desc.external:
	self.draw_label(dc,timeline.name)
	self.tl_index = self.tl_index+1

  def draw_label(self, dc, name):
    tl_origin_x = 0
    tl_origin_y = (self.reactor.TIMELINE_HEIGHT+self.reactor.TIMELINE_SPACE)*self.tl_index

    dc.SetPen(wx.Pen('#4c4c4c', 0, wx.SOLID))
    dc.DrawRectangle(-10, tl_origin_y, 250, self.reactor.TIMELINE_HEIGHT)

    dc.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL,wx.FONTWEIGHT_NORMAL, False))
    w,h = dc.GetTextExtent(name)
    dc.DrawText(name,tl_origin_x+200-w-5,tl_origin_y+1)


###############################################################################
# TimelineTokenCanvas 
###############################################################################
class TimelineTokenCanvas(wx.ScrolledWindow):
  def __init__(self, parent, id=wx.ID_ANY ):
    wx.ScrolledWindow.__init__(self, parent, id=wx.ID_ANY, style=wx.VSCROLL|wx.HSCROLL|wx.ALWAYS_SHOW_SB|wx.FULL_REPAINT_ON_RESIZE)

    # Store members
    self.reactor = parent
    
    # Set up scrolling
    self.EnableScrolling(True,True)
    self.SetVirtualSize(size = (10, 10))
    self.SetScrollRate(1,self.reactor.TIMELINE_HEIGHT+self.reactor.TIMELINE_SPACE)

    # Set to scroll to the frontier by default
    self.scroll_to_frontier = True

    # Set up so that the scroll bar sticks to the frontier
    self.Bind(wx.EVT_SCROLLWIN, self.OnScrollWin)

    # Bind repaint events
    self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
    self.Bind(wx.EVT_PAINT, self.OnPaint)

  def OnButton(self, event, source):
    print source

  def OnEraseBackground(self, event):
    pass

  def OnScrollWin(self, event):
    # If we were close enough to the frontier, stick to it
    dist_from_edge = abs(self.GetViewStart()[0] - (self.GetVirtualSize()[0] - self.GetScrollPageSize(wx.SB_HORIZONTAL)))
    if  dist_from_edge < self.tick_ahead:
      self.scroll_to_frontier = True
    else:
      self.scroll_to_frontier = False
    event.Skip()

  def OnPaint(self, event):
    if self.reactor.plan_desc.name is not '':
      # Get the current tick
      self.tick = self.reactor.plan_desc.tick
      self.reactor.trex_frame.SetStatusText("Tick %d" % (self.tick))

      # Capture the control states
      self.tick_scale = self.reactor.trex_frame.tick_scale.GetValue()/10.0
      self.tick_ahead = self.reactor.trex_frame.tick_ahead.GetValue()
      self.tick_behind = self.reactor.trex_frame.tick_behind.GetValue()

      # Update scrollbars
      self.tick_window = (self.tick_behind+self.tick, self.tick+self.tick_ahead)
      virtsize = (self.tick_scale*(self.tick_behind + self.tick_ahead))
      self.SetVirtualSize(size=(virtsize, len(self.reactor.plan.timelines)*(self.reactor.TIMELINE_HEIGHT+self.reactor.TIMELINE_SPACE)))

      # Scroll to the execution frontier if requested
      if self.scroll_to_frontier:
	self.Scroll(self.tick_scale*self.tick_behind,self.GetViewStart()[1])

      # Paint
      dc = wx.BufferedPaintDC(self)
      self.DoPrepareDC(dc) 
      self.SetBackgroundColour('BLACK')
      dc.Clear()

      #self.tl_index = 0

      # Draw execution frontier
      dc.SetPen(wx.Pen('#FFFFFF', 0, wx.TRANSPARENT))
      dc.SetBrush(wx.Brush('#AAAAAA'))
      dc.DrawRectangle(self.tick_scale*self.tick_behind, 0, self.tick_scale*self.tick_ahead, 4000)


      # Draw the tokens in each timeline
      dc.SetPen(wx.Pen('#FFFFFF', 0, wx.SOLID))

      # Initialize earliest start tick
      earliest_start = 0
      latest_end = 0

      for tl in self.reactor.plan.timelines:
	tl.earliest_start = 0
	tl.latest_end = 0

      font_label = wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL,wx.FONTWEIGHT_NORMAL, False, 'Andale Mono')
      font_times = wx.Font(8, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL,wx.FONTWEIGHT_NORMAL, False, 'Andale Mono')

      for key in self.reactor.started_token_keys[::-1] + self.reactor.planned_token_keys:
	# Get token
	token = self.reactor.all_tokens[key]

	if token.tick < self.reactor.plan_desc.tick-50:
	  continue

	#DEBUGprint "TICK: %d, EARLIEST_START: %d, LATEST_END: %d" % (self.reactor.plan_desc.tick, earliest_start, latest_end)

	# Create the label string, and get the length of the label
	label_str = " %s " % (token.name.split('.')[1])#, int(str(token.key)))
	dc.SetFont(font_label)
	w_label, h_ = dc.GetTextExtent(label_str)

	end_str = "[%d, %d]" % (token.start[0], token.end[0])
	dc.SetFont(font_times)
	w_end_str, h_ = dc.GetTextExtent(end_str)

	# Get the max width of the label
	tok_width_label = max(w_label,w_end_str)

	# Switch draw behavior if this token has started or is planned
	HORZ_OFFSET = 2000
	if token.start[0] == token.start[1]:
	  # Has started
	  # Calculate the token pixel width
	  # Get the width if this token were to be drawn between the latest point on this timeline, and the earliest point for all timelines
	  tok_width_sync = abs(token.timeline.earliest_start - earliest_start)

	  # Get the larger of the two widths
	  tok_width = 5 + max(tok_width_label, tok_width_sync)

	  # Calculate the token end point
	  # This is the start of the earliest token on the timeline that this token is being drawn onto
	  tok_end = token.timeline.earliest_start

	  # Increment earliest start for this timelines
	  token.timeline.earliest_start = token.timeline.earliest_start - tok_width
	  # Set the new earliest start for all timelines
	  earliest_start = min(earliest_start, token.timeline.earliest_start)

	  # Calculate the position top-right corner of the token
	  tok_x0 = HORZ_OFFSET+math.ceil(tok_end)
	  tok_y0 = math.ceil((self.reactor.TIMELINE_HEIGHT+self.reactor.TIMELINE_SPACE)*token.timeline.index)

	  #print "TOKEN \"%s\" ADD WIDTH: %d = max( abs( %d - %d ), %d )" % (token.name,tok_width, token.timeline.earliest_start, earliest_start, tok_width_label)
	else:
	  # Is planned
	  # Calculate the token pixel width
	  # Get the width if this token were to be drawn between the latest point on this timeline, and the earliest point for all timelines
	  tok_width_sync = abs(latest_end - token.timeline.latest_end)

	  # Get the larger of the two widths
	  tok_width = 5 + max(tok_width_label, tok_width_sync)

	  # Calculate the token end point
	  # This is the start of the earliest token on the timeline that this token is being drawn onto
	  tok_start = token.timeline.latest_end

	  # Increment earliest start for this timelines
	  token.timeline.latest_end = token.timeline.latest_end + tok_width
	  # Set the new earliest start for all timelines
	  latest_end = max(latest_end, token.timeline.latest_end)

	  # Calculate the position top-right corner of the token
	  tok_x0 = HORZ_OFFSET+math.ceil(tok_start+tok_width)
	  tok_y0 = math.ceil((self.reactor.TIMELINE_HEIGHT+self.reactor.TIMELINE_SPACE)*token.timeline.index)


	# Draw token
	# Set the color for the appropriate reactors
	if token.tick < self.reactor.plan_desc.tick:
	  color = '#BBBBBB'
	else:
	  color = token.timeline.color

	dc.SetBrush(wx.Brush(color))

	# Draw the token rectangle
	dc.DrawRectangle(tok_x0, tok_y0, -tok_width, self.reactor.TIMELINE_HEIGHT)
	# Draw the token label
	dc.SetFont(font_label)
	dc.SetTextForeground(wx.Colour(255,255,255,255))
	dc.DrawText(label_str,tok_x0-w_label,tok_y0)

	# Draw the time bounds
	dc.SetFont(font_times)
	dc.SetTextForeground(wx.Colour(64,64,64,255))
	dc.DrawText(end_str,tok_x0-w_end_str,tok_y0+self.reactor.TIMELINE_HEIGHT)
      
  def draw_timeline(self, dc):
    dc.SetPen(wx.Pen('#AAAAAA', 0, wx.TRANSPARENT))
    dc.SetBrush(wx.Brush('#AAAAAA'))
    tok_y0 = math.ceil((self.reactor.TIMELINE_HEIGHT+8)*self.tl_index)
    dc.DrawRectangle(0, tok_y0, self.tick_scale*(self.tick_behind + self.tick_ahead), self.reactor.TIMELINE_HEIGHT)

  def draw_token(self, dc, token):
    tok_x0 = math.ceil(self.tick_scale*(token.end[0] - (self.tick-self.tick_behind)))
    tok_y0 = math.ceil((self.reactor.TIMELINE_HEIGHT+8)*self.tl_index)

    tok_width = math.ceil(self.tick_scale*(token.end[0]-token.start[0]))
    tok_width = min(tok_width, self.tick_scale*(self.tick_behind+self.tick_ahead))

    # Draw token
    dc.DrawRectangle(tok_x0, tok_y0, -max(1,tok_width), self.reactor.TIMELINE_HEIGHT)

    # label
    splitname = token.name.split('.')[1]
    dc.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL,wx.FONTWEIGHT_NORMAL, False))
    w,h = dc.GetTextExtent(splitname)
    dc.DrawText(splitname,tok_x0-w-5,tok_y0+1)


###############################################################################
# ReactorPanel 
# This class creates a reactor view which shows timeline labels and tokens
###############################################################################
class ReactorPanel(wx.Panel):
  def __init__(self, parent, trex_frame, color, id=wx.ID_ANY):
    wx.Panel.__init__(self, parent, id)

    self.trex_frame = trex_frame
    self.color = color
    self.plan_desc = PlanDescription()
    self.plan = Plan('UNDEFINED',[])

    # Data structures
    self.all_tokens = dict()
    self.started_token_keys = []
    self.planned_token_keys = []

    self.started_token_times = []
    self.planned_token_times = []

    self.TIMELINE_HEIGHT = 20
    self.TIMELINE_SPACE = 20
    self.synced = True

    # Timeline label sub-panel
    self.labels_p = TimelineLabelCanvas(self)

    # Timeline sub-panel
    self.timelines_p = TimelineTokenCanvas(self)

    # Sizer
    vbox = wx.FlexGridSizer(1,2,0,0)
    vbox.Add(self.labels_p, 1, wx.EXPAND, 0)
    vbox.Add(self.timelines_p, 1, wx.EXPAND, 0)
    self.labels_p.SetMinSize((220,10))
    vbox.AddGrowableRow(0,1)
    vbox.AddGrowableCol(1,1)
    self.SetSizer(vbox)

    # Synchronize scrolling
    self.labels_p.Bind(wx.EVT_SCROLLWIN ,self.sync_vscroll)
    self.timelines_p.Bind(wx.EVT_SCROLLWIN ,self.sync_vscroll)

  def sync_vscroll(self,event):
    if self.synced and event.GetOrientation() is wx.VERTICAL:
      self.synced = False
      if event.GetEventObject() is self.timelines_p:
	self.labels_p.GetEventHandler().ProcessEvent(event)
	wx.PostEvent(self.labels_p,wx.PaintEvent())
      else:
	self.timelines_p.GetEventHandler().ProcessEvent(event)
	wx.PostEvent(self.timelines_p,wx.PaintEvent())
    self.synced = True
    event.Skip()

  def subscribe(self,topic):
    # Subscribe to plan topic
    print 'Subscribing to "%s\"' % (topic)
    rospy.Subscriber(topic, PlanDescription, self.update_plan, topic)

  def update_plan(self, plan_desc, arg):
    # Load new data
    self.plan_desc = plan_desc
    self.plan = Plan(plan_desc.name, self.plan.timelines)
    
    # Get a sorted list of all token start times
    started_tokens = []
    planned_tokens = [] 

    # Find latest-starting token
    for tl_desc in plan_desc.internal+plan_desc.external:

      # Find this timeline
      tl_match = [t for t in self.plan.timelines if t.name == tl_desc.name]

      # Create new timeline with name and row index
      if len(tl_match) is 0:
	print "NEW TIMELINE: " + tl_desc.name
	print [t.name for t in self.plan.timelines]
	tl = Timeline(tl_desc.name, len(self.plan.timelines), color='#FFFFFF')
	self.plan.timelines.append(tl)
      else:
	tl = tl_match[0]
      
      tl.color = self.trex_frame.get_tl_color(tl_desc.name)

      for token_desc in tl_desc.tokens:
	# Creae a new token from this token_desc
	new_token = Token(token_desc,tl)

	if new_token.key in self.all_tokens:
	  # Check if this token is planned from the previous tick
	  # This means that it might have started on this one, also it's start time is not yet closed,
	  # so we need to remove it before sorting
	  if new_token.key in self.planned_token_keys:
	    # Get the index in the sorted lists of this token
	    sorted_index = self.planned_token_keys.index(new_token.key)
	    # Remove from the sorted lists
	    self.planned_token_times.pop(sorted_index)
	    self.planned_token_keys.pop(sorted_index)
	else:
	  # Add this new token to all_tokens
	  self.all_tokens[new_token.key] = new_token

	# Update last updated tick for this token
	self.all_tokens[new_token.key] = new_token
	self.all_tokens[new_token.key].tick = self.plan_desc.tick

	# Insort this token to the appropriate sorted token list
	if token_desc.start[0] == token_desc.start[1]:
	  # Check if we need to add this to started_tokens
	  insert_index_start = bisect.bisect_left(self.started_token_times, new_token.start[0])
	  insert_index_end = bisect.bisect_right(self.started_token_times, new_token.start[0])

	  #print "LIST LENGTH: %d" % (len(self.started_token_times))
	  #print "INSERT INDEX: %d" % (insert_index)
	  if insert_index_start >= len(self.started_token_keys) or new_token.key not in self.started_token_keys[insert_index_start:insert_index_end]:
	    self.started_token_keys.insert(insert_index_start,new_token.key)
	    self.started_token_times.insert(insert_index_start,new_token.start[0])
	else:
	  # Check if we need to add this to planned_tokens
	  insert_index_start = bisect.bisect_left(self.planned_token_times, new_token.start[0])
	  insert_index_end = bisect.bisect_right(self.planned_token_times, new_token.start[0])

	  #print "LIST LENGTH: %d" % (len(self.planned_token_times))
	  #print "INSERT INDEX: %d" % (insert_index)
	  if insert_index_start >= len(self.planned_token_keys) or new_token.key not in self.planned_token_keys[insert_index_start:insert_index_end]:
	    self.planned_token_keys.insert(insert_index_start,new_token.key)
	    self.planned_token_times.insert(insert_index_start,new_token.start[0])

    # Make sure this reactor is selected before we repaint it
    if self is self.trex_frame.reactors_nb.GetCurrentPage():
      wx.PostEvent(self.labels_p,wx.PaintEvent())
      wx.PostEvent(self.timelines_p,wx.PaintEvent())


###############################################################################
# TREXFrame 
###############################################################################
class TREXFrame(wx.Frame):
  def __init__(self, parent, id, title):
    wx.Frame.__init__(self, parent, id, title, size=(1024,480))

    # Initialization
    self.reactor_panels = []

    font = wx.SystemSettings_GetFont(wx.SYS_SYSTEM_FONT)
    font.SetPointSize(9)

    self.CreateStatusBar()

    # Menu bar
    self.create_menu_bar()

    # Main split
    mainsplit = wx.SplitterWindow(self)
    # Reactor pane
    reactors_panel = wx.Panel(mainsplit)
    reactors_box = wx.BoxSizer(wx.HORIZONTAL)
    self.reactors_nb = wx.Notebook(reactors_panel, -1, style=wx.NB_BOTTOM)
    self.reactors_colorlist = []
    self.reactors_imagelist = wx.ImageList(16,16)
    self.reactors_nb.SetImageList(self.reactors_imagelist)
    random.seed(23)

    reactors_box.Add(self.reactors_nb, 1, wx.EXPAND | wx.ALL, 0)
    reactors_panel.SetSizer(reactors_box)

    # Controls
    self.controls_panel = wx.ScrolledWindow(mainsplit)
    controls_box = wx.BoxSizer(wx.VERTICAL)

    ##################
    time_sizer = wx.StaticBoxSizer(wx.StaticBox(self.controls_panel, -1, 'Time Options'), orient=wx.VERTICAL)
    self.expand_metric_time = wx.CheckBox(self.controls_panel, -1, 'Expand tokens to metric time', style=wx.RB_GROUP)
    time_sizer.Add(self.expand_metric_time)

    # Controls for lookahead and lookbehind 
    panel1 = wx.Panel(self.controls_panel, -1)
    grid1 = wx.GridSizer(3, 2)
    self.tick_behind = wx.SpinCtrl(panel1, min=1, max=10000, initial=300)
    self.tick_ahead = wx.SpinCtrl(panel1,  min=1, max=1000, initial=25)
    self.tick_scale = wx.SpinCtrl(panel1,  min=1, max=10000, initial=20)

    grid1.Add(wx.StaticText(panel1, -1, 'Lookbehind: ', (5, 5)), 0,  wx.ALIGN_CENTER_VERTICAL)
    grid1.Add(self.tick_behind)
    grid1.Add(wx.StaticText(panel1, -1, 'Lookahead: ', (5, 5)), 0, wx.ALIGN_CENTER_VERTICAL)
    grid1.Add(self.tick_ahead)
    grid1.Add(wx.StaticText(panel1, -1, 'Tick Size: ', (5, 5)), 0, wx.ALIGN_CENTER_VERTICAL)
    grid1.Add(self.tick_scale)

    panel1.SetSizer(grid1)

    time_sizer.Add(panel1, 0, wx.BOTTOM | wx.TOP, 9)
    controls_box.Add(time_sizer, 1)
    #################
    disp_sizer = wx.StaticBoxSizer(wx.StaticBox(self.controls_panel, -1, 'Display Options'), orient=wx.VERTICAL)

    # Controls for display
    disp_sizer.Add(wx.CheckBox(self.controls_panel, -1, 'Show garbage collected tokens', style=wx.RB_GROUP))
    disp_sizer.Add(wx.CheckBox(self.controls_panel, -1, 'Show all token labels', style=wx.RB_GROUP))

    controls_box.Add(disp_sizer, 1)
    #################

    disp_sizer = wx.StaticBoxSizer(wx.StaticBox(self.controls_panel, -1, 'Reactor Options'), orient=wx.VERTICAL)

    # Controls for display
    disp_sizer.Add(wx.ColourPickerCtrl(self.controls_panel, -1))

    controls_box.Add(disp_sizer, 1)
    #################
    self.controls_panel.SetSizer(controls_box)

    # Load into mainsplit
    mainsplit.SplitVertically(reactors_panel,self.controls_panel,-250)
    mainsplit.SetSashGravity(1.0)

    # Center and show the window
    self.Centre()
    self.Show(True)
  
  def create_menu_bar(self):
    filemenu=wx.Menu()
    filemenu.Append(ID_ABOUT,"&About","Information about this program")
    filemenu.AppendSeparator()
    filemenu.Append(ID_EXIT, "E&xit","Terminate the program")

    menuBar = wx.MenuBar()
    menuBar.Append(filemenu,"&File")
    self.SetMenuBar(menuBar)

  def add_reactor_panel(self, topic):
    # Generate an icon for this reactor
    cs = wx.EmptyBitmap(16,16)
    dc = wx.MemoryDC(cs)


    rgb = colorsys.hsv_to_rgb(len(self.reactor_panels)/float(self.n_reactors),0.3,0.4)
    color = "#%02x%02x%02x" % (255*rgb[0], 255*rgb[1], 255*rgb[2]) 
    self.reactors_colorlist.append(color)
    dc.SetBrush(wx.Brush(color))
    dc.DrawRectangle(0,0,16,16)
    dc.SelectObject(wx.NullBitmap)

    # Create a new reactor panel, and subscribe to its topic
    new_panel = ReactorPanel(self.reactors_nb, self, color, wx.ID_ANY)
    new_panel.subscribe(topic)

    icon_index = self.reactors_imagelist.Add(cs)
    # Store the new panel, and add it to the notebook
    self.reactor_panels.append(new_panel)
    self.reactors_nb.AddPage(new_panel, topic.split('/')[1],imageId=icon_index)

  def get_tl_color(self, name):
    for reactor in self.reactor_panels:
      for tl in reactor.plan_desc.internal:
	if tl.name == name:
	  return reactor.color
    return '#333333'

    
###############################################################################
# MainApp 
# Main ROS App
###############################################################################
class MainApp(wx.App):
  def OnInit(self):
    # Create a TREXFrame
    self.frame = TREXFrame(None, wx.ID_ANY, "T-REX")
  
    # Get all topics broadcasting PlanDescriptions
    plan_topics = [topic[0] for topic in rospy.get_published_topics() if topic[1]=='trex_ros/PlanDescription']
    # Subscribe to them and create ReactorPanel structures
    self.frame.n_reactors = len(plan_topics)
    for topic in plan_topics:
      self.frame.add_reactor_panel(topic)

    self.frame.Show(True)
    self.SetTopWindow(self.frame)
    return True

  # Callback for registering new plan data
  def update_plan(self, data, arg):
    #print "got plan from %s!" % data.name
    pass

if __name__=='__main__':
  # Initialize node
  rospy.init_node("trex_gui")

  # Spawn window
  app = MainApp()

  # Run GUI
  app.MainLoop()
